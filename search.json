[{"title":"go-practice-follow-offical-tour","url":"http://dearxiaojie.top/article/2018-06-15-go-practice-follow-offical-tour.html","content":"<p>最近在学习go相关的东西，以下为<a href=\"https://tour.go-zh.org/welcome/1\" target=\"_blank\" rel=\"noopener\">Go官方指南</a>中的练习记录</p>\n<ol>\n<li><p>循环与函数</p>\n<blockquote>\n<p>实现一个平方根函数：用<a href=\"https://zh.wikipedia.org/wiki/%E7%89%9B%E9%A1%BF%E6%B3%95\" target=\"_blank\" rel=\"noopener\">牛顿法</a>实现平方根函数</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Sqrt</span><span class=\"params\">(x <span class=\"keyword\">float64</span>)</span> <span class=\"title\">float64</span></span> &#123;</span><br><span class=\"line\">    z := x / <span class=\"number\">2</span></span><br><span class=\"line\">    cnt := <span class=\"number\">10</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> cnt &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        z -= (z * z - x) / (<span class=\"number\">2</span> * z)</span><br><span class=\"line\">        cnt = cnt - <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> z</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    fmt.Println(Sqrt(<span class=\"number\">3</span>)) <span class=\"comment\">// 1.7320508075688772</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</blockquote>\n</li>\n<li><p>切片</p>\n<blockquote>\n<p>实现 Pic。它应当返回一个长度为 dy 的切片，其中每个元素是一个长度为 dx，元素类型为 uint8 的切片。<br>当你运行此程序时，它会将每个整数解释为灰度值（好吧，其实是蓝度值）并显示它所对应的图像</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"golang.org/x/tour/pic\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Pic</span><span class=\"params\">(dx, dy <span class=\"keyword\">int</span>)</span> [][]<span class=\"title\">uint8</span></span> &#123;</span><br><span class=\"line\">    pic := <span class=\"built_in\">make</span>([][]<span class=\"keyword\">uint8</span>, dy*dx)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; dy; i++ &#123;</span><br><span class=\"line\">        in := <span class=\"built_in\">make</span>([]<span class=\"keyword\">uint8</span>, dx)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j := <span class=\"number\">0</span>; j &lt; dx; j++ &#123;</span><br><span class=\"line\">            in[j] = <span class=\"keyword\">uint8</span>(<span class=\"number\">1</span> &lt;&lt; <span class=\"keyword\">uint8</span>(j%<span class=\"number\">8</span>))</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        pic[i] = in</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pic</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    pic.Show(Pic)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</blockquote>\n</li>\n<li><p>映射</p>\n<blockquote>\n<p>实现 WordCount。它应当返回一个映射，其中包含字符串 s 中每个“单词”的个数。函数 wc.Test 会对此函数执行一系列测试用例，并输出成功还是失败</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">\"strings\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"string\">\"golang.org/x/tour/wc\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">WordCount</span><span class=\"params\">(s <span class=\"keyword\">string</span>)</span> <span class=\"title\">map</span>[<span class=\"title\">string</span>]<span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">    m := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">int</span>)</span><br><span class=\"line\">    field := strings.Fields(s)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(field); i++ &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> m[field[i]] &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">            m[field[i]] = m[field[i]] + <span class=\"number\">1</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            m[field[i]] = <span class=\"number\">1</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> m</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* output</span></span><br><span class=\"line\"><span class=\"comment\">func main() &#123;</span></span><br><span class=\"line\"><span class=\"comment\">    wc.Test(WordCount)</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">PASS</span></span><br><span class=\"line\"><span class=\"comment\"> f(\"I am learning Go!\") =</span></span><br><span class=\"line\"><span class=\"comment\">  map[string]int&#123;\"I\":1, \"am\":1, \"learning\":1, \"Go!\":1&#125;</span></span><br><span class=\"line\"><span class=\"comment\">PASS</span></span><br><span class=\"line\"><span class=\"comment\"> f(\"The quick brown fox jumped over the lazy dog.\") =</span></span><br><span class=\"line\"><span class=\"comment\">  map[string]int&#123;\"dog.\":1, \"The\":1, \"fox\":1, \"over\":1, \"the\":1, \"quick\":1, \"brown\":1, \"jumped\":1, \"lazy\":1&#125;</span></span><br><span class=\"line\"><span class=\"comment\">PASS</span></span><br><span class=\"line\"><span class=\"comment\"> f(\"I ate a donut. Then I ate another donut.\") =</span></span><br><span class=\"line\"><span class=\"comment\">  map[string]int&#123;\"another\":1, \"I\":2, \"ate\":2, \"a\":1, \"donut.\":2, \"Then\":1&#125;</span></span><br><span class=\"line\"><span class=\"comment\">PASS</span></span><br><span class=\"line\"><span class=\"comment\"> f(\"A man a plan a canal panama.\") =</span></span><br><span class=\"line\"><span class=\"comment\">  map[string]int&#123;\"plan\":1, \"canal\":1, \"panama.\":1, \"A\":1, \"man\":1, \"a\":2&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n</blockquote>\n</li>\n<li><p>斐波纳契闭包</p>\n<blockquote>\n<p>实现一个 fibonacci 函数，它返回一个函数（闭包），该闭包返回一个<a href=\"https://zh.wikipedia.org/wiki/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97\" target=\"_blank\" rel=\"noopener\">斐波纳契数列</a> <code>(0, 1, 1, 2, 3, 5, ...)</code>。</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">fibonacci</span><span class=\"params\">()</span> <span class=\"title\">func</span><span class=\"params\">()</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">    a, b, c := <span class=\"number\">-1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> a == <span class=\"number\">-1</span> &#123;</span><br><span class=\"line\">            a = <span class=\"number\">0</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> a</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> a == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">            a = <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> a</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            c = a + b</span><br><span class=\"line\">            b = a</span><br><span class=\"line\">            a = c</span><br><span class=\"line\">            <span class=\"keyword\">return</span> c</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    f := fibonacci()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++ &#123;</span><br><span class=\"line\">        fmt.Println(f())</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 0, 1, 1, 2, 3, 5, 8, 13, 21, 34</span></span><br></pre></td></tr></table></figure>\n</blockquote>\n</li>\n<li><p>note(方法与指针)</p>\n<blockquote>\n<ol>\n<li>带指针参数的函数必须接受一个指针,而以指针为接收者的方法被调用时，接收者既能为值又能为指针。<br>由于指针参数的函数方法有一个指针接收者，为方便起见，Go 会将语句 v.Scale(5) 解释为 (&amp;v).Scale(5)；</li>\n<li>接受一个值作为参数的函数必须接受一个指定类型的值，而以值为接收者的方法被调用时，接收者既能为值又能为指针，方法调用 p.Abs() 会被解释为 (*p).Abs()</li>\n<li>使用指针接收者的原因有二：<br>首先，方法能够修改其接收者指向的值。<br>其次，这样可以避免在每次调用方法时复制该值。若值的类型为大型结构体时，这样做会更加高效。</li>\n</ol>\n</blockquote>\n</li>\n</ol>\n<!-- next start https://tour.go-zh.org/methods/9 -->\n","categories":[],"tags":[]},{"title":"陌与墨语","url":"http://dearxiaojie.top/article/2018-05-04-陌与墨语.html","content":"<p>似乎很久没写博客了，今天趁上班摸鱼时间，想着干点啥，那就写写自己博客吧。</p>\n<p>回忆第一次在github上搭博客以来，已经换了三个域名了，从最初的xiaojwithu.info到后来的dearxiaojie.xyz,两个域名都只维持了一年的时间就没有续费了，当时只是出于玩的目的，所以并没有花什么精力在上面。再看写过的文章，大多都是笔试面试，学习笔记，采坑总结，没有半点干货输出。但是我不会删掉它们，一是因为删了就没内容了（囧…），其次，那也是自己写博客的开始，留点记忆吧。目前换成了新的域名dearxiaojie.top，时间也更长了些，前些天github pages正好支持https了，也将博客设置成https的了。</p>\n<p>心里一直有个todolist，但是却久未执行。可能是工作时间长了精力也分散了，买的一摞书也只是堆在那，偶尔躺床上的时候翻开几页看看，和买书时的初衷有些相悖。面对快速更新的技术，有时候显得手足无措。虽然自己知道应该从哪开始，选择哪些，但是心里还是会有莫名的慌乱，学的越多越觉得自己知道的太少，以至于觉得要学的东西就更多，甚至就偏离了方向。</p>\n<p>将TODO列出来一个一个执行我估计我还是办不到，至少现在没有心思去整理。</p>\n<p>虽不是得过且过，但我一直坚持在学习。</p>\n<p>我告诉自己，接下来的路还很长。</p>\n<p>以后还是多更新博客吧。</p>\n","categories":[],"tags":["随笔"]},{"title":"使用JavaScript处理点九图","url":"http://dearxiaojie.top/article/2018-01-09-use-javascript-to-handle-9-patch.html","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在前端开发中，常会将图片作为某个元素的背景图，但是背景图的大小和比例和元素有偏差，所以一般要使元素有全背景的话，只能将图片拉伸。这里不考虑<code>background-repeat</code>。最好的办法还是将图片修改为比例和元素相同以等比缩放。<br>使用微信或者QQ的人应该会发现聊天气泡，气泡会随着内容多少的改变而去适应它，但是并没有使气泡图片有拉伸的效果，这里就用到了<a href=\"https://developer.android.com/guide/topics/graphics/2d-graphics.html#nine-patch\" target=\"_blank\" rel=\"noopener\">点九图</a></p>\n<h2 id=\"点九图\"><a href=\"#点九图\" class=\"headerlink\" title=\"点九图\"></a>点九图</h2><p>关于点九图这里不做过多介绍，简单来说，它是<code>andriod</code>平台的应用软件开发里的一种特殊的图片形式，扩展名为<code>.9.png</code>。它有两个重要的特点是：四周必须要有四条一像素纯黑的线或点；左上两条线控制拉伸区，右下两条线控制内容区。<br>这里我们需要将上传的点九图片拉伸成指定的或者自适应的比例，在没有接触点九图之前根本没有任何想法，于是上<code>github</code>上找到一个在web端处理点九图的<a href=\"https://github.com/chrislondon/9-Patch-Image-for-Websites\" target=\"_blank\" rel=\"noopener\">库</a>，将代码拉取到本地即可看到<code>demo</code>。</p>\n<h2 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h2><p>阅读源码发现主要使用<code>border-image</code>和用<code>canvas</code>绘制两种方式实现。首先先取出点九图左边和上边<code>1px</code>，这里以水平方向为例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">let tempCtx, tempCanvas;</span><br><span class=\"line\">tempCanvas = document.createElement(&apos;canvas&apos;);</span><br><span class=\"line\">tempCtx = tempCanvas.getContext(&apos;2d&apos;);</span><br><span class=\"line\">tempCtx.drawImage(this.bgImage, 0, 0);</span><br><span class=\"line\">let data = tempCtx.getImageData(0, 0, this.bgImage.width, 1).data;</span><br></pre></td></tr></table></figure>\n<p>上面的<code>data</code>存放的为只读的<code>ImageData.data</code>属性，返回<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray\" target=\"_blank\" rel=\"noopener\"><code>Uint8ClampedArray</code></a>,描述一个一维数组，包含以 <code>RGBA</code> 顺序的数据，数据使用 <code>0</code> 至 <code>255</code>（包含）的整数表示。然后遍历这个一维数组，每<code>4</code>位一个<code>step</code>，找到可拉伸的区间数量和区域。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">NinePatch.prototype.getPieces = function(data, staticColor, repeatColor) &#123;</span><br><span class=\"line\">    var tempDS, tempPosition, tempWidth, tempColor, tempType;</span><br><span class=\"line\">    var tempArray = new Array();</span><br><span class=\"line\"></span><br><span class=\"line\">    tempColor = data[4] + &apos;,&apos; + data[5] + &apos;,&apos; + data[6] + &apos;,&apos; + data[7];</span><br><span class=\"line\">    tempDS = (tempColor == staticColor ? &apos;s&apos; : (tempColor == repeatColor ? &apos;r&apos; : &apos;d&apos;));</span><br><span class=\"line\">    tempPosition = 1;</span><br><span class=\"line\"></span><br><span class=\"line\">    for (var i = 4, n = data.length - 4; i &lt; n; i += 4) &#123;</span><br><span class=\"line\">        tempColor = data[i] + &apos;,&apos; + data[i + 1] + &apos;,&apos; + data[i + 2] + &apos;,&apos; + data[i + 3];</span><br><span class=\"line\">        tempType = (tempColor == staticColor ? &apos;s&apos; : (tempColor == repeatColor ? &apos;r&apos; : &apos;d&apos;));</span><br><span class=\"line\">        if (tempDS != tempType) &#123;</span><br><span class=\"line\">            // box changed colors</span><br><span class=\"line\">            tempWidth = (i / 4) - tempPosition;</span><br><span class=\"line\">            tempArray.push(new Array(tempDS, tempPosition, tempWidth));</span><br><span class=\"line\"></span><br><span class=\"line\">            tempDS = tempType;</span><br><span class=\"line\">            tempPosition = i / 4;</span><br><span class=\"line\">            tempWidth = 1</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // push end</span><br><span class=\"line\">    tempWidth = (i / 4) - tempPosition;</span><br><span class=\"line\">    tempArray.push(new Array(tempDS, tempPosition, tempWidth));</span><br><span class=\"line\"></span><br><span class=\"line\">    return tempArray;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面的<code>getPieces</code>方法存放了可用于判断拉伸区间数量和可拉伸范围的数组。在将其传入绘制函数中。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">for (var i = 0, n = this.horizontalPieces.length; i &lt; n; i++) &#123;</span><br><span class=\"line\">    if (this.horizontalPieces[i][0] == &apos;s&apos;) &#123;</span><br><span class=\"line\">        tempStaticWidth += this.horizontalPieces[i][2];</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        tempDynamicCount++; // 拉伸区间数量</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">fillWidth = (dWidth - tempStaticWidth) / tempDynamicCount;  // 可拉伸区间</span><br></pre></td></tr></table></figure></p>\n<p>再将取得的水平和垂直的<code>1px</code>获取到的数组进行嵌套循环，去填充拉伸图片，这里就不贴代码了，可以查阅源码理解。</p>\n<h2 id=\"新问题\"><a href=\"#新问题\" class=\"headerlink\" title=\"新问题\"></a>新问题</h2><p>找到的这种方式只能将图片进行放大，如果点九图比需要预览的图大，那就不适用了，还有个新问题是，点九图的宽或高跟预览图相比，有个的值大，有一个的值小，如：W点九 &gt; W预览，H点九 &lt; H预览。这种情景也不适用，所以考虑处理点九图。<br>这里只说最终的解决办法，当点九图的宽或高其中一个大于预览图的对应值时，将对应边缩小到预览图的值，再将另一边等比缩小，产生新的点九图片，这样新的点九图肯定比预览图小，可以正常拉伸了。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">if (this.div.offsetWidth &lt; this.bgImage.width &amp;&amp; this.div.offsetHeight &gt; this.bgImage.height) &#123;</span><br><span class=\"line\">    tmpCanvas.width = this.div.offsetWidth;</span><br><span class=\"line\">    tmpCanvas.height = Math.floor(this.bgImage.height * this.div.offsetWidth / this.bgImage.width);</span><br><span class=\"line\">    tmpCtx.drawImage(this.bgImage, 0, 0, this.div.offsetWidth, Math.floor(this.bgImage.height * this.div.offsetWidth / this.bgImage.width));</span><br><span class=\"line\">    let tmpImage = new Image();</span><br><span class=\"line\">    tmpImage.src = tmpCanvas.toDataURL(&quot;image/png&quot;);</span><br><span class=\"line\">    this.bakImage = this.bgImage;</span><br><span class=\"line\">    this.bgImage = tmpImage;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"遗留的问题\"><a href=\"#遗留的问题\" class=\"headerlink\" title=\"遗留的问题\"></a>遗留的问题</h2><p>按照上面的缩放方式，不论是宽还是高缩小，都会影响原点九图左边或者上面的<code>1px</code>的边界，导致在 <code>getPieces</code>方法中误取可拉伸区间值，这种情况一般发生在边界线离点九图非透明色边界距离较近时发生，暂时没有想到解决方案。<br>想到其实这也是种模拟实现的方式，在实际的产品中不可能多用。不过这个过程收获也是挺大。<br>有好的解决方案欢迎轻敲~~</p>\n","categories":["积累"],"tags":["javascript","canvas","9-patch"]},{"title":"记一次多图上传+本地预览中遇到的问题","url":"http://dearxiaojie.top/article/2017-11-30-mutiple-image-upload.html","content":"<p>在web开发中常会遇到图片预览的场景，比如在图片上传的情况下，一个办法是将图片上传到服务器之后，服务端将存储的URL返回来，然后异步通过URL加载刚上传的图片，达到图片的预览。但是在这个过程中会有两次web请求，一次是发送文件，一次是下载文件。我们可以在图片上传前就进行图片的预览，这样可以避免不必要的网络请求和等待。</p>\n<h2 id=\"图片添加\"><a href=\"#图片添加\" class=\"headerlink\" title=\"图片添加\"></a>图片添加</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;input type=&quot;file&quot; id=&quot;uploadcontainer&quot; name=&quot;images&quot; multiple=&quot;multiple&quot; accept=&quot;image/*&quot;&gt;</span><br></pre></td></tr></table></figure>\n<p>如上，<code>input</code>将<code>type</code>设置为<code>file</code>即可以上传文件，<code>accept</code>可以设置接收文件类型，这里是上传图片，所以设置成了<code>image/*</code>,<code>multiple</code>属性可以支持多文件上传。</p>\n<h2 id=\"图片预览\"><a href=\"#图片预览\" class=\"headerlink\" title=\"图片预览\"></a>图片预览</h2><blockquote>\n<p>以下代码默认加载了jquery</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 监听图片添加</span><br><span class=\"line\">$(&apos;#uploadcontainer&apos;).on(&apos;change&apos;, function() &#123;</span><br><span class=\"line\">    let files = $(this).prop(&apos;files&apos;);</span><br><span class=\"line\">    that.preview(files);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">preview: function(files) &#123;</span><br><span class=\"line\">    let that = this;</span><br><span class=\"line\">    // 遍历预览</span><br><span class=\"line\">    $.each(files, function(index, item) &#123;</span><br><span class=\"line\">        let fileReader = new FileReader();</span><br><span class=\"line\">        let tpl = new Template($(&apos;#tpl&apos;).html());</span><br><span class=\"line\">        fileReader.readAsDataURL(item);</span><br><span class=\"line\">        fileReader.onload = function(e) &#123;</span><br><span class=\"line\">            that.FILES.push(item); // *** 图片onload过程中将图片存在一个全局的数组中,因为在预览过程中还会有分类等处理，会在真正上传的时候添加更多参数</span><br><span class=\"line\">            html = tpl.render(&#123;</span><br><span class=\"line\">                cover_url: e.currentTarget.result,</span><br><span class=\"line\">                title: item.name.split(&apos;.&apos;)[0],</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            // ... 将html放到页面</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"图片上传\"><a href=\"#图片上传\" class=\"headerlink\" title=\"图片上传\"></a>图片上传</h2><blockquote>\n<p>假定我们的接口只支持每次只能上传一张图片</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">upload: function(f, cb) &#123;</span><br><span class=\"line\">    // 递归</span><br><span class=\"line\">    (function uploads() &#123;</span><br><span class=\"line\">        let file = f.shift();</span><br><span class=\"line\">        if (file) &#123;</span><br><span class=\"line\">            // 避免重名导致上传混乱，每次都重新创建新的对象</span><br><span class=\"line\">            let formData = new FormData();</span><br><span class=\"line\">            formData.append(&apos;image&apos;, file.image);</span><br><span class=\"line\">            formData.append(&apos;title&apos;, file.title);</span><br><span class=\"line\">            formData.append(&apos;category&apos;, file.category);</span><br><span class=\"line\">            $.ajax(&#123;</span><br><span class=\"line\">                type: &apos;POST&apos;,</span><br><span class=\"line\">                url: &apos;****&apos;,</span><br><span class=\"line\">                data: formData,</span><br><span class=\"line\">                contentType: false,// *</span><br><span class=\"line\">                cache: false,</span><br><span class=\"line\">                processData: false // *</span><br><span class=\"line\">            &#125;).always(function(rst) &#123;</span><br><span class=\"line\">                if (rst.ret == 1) &#123;</span><br><span class=\"line\">                    console.log(file.title + &apos; 上传中...&apos;)</span><br><span class=\"line\">                &#125; else &#123;</span><br><span class=\"line\">                    console.log(ret.msg || file.title + &apos; 上传失败...&apos;)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                uploads();</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            console.log(&apos;上传完成...&apos;);</span><br><span class=\"line\">            cb();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)();</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<h2 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h2><ul>\n<li>使用<code>FormData</code>对象，设置<code>contentType</code>为<code>false</code>, <code>processData</code>为<code>false</code></li>\n<li><code>fileReader.onload</code>的时候缓存图片，不然不能对应图片及增加的参数，导致图片和参数对应混乱</li>\n<li>递归上传，每次创建<code>FormData</code>对象，避免重复上传和重名混乱</li>\n</ul>\n","categories":["前端积累"],"tags":["js"]},{"title":"highcharts线型图表处理","url":"http://dearxiaojie.top/article/2017-08-29-diy-highcharts.html","content":"<h2 id=\"问题分析\"><a href=\"#问题分析\" class=\"headerlink\" title=\"问题分析\"></a>问题分析</h2><p>某次需求中，需要使用<a href=\"https://www.highcharts.com/\" target=\"_blank\" rel=\"noopener\"><code>highcharts</code></a>展示数据以对比。可是这批数据量级相差较大，如果在同一张图表中展示，会导致线条相隔很远或者没有波动幅度；还需要在点击某根线条的时候改变图表Y轴为当前线条数量级的，并处理他们的样式以区分。</p>\n<p>那么，第一个问题，要在同一张表中展示不同量级的数据，且相互具有参考性，有个办法就是将数据统一处理成一个维度的，如<a href=\"https://baike.baidu.com/item/%E5%BD%92%E4%B8%80%E5%8C%96%E6%96%B9%E6%B3%95\" target=\"_blank\" rel=\"noopener\">数据归一化</a>，将数据映射到<code>0~1</code>之间的小数，那不同量级的数据之间就有一定的参考性了。<br>第二个问题的话本来想过改源码，但是感觉意义不大，使用场景不多，就找<code>highcharts</code>的<code>api</code>文档，各种拼接。差不多实现了需求.</p>\n<h2 id=\"数据归一化\"><a href=\"#数据归一化\" class=\"headerlink\" title=\"数据归一化\"></a>数据归一化</h2><p>采用<code>min-max标准化</code>，也叫离差标准化，对原始数据的线性变化，结果落到<code>[0, 1]</code>之间。将需要处理的数据组，即<code>series</code>数据先处理，找到每组的最大最小，并计算.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function normalizing(arr) &#123;</span><br><span class=\"line\">    var data = [];</span><br><span class=\"line\">    for (var i = 0, len = arr.length; i &lt; len; i++) &#123;</span><br><span class=\"line\">        var cur = arr[i].data;</span><br><span class=\"line\">        arr[i].visible = false;</span><br><span class=\"line\">        var name = arr[i].name;</span><br><span class=\"line\">        arr[i].showInLegend = false;</span><br><span class=\"line\">        var max = Math.max.apply(null, cur);</span><br><span class=\"line\">        var min = Math.min.apply(null, cur);</span><br><span class=\"line\">        var news = cur.map(function (x) &#123;</span><br><span class=\"line\">            return (x - min) / max;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        var item = &#123; name: name, data: news &#125;;</span><br><span class=\"line\">        arr.push(item)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return arr;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>上面代码中，将原数据的每个线条设置为不显示，再将归一化后的数据<code>push</code>到数组后面。即最终图表上显示的是处理后的数据绘制的线条，这样的操作会引发后面的问题，接下来会提到。</p>\n<h2 id=\"展示真实数据\"><a href=\"#展示真实数据\" class=\"headerlink\" title=\"展示真实数据\"></a>展示真实数据</h2><p>在上面一步中，将所有数据都处理成了[0, 1]之间的数据，那鼠标<code>hover</code>上去显示的就是计算后的数据。这显然不是我们想要的，所以才没有去除原来的数据。查看<code>highcharts</code>的<code>api</code>，发现可以改变<code>hover</code>显示的格式，那我只需要找到计算后与之相对应的原数据就能正确显示了。<br>现在<code>hover</code>能够正确显示数据了，图表里的线条也有了一定的对比性，但是Y轴坐标依然是按照归一化后数据量级来的。在考虑到需要在点击线条的时候显示成其原数据量级的Y轴，所以采用以下办法。<br>取出选中线条数据中的最大最小，按照归一化算法逆回去，那么其实现在图表中的线条已经不是<code>[0, 1]</code>之间的数据了，而是分别乘上点击线条最大值，并加上最小值后的数据。那么，<code>Y</code>轴的自然就变成了当前的数据量级。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function adjustSeries(activeName) &#123;</span><br><span class=\"line\">    var data = chart.series;</span><br><span class=\"line\">    var max, min;</span><br><span class=\"line\">    for (var i = 0, len = 6; i &lt; len; i++) &#123;</span><br><span class=\"line\">        var curName = data[i + 6].name</span><br><span class=\"line\">        var current = data[i];</span><br><span class=\"line\">        if (curName === activeName) &#123;</span><br><span class=\"line\">            max = Math.max.apply(null, current.yData);</span><br><span class=\"line\">            min = Math.min.apply(null, current.yData);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    for (var i = 6, len = originData.length; i &lt; len; i++) &#123;</span><br><span class=\"line\">        var cur = originData[i].data || [];</span><br><span class=\"line\">        var newc = cur.map(function (item, index) &#123;</span><br><span class=\"line\">            var cnt = Math.round(item * max) + min;</span><br><span class=\"line\">            return cnt;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        var upObj = &#123; data: newc, lineWidth: 1, dashStyle: &apos;Dash&apos;, dataLabels: &#123; enabled: false &#125;, className: &apos;half-opacity&apos; &#125;;</span><br><span class=\"line\">        if (originData[i].name === activeName) &#123;</span><br><span class=\"line\">            upObj = &#123; data: newc, lineWidth: 4, dashStyle: &apos;Solid&apos;, dataLabels: &#123; enabled: true &#125;, className: &apos;no-opacity&apos; &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        chart.series[i].update(upObj);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>上面代码中的<code>originData</code>其实就是归一化后存起来的一个副本，因为后面每次点击都会使用这个数据，所以在存数据的时候一定要保证<code>originData</code>不变，存放的是真实数据，而不是数据引用，<code>javascript</code>基础知识，不清楚的可查看<a href=\"https://www.zhihu.com/question/23031215\" target=\"_blank\" rel=\"noopener\">javascript中的深拷贝和浅拷贝</a>。</p>\n<h2 id=\"使用到的API\"><a href=\"#使用到的API\" class=\"headerlink\" title=\"使用到的API\"></a>使用到的API</h2><ul>\n<li>plotOptions.series.event.click 点击线条的时候处理相关逻辑</li>\n<li>tooltip.formatter 更改鼠标<code>hover</code>的时候显示的数据和样式</li>\n<li>chart.series[i].update 动态更新图表数据，定制线条样式</li>\n<li>其他…</li>\n</ul>\n<h2 id=\"reference\"><a href=\"#reference\" class=\"headerlink\" title=\"reference\"></a>reference</h2><ul>\n<li><a href=\"http://api.highcharts.com/highcharts\" target=\"_blank\" rel=\"noopener\">Highcharts API</a></li>\n</ul>\n<p><a href=\"http://dearxiaojie.top/note/demos/highcharts.html\"><em>成品链接</em></a></p>\n","categories":["前端积累"],"tags":["js"]},{"title":"在浏览器中懒加载ES2015模块","url":"http://dearxiaojie.top/article/2017-06-05-lazy-loading-es2015-modules-in-the-browser.html","content":"<p>ES2015模块在浏览器懒加载</p>\n<p>在过去的几年里，开发者们已经无情的将服务端网站移动到了客户端，前提是那样能使页面的性能得到提高。</p>\n<p>然而，这可能是不够的。你是否考虑过你的网站也许加载更多于它实际用到的东西？遇到懒加载，一个延迟初始化（加载/分配）某个资源(代码/数据/静态资源)直到它需要的时候再加载。</p>\n<p>与此同时，<code>ES2015</code>已经能在生产环境中使用了，通过一些<code>transpilers</code>如<code>Babel</code>。现在你不用参与到使用<code>AMD</code>还是<code>CommonJS</code>的战争中，参照这篇文章的描述（<a href=\"https://www.airpair.com/javascript/posts/the-mind-boggling-universe-of-javascript-modules\" target=\"_blank\" rel=\"noopener\">The mind-boggling universe of JavaScript Module strategies</a>）,因为你可以写<code>ES2015</code>模块和让他们transpiled并交付给浏览器同时支持现有<code>CommonJS</code>或<code>AMD</code>模块。</p>\n<p>在这篇文章中，我将讨论如何使用<a href=\"https://github.com/systemjs/systemjs\" target=\"_blank\" rel=\"noopener\">System.js</a>同步(在页面加载的时候)和异步(懒加载)加载<code>ES2015</code>模块。</p>\n<h2 id=\"页面加载-vs-懒加载\"><a href=\"#页面加载-vs-懒加载\" class=\"headerlink\" title=\"页面加载 vs 懒加载\"></a>页面加载 vs 懒加载</h2><p>在浏览器上开发<code>JavaScript</code>代码执行时,你必须决定什么时候你让它执行。<br>有一些代码必须在页面加载的同时就执行，比如SPA应用使用了一些框架如<code>Angular</code>，<code>Ember</code>，<code>Backbone</code>，或者<code>React</code>，这些代码可能通过一个或多个<code>&lt;script&gt;</code>标签，必须在一个页面请求返回到浏览器后被引用到<code>HTML</code>文档的主体结构中。</p>\n<p>在另一方面，你可能有更多的代码块在一些特定的触发条件发生的时候在执行。经典的例子如：</p>\n<ul>\n<li>内容折叠。比如一个评论面板，在用户滚动到页底的时候才显示</li>\n<li>事件触发内容显示。比如一个放大的覆盖层，在用户点击图片的时候在显示</li>\n<li>少数内容。比如一个‘免运费’的控件，只只用于一些小的页面上</li>\n<li>有时间间隔的内容显示。比如一个客服聊天框</li>\n</ul>\n<p>这样的话，对于给出一个类似上面的功能，如果他的触发条件未发生，他的代码块就永远不会被执行。因此，那个代码块在页面加载的时候明显是不需要的，是可以延迟加载的。</p>\n<p>为了延迟加载，你只需要将在页面加载期间执行的代码从代码块中提取出来。这样在他的触发条件第一次发生的时候就被执行。</p>\n<p>这种异步加载引用代码的方式，或者叫懒加载，在提升页面性能上扮演了一个重要的角色，从减少页面首屏时间和速度指数上来看的话。</p>\n<p>为了学习更多关于对比页面加载和懒加载对页面性和速度指数的影响的知识，可以阅读这篇文章<a href=\"https://www.airpair.com/javascript/posts/the-tipping-point-of-clientside-performance\" target=\"_blank\" rel=\"noopener\"> Leveling up: Simple steps to optimize the Critical Rendering Path</a></p>\n<h2 id=\"AMD陷阱\"><a href=\"#AMD陷阱\" class=\"headerlink\" title=\"AMD陷阱\"></a>AMD陷阱</h2><p>AMD标准是为在浏览器上异步加载加载创造的，是第一个作为全局<code>JavaScript</code>文件散落在页面的成功替代品。根据<a href=\"http://requirejs.org/docs/whyamd.html#amd\" target=\"_blank\" rel=\"noopener\">Require.js文档</a>:</p>\n<blockquote>\n<p>The AMD format comes from wanting a module format that was better than today’s “write a bunch of script tags with implicit dependencies that you have to manually order” and something that was easy to use directly in the browser.</p>\n</blockquote>\n<p>它是基于模块设计模式<a href=\"http://addyosmani.com/resources/essentialjsdesignpatterns/book/#modulepatternjavascript\" target=\"_blank\" rel=\"noopener\">Module Design Pattern</a>的授权，有一个模块加载器，依赖注入和异步能力。它的一个主要的作用就是执行模块的懒加载。</p>\n<p>尽管是一个可怕的想法，它带来了一些固有的复杂性：也就是说，之前理解运行时模块的timelines是不那么重要的。这就意味着开发者们需要知道每个异步模块是什么时候做它预期的工作的。</p>\n<p>如果不明白这点，开发者们发现这样的情况：它有时候能正常工作，有时候不能。由于竞态，调试是非常困难的。因为这样的事情，<code>AMD</code>失去了大量的势头和牵引。</p>\n<p>学习更多关于<code>AMD</code>的陷阱，查看<a href=\"http://benmccormick.org/2015/05/28/moving-past-requirejs/\" target=\"_blank\" rel=\"noopener\">Moving Past RequireJS</a></p>\n<h2 id=\"ES2015模块101\"><a href=\"#ES2015模块101\" class=\"headerlink\" title=\"ES2015模块101\"></a>ES2015模块101</h2><p>在继续下去之前，我们回顾一下<code>ES2015</code>模块。如果你已经非常熟悉了，那这是一个快速的复习。<br>在<code>ES2015</code>中，模块已经成为官方<code>JavaScript</code>语言的一部分，它们非常强大而且很容易去掌握，站在<code>CommonJS</code>模块这个巨人的肩膀上的话。</p>\n<h3 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h3><p>通常，一个<code>ES2015</code>模块所有的全局变量仅作用于自己这个文件，模块可以导出数据，也可以导入其他的模块。</p>\n<h3 id=\"导出和导入\"><a href=\"#导出和导入\" class=\"headerlink\" title=\"导出和导入\"></a>导出和导入</h3><p>在一个你想导出的项目(如一个变量，函数、类)的前面加上一个关键词<code>export</code>就可以导出，在下面这个例子中，我们导出<code>Dog</code>和<code>Wolf</code>:<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// zoo.js</span><br><span class=\"line\">var getBarkStyle = function(isHowler) &#123;  </span><br><span class=\"line\">  return isHowler? &apos;woooooow!&apos;: &apos;woof, woof!&apos;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">export class Dog &#123;  </span><br><span class=\"line\">  constructor(name, breed) &#123;</span><br><span class=\"line\">    this.name = name;</span><br><span class=\"line\">    this.breed = breed;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  bark() &#123;</span><br><span class=\"line\">    return `$&#123;this.name&#125;: $&#123;getBarkStyle(this.breed === &apos;husky&apos;)&#125;`;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">export class Wolf &#123;  </span><br><span class=\"line\">  constructor(name) &#123;</span><br><span class=\"line\">    this.name = name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  bark() &#123;</span><br><span class=\"line\">    return `$&#123;this.name&#125;: $&#123;getBarkStyle(true)&#125;`;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>让我们想想如果在一个单元测试（如<code>Mocha/Chai</code>）用引入这个模块。使用语法<code>import &lt;object&gt; from &lt;path&gt;</code>，至于<code>&lt;object&gt;</code>我们可以选择我们想导入的元素–命名导入（<a href=\"http://www.2ality.com/2014/09/es6-modules-final.html\" target=\"_blank\" rel=\"noopener\">named imports</a>）。接下来我们可以从<code>chai</code>中导入<code>expect</code>，同样，从<code>Zoo</code>中导入<code>Dog</code>和<code>Wolf</code>。这种命名导入的语法很像ES2015的另一个方便的特性–<a href=\"http://www.2ality.com/2015/01/es6-destructuring.html\" target=\"_blank\" rel=\"noopener\">解构赋值</a><br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// zoo_spec.js</span><br><span class=\"line\">import &#123; expect &#125; from &apos;chai&apos;;  </span><br><span class=\"line\">import &#123; Dog, Wolf &#125; from &apos;../src/zoo&apos;;</span><br><span class=\"line\">describe(&apos;the zoo module&apos;, () =&gt; &#123;  </span><br><span class=\"line\">  it(&apos;should instantiate a regular dog&apos;, () =&gt; &#123;</span><br><span class=\"line\">    var dog = new Dog(&apos;Sherlock&apos;, &apos;beagle&apos;);</span><br><span class=\"line\">    expect(dog.bark()).to.equal(&apos;Sherlock: woof, woof!&apos;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  it(&apos;should instantiate a husky dog&apos;, () =&gt; &#123;</span><br><span class=\"line\">    var dog = new Dog(&apos;Whisky&apos;, &apos;husky&apos;);</span><br><span class=\"line\">    expect(dog.bark()).to.equal(&apos;Whisky: woooooow!&apos;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  it(&apos;should instantiate a wolf&apos;, () =&gt; &#123;</span><br><span class=\"line\">    var wolf = new Wolf(&apos;Direwolf&apos;);</span><br><span class=\"line\">    expect(wolf.bark()).to.equal(&apos;Direwolf: woooooow!&apos;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"默认\"><a href=\"#默认\" class=\"headerlink\" title=\"默认\"></a>默认</h3><p>如果你只有一个项目要导出，你可以使用<code>export default</code>来将你需要导出的项目作为一个对象<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// cat.js</span><br><span class=\"line\">export default class Cat &#123;  </span><br><span class=\"line\">  constructor(name) &#123;</span><br><span class=\"line\">    this.name = name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  meow() &#123;</span><br><span class=\"line\">    return `$&#123;this.name&#125;: You gotta be kidding that I&apos;ll obey you, right?`;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>导入默认的模块更简单，至于结构赋值就不再用到了，你可以直接从模块中导入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// cat_spec.js</span><br><span class=\"line\">import &#123; expect &#125; from &apos;chai&apos;;  </span><br><span class=\"line\">import Cat from &apos;../src/cat&apos;;</span><br><span class=\"line\">describe(&apos;the cat module&apos;, () =&gt; &#123;  </span><br><span class=\"line\">  it(&apos;should instantiate a cat&apos;, () =&gt; &#123;</span><br><span class=\"line\">    var cat = new Cat(&apos;Bugsy&apos;);</span><br><span class=\"line\">    expect(cat.meow()).to.equal(&apos;Bugsy: You gotta be kidding that I\\&apos;ll obey you, right?&apos;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>学习更多关于<code>ES2015</code>模块的知识，查看文章<a href=\"http://exploringjs.com/es6/ch_modules.html\" target=\"_blank\" rel=\"noopener\">Exploring ES6 — Modules.</a></p>\n<h2 id=\"ES2015模块加载器和System-js\"><a href=\"#ES2015模块加载器和System-js\" class=\"headerlink\" title=\"ES2015模块加载器和System.js\"></a>ES2015模块加载器和System.js</h2><p>惊奇的发现，<code>ES2015</code>实际上没有一个模块加载规范。这儿是一个非常受欢迎的对动态模块加载的提议–<a href=\"https://github.com/ModuleLoader/es6-module-loader\" target=\"_blank\" rel=\"noopener\">es6-module-loader</a>–受<a href=\"https://github.com/systemjs/systemjs\" target=\"_blank\" rel=\"noopener\">System.js</a>的启发。这个提议已经被撤回了，但是有个<a href=\"https://whatwg.github.io/loader/\" target=\"_blank\" rel=\"noopener\">WhatWG</a>在讨论阶段的新的加载规范和<a href=\"https://github.com/tc39/proposal-dynamic-import\" target=\"_blank\" rel=\"noopener\">Domenic Denicola</a>提出的动态导入规范。</p>\n<p>然而，<code>System.js</code>目前是最常使用的支持<code>ES2015</code>的模块加载器实现之一，它支持<code>ES2015</code>，<code>AMD</code>，<code>CommonJS</code>和浏览器中的全局脚本，还有<code>NodeJS</code>。它提供了一个异步模块加载器（对比<code>Require.js</code>）和<code>ES2015</code>转换，通过<a href=\"https://babeljs.io/\" target=\"_blank\" rel=\"noopener\">Babel</a>,<a href=\"https://github.com/google/traceur-compiler\" target=\"_blank\" rel=\"noopener\">Traceur</a>或者<a href=\"http://www.typescriptlang.org/\" target=\"_blank\" rel=\"noopener\">Typescript</a>。</p>\n<p><code>System.js</code>使用<code>Promises-based API</code>实现了异步模块加载。自从<code>promises</code>可以被链式调用和组合，这是非常长强大和方便的方法。举个例子，如果你想平行的加载多个模块，你可以使用<code>Promises.all</code>，当所有<code>promises</code>都被解决后，<code>listener</code>就可以被解除了。</p>\n<p>最后，动态导入规范正在得到更多的牵引，而且已经被编入<code>webpack 2</code>。你可以看看它在webpack2指南上是如何工作的<a href=\"https://webpack.js.org/guides/migrating/#code-splitting-with-es2015\" target=\"_blank\" rel=\"noopener\">Code splitting with ES2015</a>，这也是受<code>system.js</code>的启发，所以过度起来也很简单。</p>\n<h2 id=\"同步和异步导入模块\"><a href=\"#同步和异步导入模块\" class=\"headerlink\" title=\"同步和异步导入模块\"></a>同步和异步导入模块</h2><p>为了以同步和异步两种方式说明模块的加载，这里有一个简单的项目，将会在页面加载的时候同步加载我们的<code>Cat</code>模块，在用户点击按钮的时候懒加载<code>Zoo</code>模块。代码的<code>github</code>地址<a href=\"https://github.com/tiagorg/lazy-load-es2015-systemjs\" target=\"_blank\" rel=\"noopener\">lazy-load-es2015-systemjs</a>。</p>\n<p>让我们看一看主要的代码块中在页面加载时加载的代码，我们的<code>main.js</code>。</p>\n<p>首先，注意通过<code>import</code>同步加载<code>Cat</code>时的表现，然后，创建了一个<code>Cat</code>的实例，调用它的方法<code>meow()</code>，然后添加结果到<code>DOM</code>中：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// main.js</span><br><span class=\"line\">// Importing Cat module synchronously</span><br><span class=\"line\">import Cat from &apos;cat&apos;;</span><br><span class=\"line\">// DOM content node</span><br><span class=\"line\">let contentNode = document.getElementById(&apos;content&apos;);</span><br><span class=\"line\">// Rendering cat</span><br><span class=\"line\">let myCat = new Cat(&apos;Bugsy&apos;);  </span><br><span class=\"line\">contentNode.innerHTML += myCat.meow();</span><br></pre></td></tr></table></figure></p>\n<p>最后，注意通过<code>System.import(&#39;zoo&#39;)</code>异步导入<code>Zoo</code>，最后，<code>Dog</code>和<code>Wolf</code>分别调用他们的方法<code>back()</code>，再次将结果添加到<code>DOM</code>中：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// Button to lazy load Zoo</span><br><span class=\"line\">contentNode.innerHTML += `&lt;p&gt;&lt;button id=&apos;loadZoo&apos;&gt;Lazy load &lt;b&gt;Zoo&lt;/b&gt;&lt;/button&gt;&lt;/p&gt;`;</span><br><span class=\"line\">// Listener to lazy load Zoo</span><br><span class=\"line\">document.getElementById(&apos;loadZoo&apos;).addEventListener(&apos;click&apos;, e =&gt; &#123;</span><br><span class=\"line\">  // Importing Zoo module asynchronously</span><br><span class=\"line\">  System.import(&apos;zoo&apos;).then(Zoo =&gt; &#123;</span><br><span class=\"line\">    // Rendering dog</span><br><span class=\"line\">    let myDog = new Zoo.Dog(&apos;Sherlock&apos;, &apos;beagle&apos;);</span><br><span class=\"line\">    contentNode.innerHTML += `$&#123;myDog.bark()&#125;`;</span><br><span class=\"line\">    // Rendering wolf</span><br><span class=\"line\">    let myWolf = new Zoo.Wolf(&apos;Direwolf&apos;);</span><br><span class=\"line\">    contentNode.innerHTML += `&lt;br/&gt;$&#123;myWolf.bark()&#125;`;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>掌握遵守页面加载最少必须加载和懒加载可延迟加载的模块可以明显的提升你的页面性能，<code>AMD</code>和<code>CommonJS</code>为<code>ES2015</code>模块铺路。你可以开始使用<code>System.js</code>加载<code>ES2015</code>模块，或者通过<code>webpack 2</code>使用动态导入规范。但是官方的解决方案至今还未发布。</p>\n<h2 id=\"reference\"><a href=\"#reference\" class=\"headerlink\" title=\"reference\"></a>reference</h2><p><a href=\"https://dzone.com/articles/lazy-loading-es2015-modules-in-the-browser\" target=\"_blank\" rel=\"noopener\">lazy-loading-es2015-modules-in-the-browser</a></p>\n","categories":["翻译"],"tags":["ES2015"]},{"title":"8个npm常用技巧和简写","url":"http://dearxiaojie.top/article/2017-06-03-several-npm-shorthand-or-trick.html","content":"<p>在篇文章里,将介绍一些非常有用的npm技巧。在这有许多我们不能完全覆盖,所以主要介绍和我们开发工作最相关和最有用的技巧。</p>\n<h2 id=\"最基本的一些简写\"><a href=\"#最基本的一些简写\" class=\"headerlink\" title=\"最基本的一些简写\"></a>最基本的一些简写</h2><p>为了大家在同一起跑线，特别是针对于我们的新手，下面先快速的复习一些基本的简写来保证没人忘记任何简单的东西。</p>\n<h4 id=\"安装package\"><a href=\"#安装package\" class=\"headerlink\" title=\"安装package\"></a>安装package</h4><p>常规：<code>npm install pkg</code> 简写：<code>npm i pkg</code></p>\n<h4 id=\"全局安装\"><a href=\"#全局安装\" class=\"headerlink\" title=\"全局安装\"></a>全局安装</h4><p>常规： <code>npm install --global pkg</code> 简写：<code>npm i -g pkg</code></p>\n<h4 id=\"作为项目依赖\"><a href=\"#作为项目依赖\" class=\"headerlink\" title=\"作为项目依赖\"></a>作为项目依赖</h4><p>常规：<code>npm install --save pkg</code> 简写： <code>npm i -S pkg</code></p>\n<h4 id=\"作为开发依赖\"><a href=\"#作为开发依赖\" class=\"headerlink\" title=\"作为开发依赖\"></a>作为开发依赖</h4><p>常规： <code>npm install --save-dev pkg</code> 简写： <code>npm i -D pkg</code></p>\n<p><em>更多的简写请查看npm的<a href=\"https://docs.npmjs.com/misc/config#shorthands-and-other-cli-niceties\" target=\"_blank\" rel=\"noopener\">简写表</a></em><br>接下来开始有趣的东西。</p>\n<h3 id=\"初始化一个package\"><a href=\"#初始化一个package\" class=\"headerlink\" title=\"初始化一个package\"></a>初始化一个package</h3><p>我们都知道使用<code>npm init</code>，这是我们创建一个<code>package</code>需要做的第一步。但是，在默认情况下，我们会不停的敲<code>enter</code>键，所以我们怎么避免呢。<br><code>npm init -y</code> 或 <code>npm init -f</code>就可以一次搞定。</p>\n<h3 id=\"测试命令\"><a href=\"#测试命令\" class=\"headerlink\" title=\"测试命令\"></a>测试命令</h3><p>另一个我们都会的命令是<code>npm test</code>，基本上每天都会使用很多次。倘若我告诉你减少约<code>40%</code>的字符后可以做同样的事呢？非常幸运，这里有个命令<code>npm t</code>，确实能够做到。</p>\n<h3 id=\"列举可用的脚本\"><a href=\"#列举可用的脚本\" class=\"headerlink\" title=\"列举可用的脚本\"></a>列举可用的脚本</h3><p>我们得到了一个新项目,不知道如何开始。通常想知道：如何运行它?哪些脚本可用?<br>有一种方式是打开<code>package.json</code>文件，查看<code>scripts</code>部分。但是我们可以做的更好，所以我们可以简单的运行<code>npm run</code>，之后就可以获得可用脚本的列表。<br>另一个方式是安装<code>ntl</code>(<code>npm i -g ntl</code>)，然后在项目根目录运行<code>ntl</code>，就会列举出可用脚本，并可以直接选择运行，非常方便。</p>\n<h3 id=\"列举已安装的packages\"><a href=\"#列举已安装的packages\" class=\"headerlink\" title=\"列举已安装的packages\"></a>列举已安装的packages</h3><p>类似于可用的脚本,有时候我们需要知道在我们的项目的依赖关系。再次的，我们可以打开<code>package.json</code>文件查看。但是我们已经知道我们可以做的更好，那就是<br><code>npm ls --depth 0</code><br>如果需要列出全局安装的<code>packages</code>，我们运行同样的命令加上<code>-g</code>标志。<br><code>npm ls -g --depth 0</code></p>\n<h3 id=\"运行安装的可执行文件\"><a href=\"#运行安装的可执行文件\" class=\"headerlink\" title=\"运行安装的可执行文件\"></a>运行安装的可执行文件</h3><p>我们安装了一个包在我们的项目中,它带有一个可执行的文件,但只有通过<code>npm</code>脚本运行它。你想知道为什么,或者如何克服它吗?<br>首先，我们理解为什么–当我们在我们终端执行命令的时候，其根本其实是在我们<code>PATH</code>环境变量中列举的路径中寻找同名的可执行文件。这就是他们可从任何地方访问的神奇之处。本地安装包在本地注册他们的可执行文件,所以他们没有列在我们的<code>PATH</code>中，也就不会被发现。<br>当我们通过一个npm脚本运行可执行文件，它是如何工作的？好问题！因为这种方式运行时,是<code>npm</code>的一个小技巧,增加了一个额外的文件夹路径<code>&lt;project-directory&gt;/node_modules/.bin</code>到<code>PATH</code>，<br><code>npm</code>添加了一些更有趣的东西，你可以通过运行<code>npm run env | grep &quot;$PATH&quot;</code>看见它。你也可以只是运行<code>npm run env</code>来查看所有可用的环境变量。<br>如果你想知道，<code>node_modules/.bin</code>巧好是本地安装包存放他们可执行文件的地方。<br>例如，如果在你的项目中安装了<code>mocha</code>，直接在项目中运行<code>./node_modules/.bin/mocha</code>看有什么动作<br>so easy,对吧？无论何时你想运行一个本地安装包的可执行文件，只需要运行<code>./node_modules/.bin/&lt;command&gt;</code></p>\n<h3 id=\"在网上找你的package\"><a href=\"#在网上找你的package\" class=\"headerlink\" title=\"在网上找你的package\"></a>在网上找你的package</h3><p>在<code>package.json</code>文件中，你可能会看到<code>repository</code>的入口(‘entry’)，想知道它有什么好处呢？<br>要回答这个问题，只需要运行<code>npm repo</code>就可以在你的浏览器中看到。<br>顺便说一下,<code>npm home</code>命令和<code>npm homepage</code>同样适用,<br>如果你想在<a href=\"https://www.npmjs.com/\" target=\"_blank\" rel=\"noopener\">npmjs</a>打开你的<code>package</code>，这里也有个不错的简写<code>npm docs</code></p>\n<h3 id=\"在其他脚本前后运行脚本\"><a href=\"#在其他脚本前后运行脚本\" class=\"headerlink\" title=\"在其他脚本前后运行脚本\"></a>在其他脚本前后运行脚本</h3><p>也许你熟悉某些脚本例如<code>pretest</code>,这个允许你定义在<code>test</code>脚本运行前运行的代码。<br>你可能会惊讶地发现,你可以为每一个脚本增加预先和滞后执行的脚本,包括您自己的自定义脚本!<br>对于使用<code>npm</code>作为构建工具和有很多脚本需要编排的项目来说，是非常有用的。</p>\n<h3 id=\"更换package的版本\"><a href=\"#更换package的版本\" class=\"headerlink\" title=\"更换package的版本\"></a>更换package的版本</h3><p>你有一个<code>package</code>，也许使用<a href=\"http://semver.org/\" target=\"_blank\" rel=\"noopener\">semver</a>做版本控制，在一个新版本发布前需要更换版本。<br>一种方式是打开<code>package.json</code>文件手动的改变版本，但在这里我们不这样。<br>一个简单的方式是运行<code>npm version</code>加上<code>major</code>、<code>minor</code>或者<code>patch</code>。<br>That’s all</p>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>另外值得一提的是一些组合命令，如<code>npm it</code>将会运行安装和测试命令，等同于<code>npm install &amp;&amp; npm test</code>,非常方便。<br>如果你知道更多的有用的技巧,请在评论中分享一下吧!</p>\n<h2 id=\"reference\"><a href=\"#reference\" class=\"headerlink\" title=\"reference\"></a>reference</h2><p><a href=\"https://medium.freecodecamp.com/8-npm-tricks-you-can-use-to-impress-your-colleagues-dbdae1ef5f9e\" target=\"_blank\" rel=\"noopener\">8-npm-tricks-you-can-use-to-impress-your-colleagues</a><br><a href=\"https://docs.npmjs.com/misc/config#shorthands-and-other-cli-niceties\" target=\"_blank\" rel=\"noopener\">shorthands-and-other-cli-niceties</a></p>\n","categories":["积累"],"tags":["npm"]},{"title":"使用Python发送HTML邮件","url":"http://dearxiaojie.top/article/2017-05-26-use-python-smtp-to-send-mail.html","content":"<p><em>这段时间在慢慢学习<code>Python</code>，正巧有个与<code>Python</code>相关的活，借此机会好练练手</em></p>\n<p>为什么要学习<code>Python</code>呢，作为一个前端，为什么不学习<code>nodejs</code>，而选择学习<code>Python</code>，对呀，其实我也这么问自己，但是，有什么影响嘛，爱学啥学啥，我不觉得啥该学不该学。学了如果不用，也慢慢会忘。扯远了，其实我是比较喜欢<code>Python</code>的语法和它的严格缩进，学了一段时间后，发现还是有和<code>es6/es7</code>相似的方法。</p>\n<h2 id=\"SMTP\"><a href=\"#SMTP\" class=\"headerlink\" title=\"SMTP\"></a>SMTP</h2><p><code>SMTP</code>是发送邮件的协议，<code>Python</code>内置对<code>SMTP</code>的支持，可以发送纯文本、HTML邮件。其中有两个用到的模块，<code>email</code>负责邮件构造，<code>smtplib</code>发送邮件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&apos;&apos;&apos;using python send gmail&apos;&apos;&apos;</span><br><span class=\"line\"># !/usr/bin/env python3</span><br><span class=\"line\"># -*- coding: utf-8 -*-</span><br><span class=\"line\"></span><br><span class=\"line\">import smtplib</span><br><span class=\"line\">from email.header import Header</span><br><span class=\"line\">from email.mime.text import MIMEText</span><br><span class=\"line\">from email.mime.multipart import MIMEMultipart</span><br><span class=\"line\">from email.utils import parseaddr, formataddr</span><br><span class=\"line\">class SendGmail(object):</span><br><span class=\"line\">    &apos;&apos;&apos;send mail via gmail&apos;&apos;&apos;</span><br><span class=\"line\">    def __init__(self):</span><br><span class=\"line\">        self._from_addr = input(&apos;From:&apos;)</span><br><span class=\"line\">        self._password = input(&apos;Password:&apos;)</span><br><span class=\"line\">        self._to_addr = input(&apos;To:&apos;)</span><br><span class=\"line\">        self._smtp_server = smtplib.SMTP(&apos;smtp.gmail.com&apos;, 587)</span><br><span class=\"line\">        self._msg = MIMEMultipart(&apos;alternative&apos;)</span><br><span class=\"line\">        self._msg[&apos;From&apos;] = self._format_addrs(&apos;&lt;%s&gt;&apos; % self._from_addr) # 发件人</span><br><span class=\"line\">        self._msg[&apos;To&apos;] = self._format_addrs(&apos;&lt;%s&gt;&apos; % self._to_addr) # 收件人</span><br><span class=\"line\">        subject = &apos;hello python&apos;</span><br><span class=\"line\">        self._msg[&apos;Subject&apos;] = Header(subject, &apos;utf-8&apos;).encode() # 主题</span><br><span class=\"line\"></span><br><span class=\"line\">    def get_content(self, mail_tmp_path=&apos;mail.html&apos;):</span><br><span class=\"line\">        &apos;&apos;&apos;get mail content&apos;&apos;&apos;</span><br><span class=\"line\">        page = mail_tmp_path</span><br><span class=\"line\">        file = open(page, &apos;r&apos;, encoding=&apos;utf8&apos;)</span><br><span class=\"line\">        content = file.read()</span><br><span class=\"line\">        content = content.replace(&apos;&lt;#send_name#&gt;&apos;, self._from_addr)</span><br><span class=\"line\">        content = content.replace(&apos;&lt;#name#&gt;&apos;, self._to_addr)</span><br><span class=\"line\">        self._msg.attach(MIMEText(content, &apos;html&apos;, &apos;utf-8&apos;))</span><br><span class=\"line\"></span><br><span class=\"line\">    def send_mail(self):</span><br><span class=\"line\">        &apos;&apos;&apos;send mail&apos;&apos;&apos;</span><br><span class=\"line\">        server = self._smtp_server</span><br><span class=\"line\">        server.ehlo()</span><br><span class=\"line\">        server.starttls()</span><br><span class=\"line\">        server.login(self._from_addr, self._password)</span><br><span class=\"line\">        server.sendmail(self._from_addr, [self._to_addr], self._msg.as_string())</span><br><span class=\"line\">        print(&apos;success send to %s!&apos; % self._to_addr)</span><br><span class=\"line\">        server.quit()</span><br><span class=\"line\">    @classmethod</span><br><span class=\"line\">    def _replace_tmp(cls, string):</span><br><span class=\"line\">        pass</span><br><span class=\"line\">    @classmethod</span><br><span class=\"line\">    def _format_addrs(cls, string):</span><br><span class=\"line\">        &apos;&apos;&apos;format addr&apos;&apos;&apos;</span><br><span class=\"line\">        name, addr = parseaddr(string)</span><br><span class=\"line\">        return formataddr((Header(name, &apos;utf-8&apos;).encode(), addr))</span><br><span class=\"line\"></span><br><span class=\"line\">if __name__ == &apos;__main__&apos;:</span><br><span class=\"line\">    MESSAGE = SendGmail()</span><br><span class=\"line\">    MESSAGE.get_content()</span><br><span class=\"line\">    MESSAGE.send_mail()</span><br></pre></td></tr></table></figure>","categories":["积累"],"tags":["Python","SMTP","mail"]},{"title":"使用Travis CI自动部署Hexo博客到Github上","url":"http://dearxiaojie.top/article/2017-05-04-use-travisci-build-your-hexo-site.html","content":"<h2 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h2><p>自从在<code>github page</code>上搭建博客以来，都是使用的<a href=\"http://hexo.io/\" target=\"_blank\" rel=\"noopener\">hexo</a>，每次都是通过<code>hexo</code>命令<code>build</code>生成静态文件，再<code>push</code>到<code>github</code>上，后来找到一个<a href=\"https://github.com/hexojs/hexo-deployer-git\" target=\"_blank\" rel=\"noopener\">deploy</a>插件，只需要填写好<code>github</code>的<code>repos</code>地址就好。但是源码的保存是个问题，更换电脑想要写博客很不方便，甚至蠢到将源码保存到u盘里面，这样每次提交后又要备份一次，很容易忘记。说到这里那为什么不将源码保存到<code>github</code>上呢。</p>\n<p>其实也是因为懒，给博客换了几次主题后，使得博客源码很乱，甚至自己也忘了改了主题的哪些代码，加上主题也是个<code>repos</code>，直接提交博客源码是提不上的，涉及到子模块问题，麻烦。想到自己还喜欢改动别人的主题，索性将主题文件夹<code>.git</code>文件删掉，让他成为一个普通的文件夹，这样就能提交到<code>github</code>了。废话不多说，估计是很久没写博客了，没有重点，下面简单说说使用<code>Travis CI</code>自动部署<code>Hexo</code>博客到<code>github</code>上。</p>\n<h2 id=\"什么是Travis-CI？\"><a href=\"#什么是Travis-CI？\" class=\"headerlink\" title=\"什么是Travis CI？\"></a>什么是Travis CI？</h2><blockquote>\n<p><code>Travis CI</code> 是目前新兴的开源持续集成构建项目，它与<code>jenkins</code>，<code>GO</code>的很明显的特别在于采用<code>yaml</code>格式，简洁清新独树一帜。目前大多数的github项目都已经移入到<code>Travis CI</code>的构建队列中，据说<code>Travis CI</code>每天运行超过<code>4000</code>次完整构建。</p>\n</blockquote>\n<h2 id=\"构建\"><a href=\"#构建\" class=\"headerlink\" title=\"构建\"></a>构建</h2><p>首先进入<a href=\"https://travis-ci.org/\" target=\"_blank\" rel=\"noopener\">Travis CI</a>官网，使用<code>github</code>账号登录，如下图<br><img src=\"http://7xjp74.com1.z0.glb.clouddn.com/travis.png\" alt=\"travis\"><br>登录成功后进入如下界面，以为我再此之前已经构建过，所以会用红色框内的内容，如果没有使用过是没有的。<br><img src=\"http://7xjp74.com1.z0.glb.clouddn.com/list.png\" alt=\"list\"><br>然后点击<code>My Repositories</code>右边的<code>+</code>，添加需要自动构建的<code>repos</code>，进入如下页面。<br><img src=\"http://7xjp74.com1.z0.glb.clouddn.com/new.png\" alt=\"new\"><br>可以看到这个界面会显示当前<code>github</code>账号的所以项目，如果没有显示，点击右上角的<code>Sync account</code>按钮，就可以同步过来了，点击需要构建的<code>repos</code>前面的按钮为<code>ON</code>，再点击其后的原形设置图标，进入如下界面<br><img src=\"http://7xjp74.com1.z0.glb.clouddn.com/config.png\" alt=\"config\"><br>如图中设置，将<code>Build only if .travis.yml is present</code>及另外两个设置为<code>ON</code>，功能如字面意思不多说。<br>到目前为止，已经将需要构建的<code>repos</code>开启，那么，我们如何在将源码提交到<code>github</code>的时候，它就自动构建并将<code>build</code>后的静态文件<code>push</code>到我的静态文件<code>branch</code>或者<code>repos</code>呢（我是将<code>build</code>后的静态文件放到一个单独的<code>repos</code>了，也可以放在源码<code>repos</code>的另一个<code>branch</code>，例如起名叫<code>hexo</code>），接下来说如何让<code>Travis CI</code>访问<code>github</code>.</p>\n<h2 id=\"Access-Token\"><a href=\"#Access-Token\" class=\"headerlink\" title=\"Access Token\"></a>Access Token</h2><p>我们需要在<code>Travis</code>上配置<code>Access Token</code>，就可以在构建完毕后自动<code>push</code>到<code>github</code>上保存静态文件的<code>repos</code>了。</p>\n<h3 id=\"生成Access-Token\"><a href=\"#生成Access-Token\" class=\"headerlink\" title=\"生成Access Token\"></a>生成Access Token</h3><p>登录<a href=\"https://github.com/\" target=\"_blank\" rel=\"noopener\">github</a>，进入个人主页，点击<code>setting</code>，进入界面后找到下图所指位置。<br><img src=\"http://7xjp74.com1.z0.glb.clouddn.com/token.png\" alt=\"token\"><br>点击<code>Personal access tokens</code>，进入页面后，在点击右上角<code>Generate new token</code>,会再次让输入<code>github</code>密码，然后在<code>Token description</code>下起一个名字，再勾选一些权限，我是全给勾选上了，在点击下面<code>Generate token</code>这里就不多截图了。复制生成的<code>token</code>码。</p>\n<h3 id=\"配置Travis-CI\"><a href=\"#配置Travis-CI\" class=\"headerlink\" title=\"配置Travis CI\"></a>配置Travis CI</h3><p>回到<code>Travis</code>的<code>setting</code>页面，如上面图，在<code>Environment Variables</code>这一栏，点击<code>Add</code>，起一个名字到<code>Name</code>，将复制的<code>token</code>码粘贴到<code>Value</code>框中，到这步为止，已经完成了<code>Travis</code>的设置。到博客源码根目录，创建一个<code>.travis.yml</code>的配置文件，内容如下，附注释，注意缩进<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">language: node_js  #设置语言</span><br><span class=\"line\"></span><br><span class=\"line\">node_js: stable  #设置相应的版本</span><br><span class=\"line\"></span><br><span class=\"line\">install:</span><br><span class=\"line\">  - npm install  #安装hexo及插件</span><br><span class=\"line\"></span><br><span class=\"line\">script:</span><br><span class=\"line\">  - hexo clean  #清除</span><br><span class=\"line\">  - hexo g  #生成</span><br><span class=\"line\"></span><br><span class=\"line\">after_script:</span><br><span class=\"line\">  - cd ./public</span><br><span class=\"line\">  - git init</span><br><span class=\"line\">  - git config user.name &quot;swust-xiaoj&quot;  #修改name</span><br><span class=\"line\">  - git config user.email &quot;swustxiaojie@163.com&quot;  #修改email</span><br><span class=\"line\">  - git add .</span><br><span class=\"line\">  - git commit -m &quot;update site&quot;</span><br><span class=\"line\">  - git push --force  &quot;https://$&#123;travis&#125;@$&#123;GH_REF&#125;&quot; master:master  #travis是在Travis中配置token的名称</span><br><span class=\"line\"></span><br><span class=\"line\">branches:</span><br><span class=\"line\">  only:</span><br><span class=\"line\">    - master  #只监测master，可根据自己情况设置，若是存放同一个仓库，这儿可以选择存放源码的branch，如hexo</span><br><span class=\"line\">env:</span><br><span class=\"line\"> global:</span><br><span class=\"line\">   - GH_REF: github.com/swust-xiaoj/tb.git  #设置GH_REF，注意更改yourname</span><br></pre></td></tr></table></figure></p>\n<p>因为我是新起了一个<code>repos</code>来存放静态文件了，所以上面的<code>GH_REF</code>是对应那个<code>repos</code>地址，若是放同一个<code>repos</code>中，那这儿一般都是<code>yourname.github.io</code>那个仓库。到此，配置已经完成了。</p>\n<h3 id=\"创建文章\"><a href=\"#创建文章\" class=\"headerlink\" title=\"创建文章\"></a>创建文章</h3><p>我们可以创建一篇文章<code>hexo new post use-travis-build-your-hexo-site</code>，添加内容后，并<code>push</code>到<code>github</code>，正常情况下，进入<code>Travis</code>网站就可以看到已经在构建了，如图<br><img src=\"http://7xjp74.com1.z0.glb.clouddn.com/success.png\" alt=\"success\"><br>完成后，<a href=\"https://dearxiaojie.top/article/2017-05-04-use-travisci-build-your-hexo-site.html\">访问链接</a>就可以看到这篇文章了。</p>\n<h2 id=\"写在后面\"><a href=\"#写在后面\" class=\"headerlink\" title=\"写在后面\"></a>写在后面</h2><p>很久没有花时间写点东西了，不管有没有价值，总是一种对知识的积累和总结，输出也意味着输入，所以以后还是将学到的东西和积累总结下，自己可以将知识梳理的同时能帮助到别人是更好的了。</p>\n<h2 id=\"更新\"><a href=\"#更新\" class=\"headerlink\" title=\"更新\"></a>更新</h2><h3 id=\"master-commit-树被清空\"><a href=\"#master-commit-树被清空\" class=\"headerlink\" title=\"master commit 树被清空\"></a>master commit 树被清空</h3><p>仔细查看上面的配置文件，我们发现每次都是将 public 目录下的文件重新生成了一个git项目，然后强制覆盖提交到了 master 分支下，这就是问题的所在。<br>为了解决这个问题，我将配置文件改为了如下的内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">after_script:</span><br><span class=\"line\">  - git clone https://$&#123;GH_REF&#125; .deploy_git</span><br><span class=\"line\">  - cd .deploy_git</span><br><span class=\"line\">  - git checkout master</span><br><span class=\"line\">  - cd ../</span><br><span class=\"line\">  - mv .deploy_git/.git/ ./public/</span><br><span class=\"line\">  - cd ./public</span><br><span class=\"line\">  - git config user.name &quot;swust-xiaoj&quot;  #修改name</span><br><span class=\"line\">  - git config user.email &quot;swustxiaojie@163.com&quot;  #修改email</span><br><span class=\"line\">  - git add .</span><br><span class=\"line\">  - git commit -m &quot;Travis CI Auto Builder&quot;</span><br><span class=\"line\">  - git push --force --quiet &quot;https://$&#123;travis&#125;@$&#123;GH_REF&#125;&quot; master:master  #travis是在Travis中配置token的名称</span><br></pre></td></tr></table></figure>\n<p>在 after_script 部分，我先将博客项目 clone 到本地的 .deploy_git 目录下（目录名可自定义）,然后切换到 master 分支，将 master 分支下的 .git 目录拷贝到了 public 目录下，接着继续后面的 commit 操作。</p>\n<h3 id=\"添加-commit-时间戳\"><a href=\"#添加-commit-时间戳\" class=\"headerlink\" title=\"添加 commit 时间戳\"></a>添加 commit 时间戳</h3><p>按照前面的方法配置 <code>travis.yml</code> 的内容，在 <code>master</code> 分支下的提交记录是这样的：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Travis CI Auto Builder</span><br><span class=\"line\">Travis CI Auto Builder</span><br><span class=\"line\">Travis CI Auto Builder</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure></p>\n<p>看到每次的提交记录中没有提交的时间戳，所以考虑着要把 <code>commit</code> 的时间戳给加上。<br><code>script</code> 命令下是可以执行 <code>shell</code> 命令的，所以对 <code>travis.yml</code> 文件进行了修改。<br>在 <code>shell</code> 中获取当前的时间戳，可以这样:<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#/bin/bash</span><br><span class=\"line\">&gt; date +&quot;%Y-%m-%d %H:%M&quot;</span><br><span class=\"line\">2018-05-05 12:13</span><br></pre></td></tr></table></figure></p>\n<p><code>Travis CI</code> 中使用的<code>linux</code>系统在编译生成时使用的是<code>UTC</code>时间，这样我们在<code>github</code>中的提交列表中看到的提交时间就会晚8小时。我们需要在执行时将时区改为东八区。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">before_install:</span><br><span class=\"line\">  - export TZ=&apos;Asia/Shanghai&apos;</span><br></pre></td></tr></table></figure></p>\n<p>然后将<code>after_script</code>中的命令移到单独的<code>shell</code>文件中。最终的两个文件内容如下</p>\n<blockquote>\n<p>build.sh<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#!/bin/bash</span><br><span class=\"line\">set -ev</span><br><span class=\"line\"></span><br><span class=\"line\">git clone https://$&#123;GH_REF&#125; .deploy_git</span><br><span class=\"line\">cd .deploy_git</span><br><span class=\"line\">git checkout master</span><br><span class=\"line\"></span><br><span class=\"line\">cd ../</span><br><span class=\"line\">mv .deploy_git/.git/ ./public/</span><br><span class=\"line\"></span><br><span class=\"line\">cd ./public</span><br><span class=\"line\"></span><br><span class=\"line\">git config user.name &quot;swust-xiaoj&quot;  #修改name</span><br><span class=\"line\">git config user.email &quot;swustxiaojie@163.com&quot;  #修改email</span><br><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m &quot;Travis CI Auto Builder at `date +&quot;%Y-%m-%d %H:%M&quot;`&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">git push --force --quiet &quot;https://$&#123;travis&#125;@$&#123;GH_REF&#125;&quot; master:master  #travis是在Travis中配置token的名称</span><br></pre></td></tr></table></figure></p>\n<p>.travis.yml<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">language: node_js</span><br><span class=\"line\"></span><br><span class=\"line\">node_js: stable</span><br><span class=\"line\"></span><br><span class=\"line\">cache:</span><br><span class=\"line\">  apt: true</span><br><span class=\"line\">  directories:</span><br><span class=\"line\">    - node_modules</span><br><span class=\"line\">before_install:</span><br><span class=\"line\">  - export TZ=&apos;Asia/Shanghai&apos; # 更改时区</span><br><span class=\"line\">  - npm install hexo-cli -g</span><br><span class=\"line\">  - chmod +x ./build.sh  # 为shell文件添加可执行权限</span><br><span class=\"line\"></span><br><span class=\"line\">install:</span><br><span class=\"line\">  - npm install</span><br><span class=\"line\"></span><br><span class=\"line\">script:</span><br><span class=\"line\">  - hexo clean</span><br><span class=\"line\">  - hexo g</span><br><span class=\"line\"></span><br><span class=\"line\">after_script:</span><br><span class=\"line\">  - ./build.sh</span><br><span class=\"line\"></span><br><span class=\"line\">branches:</span><br><span class=\"line\">  only:</span><br><span class=\"line\">    - master</span><br><span class=\"line\">env:</span><br><span class=\"line\"> global:</span><br><span class=\"line\">   - GH_REF: github.com/swust-xiaoj/swust-xiaoj.github.io.git</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://docs.travis-ci.com/user/customizing-the-build/\" target=\"_blank\" rel=\"noopener\">Customizing the Build</a></li>\n<li><a href=\"http://www.itfanr.cc/2017/08/09/using-travis-ci-automatic-deploy-hexo-blogs/\" target=\"_blank\" rel=\"noopener\">IT 范儿 | 使用Travis CI自动部署Hexo博客</a></li>\n</ul>\n","categories":["积累"],"tags":["hexo"]},{"title":"Show 'Search' button in iPhone/iPad Safari keyboard","url":"http://dearxiaojie.top/article/2016-10-23-search-btn.html","content":"<h2 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h2><p>点击搜索框的时候，需要将软键盘的<code>return</code> <code>go</code> <code>前往</code> 按键文案变成 <code>搜索</code>或 <code>search</code>，并且点击的时候发起搜索。<br><a id=\"more\"></a><br>实现方式是将<code>input</code>框<code>type</code> 设置成 <code>search</code>，并在外层套一个<code>form</code>，在一般浏览器如QQ浏览器，uc浏览器等上能将软键盘显示成<code>搜索</code>,但是在safari浏览器上并不能正常将软键盘文案改变。</p>\n<h2 id=\"解决办法\"><a href=\"#解决办法\" class=\"headerlink\" title=\"解决办法\"></a>解决办法</h2><p>在<code>form</code>上设置<code>action</code>,并将其值设置成<code>.</code>,但是需要控制在搜索的时候应将表单默认行为拦截，<code>form</code>上添加<code>return false</code>即可。</p>\n<h2 id=\"源代码\"><a href=\"#源代码\" class=\"headerlink\" title=\"源代码\"></a>源代码</h2><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 搜索框 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">class</span>=<span class=\"string\">\"search-top\"</span> <span class=\"attr\">action</span>=<span class=\"string\">\".\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"search-wrap\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"search\"</span> <span class=\"attr\">name</span>=<span class=\"string\">'key'</span> <span class=\"attr\">id</span>=<span class=\"string\">'search-input'</span> <span class=\"attr\">placeholder</span>=<span class=\"string\">\"keyword...\"</span> <span class=\"attr\">autocapitalize</span>=<span class=\"string\">\"off\"</span> <span class=\"attr\">autocomplete</span>=<span class=\"string\">\"off\"</span> <span class=\"attr\">autocorrect</span>=<span class=\"string\">\"off\"</span> &gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">class</span>=<span class=\"string\">\"search\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">i</span> <span class=\"attr\">class</span>=<span class=\"string\">\"icon-search\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">i</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">i</span> <span class=\"attr\">class</span>=<span class=\"string\">\"icon-reset reset\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">i</span>&gt;</span></span><br><span class=\"line\">     <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"cancel-btn\"</span>&gt;</span>取消<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">'.search-top'</span>).on(<span class=\"string\">'submit'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> text = $(<span class=\"string\">'#search-input'</span>).val().trim();</span><br><span class=\"line\">    text &amp;&amp; that.emit.emit(<span class=\"string\">'search'</span>, text);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"reference\"><a href=\"#reference\" class=\"headerlink\" title=\"reference\"></a>reference</h2><blockquote>\n<p><a href=\"http://stackoverflow.com/questions/4864167/show-search-button-in-iphone-ipad-safari-keyboard\" target=\"_blank\" rel=\"noopener\">Show ‘Search’ button in iPhone/iPad Safari keyboard</a></p>\n</blockquote>\n","categories":["学习笔记"],"tags":["CSS"]},{"title":"Gulp Connect发送post请求返回405","url":"http://dearxiaojie.top/article/2016-04-10-Gulp Connect发送post请求返回405.html","content":"<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>在使用<code>gulp</code>过程中，遇到了在使用gulp-connect启动服务的时候，发送ajax请求不能发送post，返回错误:<br><a id=\"more\"></a><br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">405 Method Not Allowed</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h2><p>通过自定义一个中间件来完成<code>POST</code>、<code>PUT</code>、<code>DELETE</code> 请求。<br>首先，引入<code>fs</code>、<code>path</code>和<code>connect</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var fs = require(&apos;fs&apos;),</span><br><span class=\"line\">path = require(&apos;path&apos;),</span><br><span class=\"line\">connect = require(&apos;gulp-connect&apos;);</span><br></pre></td></tr></table></figure>\n<p>接着，在配置中增加自己的中间件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">gulp.task(&apos;server&apos;,function()&#123;</span><br><span class=\"line\">    connect.server(&#123;</span><br><span class=\"line\">        middleware: function(connect, options) &#123;</span><br><span class=\"line\">        return [</span><br><span class=\"line\">            function(req, res, next) &#123;</span><br><span class=\"line\">                var filepath = path.join(options.root, req.url);</span><br><span class=\"line\">                if (&apos;POSTPUTDELETE&apos;.indexOf(req.method.toUpperCase()) &gt; -1</span><br><span class=\"line\">                    &amp;&amp; fs.existsSync(filepath) &amp;&amp; fs.statSync(filepath).isFile()) &#123;</span><br><span class=\"line\">                    return res.end(fs.readFileSync(filepath));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                return next();</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">            ];</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        hostname: &apos;127.0.0.1&apos;,</span><br><span class=\"line\">        port: 8090,</span><br><span class=\"line\">        livereload: true</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"References\"><a href=\"#References\" class=\"headerlink\" title=\"References\"></a>References</h2><p><a href=\"http://cweili.gitcafe.io/gulp-connect-post-put-delete/\" target=\"_blank\" rel=\"noopener\">让 Gulp Connect 支持 POST、PUT、DELETE 请求</a></p>\n","categories":["积累"],"tags":["gulp"]},{"title":"删除node_modules不成功","url":"http://dearxiaojie.top/article/2015-11-23-删除node-modules不成功.html","content":"<h2 id=\"Question\"><a href=\"#Question\" class=\"headerlink\" title=\"Question\"></a>Question</h2><blockquote>\n<p>Windows做Node.js开发的你或许碰到过无法删除node_modules文件夹的情况,如下图：<br><a id=\"more\"></a><br><img src=\"http://7xjp74.com1.z0.glb.clouddn.com/failed.png\" alt=\"failed\"></p>\n</blockquote>\n<h2 id=\"Reason\"><a href=\"#Reason\" class=\"headerlink\" title=\"Reason\"></a>Reason</h2><p>windows 在文件目录的长度有限制，因为node packages 有众多dependencies，每一个dependency又有其他的dependency，这些dependency或许还有其他的dependency，所以导致node_modules有超级复杂的文件目录。比如：</p>\n<blockquote>\n<p>D:\\codetest\\node_modules\\edpx-mobile\\node_modules\\edp-webserver\\node_modules\\babel\\node_modules\\chokidar\\node_modules\\anymatch\\node_modules</p>\n</blockquote>\n<h2 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution\"></a>Solution</h2><h3 id=\"install\"><a href=\"#install\" class=\"headerlink\" title=\"install\"></a>install</h3><blockquote>\n<p>npm install -g rimraf</p>\n</blockquote>\n<h3 id=\"delete\"><a href=\"#delete\" class=\"headerlink\" title=\"delete\"></a>delete</h3><blockquote>\n<p>rimraf node_modules</p>\n</blockquote>\n<p><em>亲测有效</em></p>\n","categories":["积累"],"tags":["nodejs"]},{"title":"remove white space below image","url":"http://dearxiaojie.top/article/2015-10-20-remove-white-space-below-image.html","content":"<p>最近遇到过关于<code>&lt;img&gt;</code>标签显示一张图片在一个<code>&lt;div&gt;</code>里面，<code>&lt;div&gt;</code>的宽高由<code>image</code>撑起。可是在图片的底部和<code>&lt;div&gt;</code>底部之间，多出神秘的2~3px的空白。如下图：<br><a id=\"more\"></a><br><img src=\"http://7xjp74.com1.z0.glb.clouddn.com/1.JPG\" alt=\"have white space\"><br>我知道<code>&lt;img&gt;</code>是个特殊的元素，为什么会出现这种现象？</p>\n<h2 id=\"Reason\"><a href=\"#Reason\" class=\"headerlink\" title=\"Reason\"></a>Reason</h2><p><code>&lt;img&gt;</code> 元素在默认情况下是inline元素，inline元素默认和父级元素的baseline对齐的，而baseline又和父级底边有一定距离，注意下面两段文字。</p>\n<blockquote>\n<p>Look at this line of text. Notice there are no letters that breach the baseline</p>\n</blockquote>\n<p>另一段：</p>\n<blockquote>\n<p>By just crossing the bridge he probably got away.</p>\n</blockquote>\n<p>注意比较上面两段文字中字母<code>y,j,p,g</code>,下图更形象的显示<br><img src=\"http://7xjp74.com1.z0.glb.clouddn.com/jQaJx.png\" alt=\"jQaJx\"><br>因为浏览器提供空间低于inline元素来适应字体。这就是上面出现的白边。这不是CSS的padding或margin,所以开发中不容易发现。</p>\n<h2 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution\"></a>Solution</h2><ul>\n<li>给<code>&lt;img&gt;</code>元素设置<code>display:block</code></li>\n<li>给<code>&lt;img&gt;</code>元素设置<code>vertical-align:bottom</code>或者<code>vertical-align:top</code></li>\n<li>给<code>&lt;img&gt;</code>元素设置<code>font-size:0; vertical-align:middle;</code></li>\n<li>给<code>&lt;div&gt;</code>元素设置<code>line-height:0</code></li>\n<li>给<code>&lt;div&gt;</code>元素设置<code>font-size:0</code></li>\n<li>给<code>&lt;img&gt;</code>元素设置<code>vertical-align:text-bottom</code></li>\n</ul>\n<p>以上最后一条效果并不好，设置后仍有1px的白边，如下图：<br><img src=\"http://7xjp74.com1.z0.glb.clouddn.com/3.JPG\" alt=\"1px white space\"><br>而正常处理后是没有白边的，如下图：<br><img src=\"http://7xjp74.com1.z0.glb.clouddn.com/2.JPG\" alt=\"no white space\"></p>\n<h2 id=\"Code-source\"><a href=\"#Code-source\" class=\"headerlink\" title=\"Code source\"></a>Code source</h2><p><a href=\"http://runjs.cn/code/eozhsutb\" target=\"_blank\" rel=\"noopener\">源码与在线演示</a></p>\n<h2 id=\"References\"><a href=\"#References\" class=\"headerlink\" title=\"References\"></a>References</h2><ul>\n<li><a href=\"http://stackoverflow.com/questions/31444891/mystery-white-space-underneath-image-tag/31445364#31445364\" target=\"_blank\" rel=\"noopener\">Mystery white space underneath image tag</a></li>\n<li><a href=\"http://salman-w.blogspot.com/2012/10/remove-space-below-images-and-inline-block-elements.html\" target=\"_blank\" rel=\"noopener\">How to Remove the Space Below Images and Other Inline-Block Elements</a></li>\n<li><a href=\"http://stackoverflow.com/questions/7774814/remove-white-space-below-image\" target=\"_blank\" rel=\"noopener\">Remove white space below image</a></li>\n</ul>\n<p><em>欢迎补充</em></p>\n","categories":["前端积累"],"tags":["CSS"]},{"title":"CSS伪元素::after提示用法","url":"http://dearxiaojie.top/article/2015-09-05-CSS伪元素-after.html","content":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>CSS伪元素::after用来匹配已选中元素的一个虚拟的最后子元素，通常会配合content属性来为该元素添加装饰内容.这个虚拟元素默认是行内元素<br><a id=\"more\"></a></p>\n<h2 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h2><blockquote>\n<p><code>element:after  { style properties }</code>  /<em> CSS2 语法 </em>/<br><code>element::after { style properties }</code>  /<em> CSS3 语法 </em>/</p>\n</blockquote>\n<p><code>::after</code>表示法是在CSS 3中引入的,::符号是用来区分伪类和伪元素的.支持CSS3的浏览器同时也都支持CSS2中引入的表示法<code>:after</code>.</p>\n<p>##例子</p>\n<p>用<code>::after</code>伪元素，<a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/attr\" target=\"_blank\" rel=\"noopener\">attr()</a>CSS表达式和一个<a href=\"https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes\" target=\"_blank\" rel=\"noopener\">自定义数据属性</a> <code>data-descr</code> 创建一个纯CSS, 词汇表提示工具</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">\t&lt;p&gt;这是一段并没有什么用的</span><br><span class=\"line\">\t\t\t&lt;span data-descr=&apos;collection of words and punctuation&apos;&gt;文字&lt;/span&gt;</span><br><span class=\"line\">\t\t\t，完全是为了凑数才出现的文字，实现一个</span><br><span class=\"line\">\t\t\t&lt;span data-descr=&apos;small popups which also hide again&apos;&gt;提示&lt;/span&gt;</span><br><span class=\"line\">\t\t\t功能，可以吧鼠标放上去</span><br><span class=\"line\">\t\t\t&lt;span data-descr=&apos;not to be taken literrlly&apos;&gt;看看&lt;/span&gt;</span><br><span class=\"line\">\t&lt;/p&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">span[data-descr] &#123;</span><br><span class=\"line\">       position: relative;</span><br><span class=\"line\">       text-decoration: underline;</span><br><span class=\"line\">       color: #00F;</span><br><span class=\"line\">       cursor: help;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   span[data-descr]:hover::after &#123;</span><br><span class=\"line\">     content: attr(data-descr);</span><br><span class=\"line\">     position: absolute;</span><br><span class=\"line\">     left: 0;</span><br><span class=\"line\">     top: 24px;</span><br><span class=\"line\">     min-width: 200px;</span><br><span class=\"line\">     border: 1px #aaaaaa solid;</span><br><span class=\"line\">     border-radius: 10px;</span><br><span class=\"line\">     background-color: #ffffcc;</span><br><span class=\"line\">     padding: 12px;</span><br><span class=\"line\">     color: #000000;</span><br><span class=\"line\">     font-size: 14px;</span><br><span class=\"line\">     z-index: 1;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p><a href=\"http://runjs.cn/code/hkmnji2p\" target=\"_blank\" rel=\"noopener\">在线演示</a></p>\n<h2 id=\"效果图\"><a href=\"#效果图\" class=\"headerlink\" title=\"效果图\"></a>效果图</h2><p><img src=\"http://7xjp74.com1.z0.glb.clouddn.com/css%20after.png\" alt=\"css-after\"></p>\n<h2 id=\"浏览器兼容性\"><a href=\"#浏览器兼容性\" class=\"headerlink\" title=\"浏览器兼容性\"></a>浏览器兼容性</h2><p><img src=\"http://7xjp74.com1.z0.glb.clouddn.com/table.png\" alt=\"兼容性\"></p>\n<h2 id=\"References\"><a href=\"#References\" class=\"headerlink\" title=\"References\"></a>References</h2><ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/%3A%3Aafter\" target=\"_blank\" rel=\"noopener\">::after (:after)</a></li>\n</ul>\n","categories":["前端积累"],"tags":["CSS"]},{"title":"图解Javascript上下文与作用域","url":"http://dearxiaojie.top/article/2015-08-04-图解Javascript上下文与作用域.html","content":"<p>本文尝试阐述Javascript中的上下文与作用域背后的机制，主要涉及到执行上下文（<code>execution context</code>）、作用域链（<code>scope chain</code>）、闭包（<code>closure</code>）、<code>this</code>等概念。<br><a id=\"more\"></a></p>\n<h2 id=\"Execution-context\"><a href=\"#Execution-context\" class=\"headerlink\" title=\"Execution context\"></a>Execution context</h2><p>执行上下文（简称上下文）决定了Js执行过程中可以获取哪些变量、函数、数据，一段程序可能被分割成许多不同的上下文，每一个上下文都会绑定一个变量对象（<code>variable object</code>），它就像一个容器，用来存储当前上下文中所有已定义或可获取的变量、函数等。位于最顶端或最外层的上下文称为全局上下文（<code>global context</code>），全局上下文取决于执行环境，如Node中的<code>global</code>和Browser中的<code>window</code>：<br><img src=\"http://7xjp74.com1.z0.glb.clouddn.com/zhuanzai1.jpg\" alt=\"\"><br>需要注意的是，上下文与作用域（<code>scope</code>）是不同的概念。Js本身是单线程的，每当有<code>function</code>被执行时，就会产生一个新的上下文，这一上下文会被压入Js的上下文堆栈（<code>context stack</code>）中，<code>function</code>执行结束后则被弹出，因此Js解释器总是在栈顶上下文中执行。在生成新的上下文时，首先会绑定该上下文的变量对象，其中包括<code>arguments</code>和该函数中定义的变量；之后会创建属于该上下文的作用域链（<code>scope chain</code>），最后将<code>this</code>赋予这一<code>function</code>所属的<code>Object</code>，这一过程可以通过下图表示：<br><img src=\"http://7xjp74.com1.z0.glb.clouddn.com/zhuanzai2.jpg\" alt=\"\"></p>\n<h2 id=\"this\"><a href=\"#this\" class=\"headerlink\" title=\"this\"></a>this</h2><p>上文提到<code>this</code>被赋予<code>function</code>所属的<code>Object</code>，具体来说，当<code>function</code>是定义在<code>global</code>对中时，<code>this</code>指向<code>global</code>；当<code>function</code>作为<code>Object</code>的方法时，<code>this</code>指向该<code>Object</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var x = 1;  </span><br><span class=\"line\">var f = function()&#123;  </span><br><span class=\"line\">    console.log(this.x);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f();  // -&gt; 1</span><br><span class=\"line\">var ff = function()&#123;  </span><br><span class=\"line\">    this.x = 2;</span><br><span class=\"line\">    console.log(this.x);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ff(); // -&gt; 2  </span><br><span class=\"line\">x     // -&gt; 2</span><br><span class=\"line\">var o = &#123;x: &quot;o&apos;s x&quot;, f: f&#125;;  </span><br><span class=\"line\">o.f(); // &quot;o&apos;s x&quot;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Scope-chain\"><a href=\"#Scope-chain\" class=\"headerlink\" title=\"Scope chain\"></a>Scope chain</h2><p>上文提到，在<code>function</code>被执行时生成新的上下文时会先绑定当前上下文的变量对象，再创建作用域链。我们知道<code>function</code>的定义是可以嵌套在其他<code>function</code>所创建的上下文中，也可以并列地定义在同一个上下文中（如<code>global</code>）。作用域链实际上就是自下而上地将所有嵌套定义的上下文所绑定的变量对象串接到一起，使嵌套的<code>function</code>可以“继承”上层上下文的变量，而并列的<code>function</code>之间互不干扰：<br><img src=\"http://7xjp74.com1.z0.glb.clouddn.com/zhuanzai3.jpg\" alt=\"\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var x = &apos;global&apos;;  </span><br><span class=\"line\">function a()&#123;  </span><br><span class=\"line\">    var x = &quot;a&apos;s x&quot;;</span><br><span class=\"line\">    function b()&#123;</span><br><span class=\"line\">        var y = &quot;b&apos;s y&quot;;</span><br><span class=\"line\">        console.log(x);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    b();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function c()&#123;  </span><br><span class=\"line\">    var x = &quot;c&apos;s x&quot;;</span><br><span class=\"line\">    function d()&#123;</span><br><span class=\"line\">\t    console.log(y);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    d();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a();  // -&gt; &quot;a&apos;s x&quot;  </span><br><span class=\"line\">c();  // -&gt; ReferenceError: y is not defined  </span><br><span class=\"line\">x     // -&gt; &quot;global&quot;  </span><br><span class=\"line\">y     // -&gt; ReferenceError: y is not defined</span><br></pre></td></tr></table></figure>\n<h2 id=\"Closure\"><a href=\"#Closure\" class=\"headerlink\" title=\"Closure\"></a>Closure</h2><p>如果理解了上文中提到的上下文与作用域链的机制，再来看闭包的概念就很清楚了。每个<code>function</code>在调用时会创建新的上下文及作用域链，而作用域链就是将外层（上层）上下文所绑定的变量对象逐一串连起来，使当前<code>function</code>可以获取外层上下文的变量、数据等。如果我们在<code>function</code>中定义新的<code>function</code>，同时将内层<code>function</code>作为值返回，那么内层<code>function</code>所包含的作用域链将会一起返回，即使内层<code>function</code>在其他上下文中执行，其内部的作用域链仍然保持着原有的数据，而当前的上下文可能无法获取原先外层<code>function</code>中的数据，使得<code>function</code>内部的作用域链被保护起来，从而形成“闭包”。看下面的例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var x = 100;  </span><br><span class=\"line\">var inc = function()&#123;  </span><br><span class=\"line\">    var x = 0;</span><br><span class=\"line\">    return function()&#123;</span><br><span class=\"line\">        console.log(x++);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var inc1 = inc();  </span><br><span class=\"line\">var inc2 = inc();</span><br><span class=\"line\">inc1();  // -&gt; 0  </span><br><span class=\"line\">inc1();  // -&gt; 1  </span><br><span class=\"line\">inc2();  // -&gt; 0  </span><br><span class=\"line\">inc1();  // -&gt; 2  </span><br><span class=\"line\">inc2();  // -&gt; 1  </span><br><span class=\"line\">x;       // -&gt; 100</span><br></pre></td></tr></table></figure>\n<p>执行过程如下图所示，<code>inc</code>内部返回的匿名<code>function</code>在创建时生成的作用域链包括了<code>inc</code>中的<code>x</code>，即使后来赋值给<code>inc1</code>和<code>inc2</code>之后，直接在<code>global context</code>下调用，它们的作用域链仍然是由定义中所处的上下文环境决定，而且由于<code>x</code>是在<code>function inc</code>中定义的，无法被外层的<code>global context</code>所改变，从而实现了闭包的效果：<br><img src=\"http://7xjp74.com1.z0.glb.clouddn.com/zhuanzai4.jpg\" alt=\"\"></p>\n<h2 id=\"this-in-closure\"><a href=\"#this-in-closure\" class=\"headerlink\" title=\"this in closure\"></a>this in closure</h2><p>我们已经反复提到执行上下文和作用域实际上是通过<code>function</code>创建、分割的，而<code>function</code>中的<code>this</code>与作用域链不同，它是由执行该<code>function</code>时当前所处的<code>Object</code>环境所决定的，这也是<code>this</code>最容易被混淆用错的一点。一般情况下的例子如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var name = &quot;global&quot;;  </span><br><span class=\"line\">var o = &#123;  </span><br><span class=\"line\">    name: &quot;o&quot;,</span><br><span class=\"line\">    getName: function()&#123;</span><br><span class=\"line\">        return this.name</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">o.getName();  // -&gt; &quot;o&quot;</span><br></pre></td></tr></table></figure>\n<p>由于执行<code>o.getName()</code>时<code>getName</code>所绑定的<code>this</code>是调用它的<code>o</code>，所以此时<code>this == o</code>；更容易搞混的是在<code>closure</code>条件下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var name = &quot;global&quot;;  </span><br><span class=\"line\">var oo = &#123;  </span><br><span class=\"line\">    name: &quot;oo&quot;,</span><br><span class=\"line\">    getNameFunc: function()&#123;</span><br><span class=\"line\">        return function()&#123;</span><br><span class=\"line\">            return this.name;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">oo.getNameFunc()();  // -&gt; &quot;global&quot;</span><br></pre></td></tr></table></figure>\n<p>此时闭包函数被<code>return</code>后调用相当于：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">getName = oo.getNameFunc();  </span><br><span class=\"line\">getName();  // -&gt; &quot;global&quot;</span><br></pre></td></tr></table></figure>\n<p>换一个更明显的例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var ooo = &#123;  </span><br><span class=\"line\">    name: &quot;ooo&quot;,</span><br><span class=\"line\">    getName: oo.getNameFunc() // 此时闭包函数的this被绑定到新的Object</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">ooo.getName();  // -&gt; &quot;ooo&quot;</span><br></pre></td></tr></table></figure>\n<p>当然，有时候为了避免闭包中的<code>this</code>在执行时被替换，可以采取下面的方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var name = &quot;global&quot;;  </span><br><span class=\"line\">var oooo = &#123;  </span><br><span class=\"line\">    name: &quot;ox4&quot;,</span><br><span class=\"line\">    getNameFunc: function()&#123;</span><br><span class=\"line\">        var self = this;</span><br><span class=\"line\">        return function()&#123;</span><br><span class=\"line\">            return self.name;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">oooo.getNameFunc()(); // -&gt; &quot;ox4&quot;</span><br></pre></td></tr></table></figure>\n<p>或者是在调用时强行定义执行的<code>Object</code>：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var name = &quot;global&quot;;  </span><br><span class=\"line\">var oo = &#123;  </span><br><span class=\"line\">    name: &quot;oo&quot;,</span><br><span class=\"line\">    getNameFunc: function()&#123;</span><br><span class=\"line\">        return function()&#123;</span><br><span class=\"line\">            return this.name;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">oo.getNameFunc()();  // -&gt; &quot;global&quot;  </span><br><span class=\"line\">oo.getNameFunc().bind(oo)(); // -&gt; &quot;oo&quot;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>Js是一门很有趣的语言，由于它的很多特性是针对HTML中DOM的操作，因而显得随意而略失严谨，但随着前端的不断繁荣发展和Node的兴起，Js已经不再是”toy language”或是jQuery时代的”CSS扩展”，本文提到的这些概念无论是对新手还是从传统Web开发中过度过来的Js开发人员来说，都很容易被混淆或误解，希望本文可以有所帮助。</p>\n<p>写这篇总结的原因是我在Github上分享的<a href=\"https://github.com/coodict/javascript-in-one-pic\" target=\"_blank\" rel=\"noopener\">Learn javascript in one picture</a>，刚开始有人质疑这只能算是一张语法表（syntax cheat sheet），根本不会涉及更深层的闭包、作用域等内容，但是出乎意料的是这个项目竟然获得3000多个star，所以不能虎头蛇尾，以上。</p>\n<h2 id=\"References\"><a href=\"#References\" class=\"headerlink\" title=\"References\"></a>References</h2><ul>\n<li><a href=\"http://ryanmorr.com/understanding-scope-and-context-in-javascript/\" target=\"_blank\" rel=\"noopener\">Understanding Scope and Context in JavaScript</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this\" target=\"_blank\" rel=\"noopener\">this - JavaScript | MDN</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures\" target=\"_blank\" rel=\"noopener\">闭包 - JavaScript | MDN</a></li>\n</ul>\n<p><em><a href=\"http://blog.rainy.im/2015/07/04/scope-chain-and-prototype-chain-in-js/\" target=\"_blank\" rel=\"noopener\">原文猛戳</a></em></p>\n","categories":["转载"],"tags":["javascript","概念理解"]},{"title":"javascript性能优化小知识","url":"http://dearxiaojie.top/article/2015-07-27-javascript性能优化小知识.html","content":"<p>前面有一篇也是关于<code>javascript</code>性能方面的文章，是看了<a href=\"http://book.douban.com/subject/5362856/\" target=\"_blank\" rel=\"noopener\">《高性能javascript》</a>后的笔记，这是一篇自己在项目和学习过程中的积累，部分参考了一些学习博客。对面试和代码的编写都有帮助。<br><a id=\"more\"></a></p>\n<h3 id=\"避免全局查找\"><a href=\"#避免全局查找\" class=\"headerlink\" title=\"避免全局查找\"></a>避免全局查找</h3><p>在一个函数中会用到全局对象存储为局部变量来减少全局查找，因为访问局部变量的速度要比访问全局变量的速度更快些。</p>\n<h3 id=\"字符串的连接\"><a href=\"#字符串的连接\" class=\"headerlink\" title=\"字符串的连接\"></a>字符串的连接</h3><p>如果要连接多个字符串，应该少使用+=，如<br>s+=a;<br>s+=b;<br>s+=c;<br>应该写成s+=a + b + c；<br>而如果是收集字符串，比如多次对同一个字符串进行+=操作的话，最好使用一个缓存，使用<code>JavaScript</code>数组来收集，最后使用<code>join</code>方法连接起来。</p>\n<h3 id=\"数字转换成字符串\"><a href=\"#数字转换成字符串\" class=\"headerlink\" title=\"数字转换成字符串\"></a>数字转换成字符串</h3><p><code>(&quot;&quot; +) &gt; String() &gt; .toString() &gt; new String()</code><br>字符串如’1322’转换成数字的时候可以在前面加’+’,如<code>var str = &#39;123&#39;;var num = +str</code>,那么<code>typeof num</code>为<code>number</code></p>\n<h3 id=\"浮点数转换成整型\"><a href=\"#浮点数转换成整型\" class=\"headerlink\" title=\"浮点数转换成整型\"></a>浮点数转换成整型</h3><p>很多人喜欢使用<code>parseInt()</code>，其实<code>parseInt()</code>是用于将字符串转换成数字，而不是浮点数和整型之间的转换，我们应该使用<code>Math.floor()</code>或者<code>Math.round()</code>。</p>\n<h3 id=\"使用DocumentFragment优化多次append\"><a href=\"#使用DocumentFragment优化多次append\" class=\"headerlink\" title=\"使用DocumentFragment优化多次append\"></a>使用DocumentFragment优化多次append</h3><p>一旦需要更新DOM,请考虑使用文档碎片来构建DOM结构，然后再将其添加到现存的文档中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">for (var i = 0; i &lt; 1000; i++) &#123;</span><br><span class=\"line\">          var el = document.createElement(&apos;p&apos;);</span><br><span class=\"line\">          el.innerHTML = i;</span><br><span class=\"line\">          document.body.appendChild(el);</span><br><span class=\"line\">      &#125;       </span><br><span class=\"line\">       //可以替换为：</span><br><span class=\"line\">      var frag = document.createDocumentFragment();</span><br><span class=\"line\">          for (var i = 0; i &lt; 1000; i++) &#123;  </span><br><span class=\"line\">              var el = document.createElement(&apos;p&apos;);</span><br><span class=\"line\">          \tel.innerHTML = i;</span><br><span class=\"line\">          \tfrag.appendChild(el);</span><br><span class=\"line\">      \t&#125;</span><br><span class=\"line\">      document.body.appendChild(frag);</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用一次innerHTML赋值代替构建dom元素\"><a href=\"#使用一次innerHTML赋值代替构建dom元素\" class=\"headerlink\" title=\"使用一次innerHTML赋值代替构建dom元素\"></a>使用一次innerHTML赋值代替构建dom元素</h3><p>对于大的DOM更改，使用<code>innerHTML</code>要比使用标准的DOM方法创建同样的DOM结构快得多。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var frag = document.createDocumentFragment();</span><br><span class=\"line\">     for (var i = 0; i &lt; 1000; i++) &#123;</span><br><span class=\"line\">         var el = document.createElement(&apos;p&apos;);</span><br><span class=\"line\">         el.innerHTML = i;</span><br><span class=\"line\">         frag.appendChild(el);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     document.body.appendChild(frag);</span><br><span class=\"line\">         //可以替换为：</span><br><span class=\"line\">     var html = [];</span><br><span class=\"line\">         for (var i = 0; i &lt; 1000; i++) &#123;</span><br><span class=\"line\">         html.push(&apos;&lt;p&gt;&apos; + i + &apos;&lt;/p&gt;&apos;);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     document.body.innerHTML = html.join(&apos;&apos;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用事件代理\"><a href=\"#使用事件代理\" class=\"headerlink\" title=\"使用事件代理\"></a>使用事件代理</h3><p>任何可以冒泡的事件都不仅仅可以在事件目标上进行处理，目标的任何祖先节点上也能处理，使用这个知识就可以将事件处理程序附加到更高的地方负责多个目标的事件处理，同样，对于内容动态增加并且子节点都需要相同的事件处理函数的情况，可以把事件注册提到父节点上，这样就不需要为每个子节点注册事件监听了。另外，现有的js库都采用<code>observe</code>方式来创建事件监听,其实现上隔离了DOM对象和事件处理函数之间的循环引用,所以应该尽量采用这种方式来创建事件监听</p>\n<h3 id=\"缩短否定检测\"><a href=\"#缩短否定检测\" class=\"headerlink\" title=\"缩短否定检测\"></a>缩短否定检测</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">if (oTest != &apos;#ff0000&apos;) &#123;</span><br><span class=\"line\">    //do something</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">if (oTest != null) &#123;</span><br><span class=\"line\">    //do something</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">if (oTest != false) &#123;</span><br><span class=\"line\">    //do something</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    //虽然这些都正确，但用逻辑非操作符来操作也有同样的效果：</span><br><span class=\"line\">if (!oTest) &#123;</span><br><span class=\"line\">    //do something</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"条件分支\"><a href=\"#条件分支\" class=\"headerlink\" title=\"条件分支\"></a>条件分支</h3><p>将条件分支，按可能性顺序从高到低排列：可以减少解释器对条件的探测次数<br>在同一条件子的多（&gt;2）条件分支时，使用<code>switch</code>优于<code>if</code>：<code>switch</code>分支选择的效率高于if，在IE下尤为明显。4分支的测试，IE下<code>switch</code>的执行时间约为if的一半。<br>使用三目运算符替代条件分支</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">if (a &gt; b) &#123;</span><br><span class=\"line\">           num = a;</span><br><span class=\"line\">       &#125; else &#123;</span><br><span class=\"line\">           num = b;</span><br><span class=\"line\">       &#125;        //可以替换为：</span><br><span class=\"line\">       num = a &gt; b ? a : b;</span><br></pre></td></tr></table></figure>\n<p><em>续。。。</em></p>\n","categories":["学习笔记"],"tags":["javascript","性能优化"]},{"title":"jQuery常用方法归纳","url":"http://dearxiaojie.top/article/2015-06-27-jQuery常用方法归纳总结.html","content":"<h1 id=\"grep\"><a href=\"#grep\" class=\"headerlink\" title=\"$.grep()\"></a>$.grep()</h1><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$.grep( array, function(elementOfArray, indexInArray) [, invert ] )</span><br></pre></td></tr></table></figure>\n<p>功能：查找满足过滤函数的数组元素：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;script src=&quot;js/jquery1.42.min.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">    &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class=\"line\">        $(function () &#123;</span><br><span class=\"line\">            var arr = [23,45,5,1,4,67,8,100,-2];</span><br><span class=\"line\">            var arrGrep = $.grep(arr, function (element,index) &#123;</span><br><span class=\"line\">                return (index&lt;5)&amp;&amp;(element != 4);//整体返回一个数组</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">            alert(arrGrep);//23,45,5,1</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\"> &lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<h1 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"$.map()\"></a>$.map()</h1><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$.map( array, callback(elementOfArray, indexInArray) )</span><br></pre></td></tr></table></figure>\n<p>功能：将一个数组中的所有元素转换到另一个数组中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;script src=&quot;js/jquery1.42.min.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class=\"line\">    $(function () &#123;</span><br><span class=\"line\">        var arr = [5,1,4,67,8,100,-2];</span><br><span class=\"line\">        var arrMap = $.map(arr, function (element,index) &#123;</span><br><span class=\"line\">            //  return (index&lt;3)&amp;&amp;(element != 4);这里按布尔值返回</span><br><span class=\"line\">            if(index&lt;3 &amp;&amp; element&lt; 4)&#123;</span><br><span class=\"line\">                return element;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        alert(arrMap);//1</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<h1 id=\"mouseover-mouserout\"><a href=\"#mouseover-mouserout\" class=\"headerlink\" title=\"mouseover()/mouserout()\"></a>mouseover()/mouserout()</h1><p>当鼠标进入/离开某个元素或它的后代元素时触发<code>mouseover/mouseout</code>事件。<br><code>mouseover</code>事件大多数时候会与 <code>mouseout</code> 事件一起使用。</p>\n<p><code>mouseover/mouserout</code>事件由于冒泡机制，经常在不需要的时候不小心触发，从而导致一些脚本问题。</p>\n<h1 id=\"mouseenter-mouseleave\"><a href=\"#mouseenter-mouseleave\" class=\"headerlink\" title=\"mouseenter()/mouseleave()\"></a>mouseenter()/mouseleave()</h1><p>mouseenter/mouseleave当且仅当鼠标进入被选元素时才触发，当鼠标穿过任何子元素时不会触发。它不关心目标元素是否有子元素。</p>\n<h1 id=\"focusin-和focusout\"><a href=\"#focusin-和focusout\" class=\"headerlink\" title=\"focusin()和focusout()\"></a>focusin()和focusout()</h1><p><code>.focusin()</code>：一个元素或它的子元素得到焦点时触发此事件<br><code>.focusout()</code>：一个元素或它的子元素失去焦点时触发此事件</p>\n<p>与 <code>focus()</code> 方法不同的是，<code>focusin()</code> 方法在任意子元素获得焦点时也会触发。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;p&gt;&lt;input type=&quot;text&quot;&gt; &lt;span&gt;focusin fire&lt;/span&gt;&lt;/p&gt;</span><br><span class=\"line\">    &lt;p&gt;&lt;input type=&quot;password&quot;&gt; &lt;span&gt;focusin fire&lt;/span&gt;&lt;/p&gt;</span><br><span class=\"line\">    &lt;script&gt;</span><br><span class=\"line\">    $( &quot;p&quot; ).focusin(function() &#123;</span><br><span class=\"line\">        $( this ).find( &quot;span&quot; ).css( &quot;display&quot;, &quot;inline&quot; ).fadeOut( 1000 );</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    &lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br></pre></td></tr></table></figure>\n<h1 id=\"eq-和get\"><a href=\"#eq-和get\" class=\"headerlink\" title=\"eq()和get()\"></a>eq()和get()</h1><p><code>.get()</code>： 通过jQuery对象获取一个对应的DOM元素。<br><code>.eq()</code>：从集合的一个元素中构造新的jQuery对象</p>\n<p><code>eq</code>返回的是一个jQuery对象，<code>get</code>返回的是一个DOM对象。举个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$( &quot;li&quot; ).get( 0 ).css(&quot;color&quot;, &quot;red&quot;); //错误</span><br><span class=\"line\">$( &quot;li&quot; ).eq( 0 ).css(&quot;color&quot;, &quot;red&quot;); //正确</span><br></pre></td></tr></table></figure>\n<p>那么，什么是DOM对象，什么又是jQuery对象呢？</p>\n<p>DOM对象就是用js获得的对象，而juqery对象是用jQuery类库的选择器获得的对象。</p>\n<p>如：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var $obj = $(&quot;div&quot;);//jQuery对象</span><br></pre></td></tr></table></figure></p>\n<p><code>get</code>方法本质上是把jQuery对象转换成DOM对象，但是css属于jQuery构造器的，DOM是不存在这个方法的，如果需要用jQuery的方法，我们必须这样写：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var li = $(&quot;li&quot;).get(0);</span><br><span class=\"line\">$(li).css(&quot;color&quot;,&quot;black&quot;);//用$包装</span><br><span class=\"line\">filter()</span><br></pre></td></tr></table></figure></p>\n<p><code>filter()</code>方法:筛选出与指定表达式匹配的元素集合。<br>这个方法用于缩小匹配的范围。用逗号分隔多个表达式。</p>\n<p><code>filter(expression)</code>：（字符串|函数）如果参数是字符串，则制定jQuery选择器，用于从包装集里删除所有与选择器不匹配的元素，最后留下与选择器匹配的元素；如果参数是函数，则用于确定筛选条件。为包装集里的每一个元素各调用一次该函数，函数调用返回值为false的任何元素都会从包装集里删除。</p>\n<p>以下代码意为：保留第一个以及带有select类的元素</p>\n<p>HTML 代码:<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;p&gt;Hello&lt;/p&gt;&lt;p&gt;Hello Again&lt;/p&gt;&lt;p class=&quot;selected&quot;&gt;And Again&lt;/p&gt;</span><br></pre></td></tr></table></figure></p>\n<p>jQuery 代码:<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$(&quot;p&quot;).filter(&quot;.selected, :first&quot;);</span><br></pre></td></tr></table></figure></p>\n<p>结果:<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;p&gt;Hello&lt;/p&gt;, &lt;p class=&quot;selected&quot;&gt;And Again&lt;/p&gt;</span><br></pre></td></tr></table></figure></p>\n<p>再看一个function的例子，一个函数用来作为测试元素的集合。它接受一个参数index，这是元素在jQuery集合的索引。在函数， <code>this</code>指的是当前的DOM元素。</p>\n<p>HTML 代码:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;p&gt;&lt;ol&gt;&lt;li&gt;Hello&lt;/li&gt;&lt;/ol&gt;&lt;/p&gt;&lt;p&gt;How are you?&lt;/p&gt;</span><br></pre></td></tr></table></figure>\n<p>jQuery 代码:<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$(&quot;p&quot;).filter(function(index) &#123;</span><br><span class=\"line\">    return $(&quot;ol&quot;, this).length == 0;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>结果:<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;p&gt;How are you?&lt;/p&gt;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"bind-、-live-和-delegate-方法\"><a href=\"#bind-、-live-和-delegate-方法\" class=\"headerlink\" title=\".bind()、.live()和.delegate()方法\"></a>.bind()、.live()和.delegate()方法</h1><p><code>.bind()</code>：绑定事件处理函数的最基本方式是使用<code>.bind()</code>方法。它和<code>live()</code>方法一样，接受两个参数：</p>\n<p><code>.bind(event type, event handler)</code><br>两种绑定事件处理函数的方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$(document).ready(function()&#123;</span><br><span class=\"line\">    $(&apos;.mydiv&apos;).bind(&apos;click&apos;,test);</span><br><span class=\"line\">    function test()&#123;</span><br><span class=\"line\">        alert(&quot;￼Hello World!&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n<p>事件处理函数也可以使用匿名函数，如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$(document).ready(function()&#123;</span><br><span class=\"line\">    $(&quot;#mydiv&quot;).bind(&quot;click&quot;,function()&#123;</span><br><span class=\"line\">        alert(&quot;￼Hello World!&quot;);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p><code>.live()</code>：<code>live</code>方法和<code>bind</code>方法的唯一区别在于<code>.live()</code>不仅作用于DOM中当前存在的元素，还作用于将来可能存在（动态生成）的元素<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$(document).ready(function()&#123;</span><br><span class=\"line\">$(&apos;.box&apos;).live(&apos;click&apos;,function()&#123;</span><br><span class=\"line\">        $(this).clone().appendTo(&apos;.container&apos;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">&lt;div class=&quot;container&quot;&gt;</span><br><span class=\"line\">    &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>\n<p>使用<code>live</code>方法绑定事件的缺点在于它无法使用链式调用，那有没有既可以像<code>live</code>方法那样绑定事件，又可以支持链式调用的方法呢？答案就是下面的<code>delegate</code>方法。</p>\n<p><code>delegate()</code>方法：为指定的元素（属于被选元素的子元素）添加一个或多个事件处理程序，<br>并规定当这些事件发生时运行的函数。从jQuery 1.7开始，<code>.delegate()</code>已经被<code>.on()</code>方法取代。<br>语法：</p>\n<p> <code>$(selector).delegate(childSelector,event type,function)</code><br>参数说明：</p>\n<p><code>childSelector</code> 必需。规定要附加事件处理程序的一个或多个子元素。</p>\n<p><code>event</code> 必需。规定附加到元素的一个或多个事件。由空格分隔多个事件值。必须是有效的事件。</p>\n<p><code>function</code> 必需。规定当事件发生时运行的函数。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$(document).ready(function()&#123;</span><br><span class=\"line\">    $(&apos;.container&apos;).delegate(&apos;.box&apos;,&apos;click&apos;,function()&#123;</span><br><span class=\"line\">        $(this).clone().appendTo(&apos;.container&apos;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p><code>delegate()</code>会在以下两个情况下使用到：</p>\n<p>1、如果你有一个父元素，需要给其下的子元素添加事件，这时你可以使用<code>delegate()</code>了，代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$(&quot;ul&quot;).delegate(&quot;li&quot;, &quot;click&quot;, function()&#123;</span><br><span class=\"line\">    $(this).hide();</span><br><span class=\"line\"> &#125;);</span><br></pre></td></tr></table></figure></p>\n<p>2、当元素在当前页面中不可用时，可以使用<code>delegate()</code></p>\n<p><code>end()</code>方法</p>\n<p> <code>end()</code>方法：在jquery命令链内调用，以便退回到前一个包装集。<br>每次过滤方法都会被压入栈中。当我们需要返回到前一个状态时，我们可以使用<code>end()</code> 进行出栈操作，来返回栈中的前一个状态。</p>\n<p><code>end()</code> 方法结束当前链条中的最近的筛选操作，并将匹配元素集还原为之前的状态。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot; /&gt;</span><br><span class=\"line\">&lt;title&gt;&lt;/title&gt;</span><br><span class=\"line\">&lt;script src=&quot;http://libs.baidu.com/jquery/1.9.0/jquery.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">&lt;ul class=&quot;one&quot;&gt;</span><br><span class=\"line\">&lt;li class=&quot;two&quot;&gt;item 1&lt;/li&gt;</span><br><span class=\"line\">&lt;li&gt;item 2&lt;/li&gt;</span><br><span class=\"line\">&lt;li class=&quot;three&quot;&gt;item 3&lt;/li&gt;</span><br><span class=\"line\">&lt;/ul&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class=\"line\">$(&apos;ul.one&apos;).find(&quot;.two&quot;).css(&quot;color&quot;,&quot;red&quot;).find(&apos;.three&apos;).css(&quot;background&quot;,&quot;blue&quot;);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<p>在上面的代码例子中，我们只会看到item 1的字体颜色改变了，而背景颜色没有改变。这是因为<br>第二个<code>find()</code>方法之前的状态返回的是红色字体的<code>class</code>值为<code>two</code>的对象，因此，第二次<code>find()</code>只会查找<code>&lt;ul class=&quot;one&quot;&gt;</code> 中的<code>.two</code>，使用<code>end()</code>方法修改该链式操作的代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class=\"line\">    $(&apos;ul.one&apos;).find(&quot;.two&quot;).css(&quot;color&quot;,&quot;red&quot;).end().find(&apos;.three&apos;).css(&quot;background&quot;,&quot;blue&quot;);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<p><code>end()</code>方法在这里是 返回调用 <code>find()</code> 之前的状态，也就是<code>$(&#39;ul.one&#39;)</code></p>\n<h1 id=\"toggleClass\"><a href=\"#toggleClass\" class=\"headerlink\" title=\"toggleClass()\"></a>toggleClass()</h1><p><code>toggleClass()</code>方法：如果在元素中指定类名称不存在，则添加指定类名称；如果元素已经拥有指定类名称，则从元素中删除指定类名称。<br><code>css(name,value)</code>方法：设定指定的值到每个已匹配元素的指定的css样式属性</p>\n<h1 id=\"wrap-和wrapInner\"><a href=\"#wrap-和wrapInner\" class=\"headerlink\" title=\"wrap()和wrapInner()\"></a>wrap()和wrapInner()</h1><p><code>wrap()和wrapInner()</code>：前者把所有匹配的元素用其他元素的结构化标记包裹起来；<br>后者将每一个匹配的元素的子内容(包括文本节点)用一个HTML结构包裹起来。<br>看下面一个<code>wrap()</code>的例子：<br>用原先div的内容作为新div的class，并将每一个元素包裹起来</p>\n<p>HTML 代码:<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div class=&quot;container&quot;&gt;</span><br><span class=\"line\">&lt;div class=&quot;inner&quot;&gt;Hello&lt;/div&gt;</span><br><span class=\"line\">&lt;div class=&quot;inner&quot;&gt;Goodbye&lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>\n<p>jQuery 代码:<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$(&apos;.inner&apos;).wrap(function() &#123;</span><br><span class=\"line\">    return &apos;&lt;div class=&quot;&apos; + $(this).text() + &apos;&quot; /&gt;&apos;;</span><br><span class=\"line\"> &#125;);</span><br></pre></td></tr></table></figure></p>\n<p>结果:<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div class=&quot;container&quot;&gt;</span><br><span class=\"line\">    &lt;div class=&quot;Hello&quot;&gt;</span><br><span class=\"line\">        &lt;div class=&quot;inner&quot;&gt;Hello&lt;/div&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">    &lt;div class=&quot;Goodbye&quot;&gt;</span><br><span class=\"line\">        &lt;div class=&quot;inner&quot;&gt;Goodbye&lt;/div&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>\n<p>接着再看下面一个<code>wrapInner()</code>的例子:</p>\n<p>用原先div的内容作为新div的class，并将每一个元素包裹起来</p>\n<p>HTML 代码:<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div class=&quot;container&quot;&gt;</span><br><span class=\"line\">    &lt;div class=&quot;inner&quot;&gt;Hello&lt;/div&gt;</span><br><span class=\"line\">    &lt;div class=&quot;inner&quot;&gt;Goodbye&lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>\n<p>jQuery 代码:<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$(&apos;.inner&apos;).wrapInner(function() &#123;</span><br><span class=\"line\">    return &apos;&lt;div class=&quot;&apos; + $(this).text() + &apos;&quot; /&gt;&apos;;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>结果:<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div class=&quot;container&quot;&gt;</span><br><span class=\"line\">    &lt;div class=&quot;inner&quot;&gt;</span><br><span class=\"line\">        &lt;div class=&quot;Hello&quot;&gt;Hello&lt;/div&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">    &lt;div class=&quot;inner&quot;&gt;</span><br><span class=\"line\">        &lt;div class=&quot;Goodbye&quot;&gt;Goodbye&lt;/div&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"detach、empty和remove方法\"><a href=\"#detach、empty和remove方法\" class=\"headerlink\" title=\"detach、empty和remove方法\"></a>detach、empty和remove方法</h1><p><code>.detach( [selector ] )</code>：从DOM中去掉所有匹配的元素。当需要移走一个元素，不久又将该元素插入DOM时，就需要用到detach方法。</p>\n<p><code>.empty()</code>：这个方法不仅移除子元素（和其他后代元素），同样移除元素里的文本。因为，根据说明，元素里任何文本字符串都被看做是该元素的子节点。</p>\n<p><code>.remove( [selector ] )</code>：将元素从DOM中移除，同时移除元素上的事件及 jQuery 数据</p>\n<p><code>empty()</code>的例子：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;ul class=&quot;one&quot;&gt;</span><br><span class=\"line\">    &lt;li class=&quot;two&quot;&gt;item 1&lt;/li&gt;</span><br><span class=\"line\">    &lt;li&gt;item 2&lt;/li&gt;</span><br><span class=\"line\">    &lt;li class=&quot;three&quot;&gt;item 3&lt;/li&gt;</span><br><span class=\"line\">    &lt;/ul&gt;</span><br><span class=\"line\">    &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class=\"line\">        $(&quot;.two&quot;).empty();//item 1 文本节点被移除，li的小圆点还在，证明li没有被移除</span><br><span class=\"line\">    &lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<p>看下面一个<code>remove()</code>例子：</p>\n<p>描述：从DOM中把所有段落删除</p>\n<p>HTML 代码:<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;p&gt;Hello&lt;/p&gt; how are &lt;p&gt;you?&lt;/p&gt;</span><br></pre></td></tr></table></figure></p>\n<p>jQuery 代码:<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$(&quot;p&quot;).remove();</span><br></pre></td></tr></table></figure></p>\n<p>结果:<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">how are</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"val-方法\"><a href=\"#val-方法\" class=\"headerlink\" title=\"val()方法\"></a>val()方法</h1><p><code>val()</code>：获得匹配元素的当前值。<br>描述:获取文本框中的值</p>\n<p>jQuery 代码:<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$(&quot;input&quot;).val();</span><br></pre></td></tr></table></figure></p>\n<p>jQuery 代码:<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$(&quot;input&quot;).val(&quot;hello world!&quot;);</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"each-和map\"><a href=\"#each-和map\" class=\"headerlink\" title=\"each()和map()\"></a>each()和map()</h1><p><code>each()</code>和<code>map()</code>方法：<code>each</code>返回的是原来的数组，并不会新创建一个数组。而map方法会返回一个<br>新的数组。如果在没有必要的情况下使用map，则有可能造成内存浪费。</p>\n<h2 id=\"each方法：\"><a href=\"#each方法：\" class=\"headerlink\" title=\"each方法：\"></a>each方法：</h2><p>定义一个空数组，通过each方法，往数组添加ID值；最后将数组转换成字符串后，alert这个值；<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$(function()&#123;</span><br><span class=\"line\">    var arr = [];</span><br><span class=\"line\">    $(&quot;:checkbox&quot;).each(function(index)&#123;</span><br><span class=\"line\">        arr.push(this.id);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    var str = arr.join(&quot;,&quot;);</span><br><span class=\"line\">    alert(str);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"map方法\"><a href=\"#map方法\" class=\"headerlink\" title=\"map方法:\"></a>map方法:</h2><p>将每个<code>:checkbox</code>执行<code>return this.id</code>；并将这些返回值，自动的保存为jQuery对象，然后用get方法将其转换成原生Javascript数组，再使用join方法转换成字符串，最后alert这个值；<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$(function()&#123;</span><br><span class=\"line\">    var str = $(&quot;:checkbox&quot;).map(function() &#123;</span><br><span class=\"line\">        return this.id;</span><br><span class=\"line\">    &#125;).get().join();    </span><br><span class=\"line\">    alert(str);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>当有需一个数组的值的时候，用map方法，很方便。</p>\n<h2 id=\"each\"><a href=\"#each\" class=\"headerlink\" title=\"$.each()\"></a>$.each()</h2><p>jQuery的<code>$(selector).each()</code>函数可以遍历循环选中的子元素，而jQuery的$.each()函数则可以遍历任何集合，包括对象和数组，它接收要遍历的集合以及一个回调函数，回调函数每次传递一个数组的下标和这个下标所对应的数组的值。</p>\n<p><code>$.each(array,callback);</code></p>\n<p><code>$.each(object,callback);</code></p>\n<h2 id=\"数组实例\"><a href=\"#数组实例\" class=\"headerlink\" title=\"数组实例\"></a>数组实例</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$.each( [ &quot;one&quot;, &quot;two&quot;, &quot;three&quot; ], function( i, l )&#123;</span><br><span class=\"line\">    alert( &quot;index #&quot; + i + &quot;: &quot; + l );</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p><code>callback</code>(索引,索引值)<br>DEMO：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">index 0: one</span><br><span class=\"line\">index 1: two;</span><br><span class=\"line\">index 2: three</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"对象实例\"><a href=\"#对象实例\" class=\"headerlink\" title=\"对象实例\"></a>对象实例</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$.each(&#123; name: &quot;trigkit4&quot;, lang: &quot;JS&quot; &#125;, function( k, v ) &#123;</span><br><span class=\"line\">    alert( &quot;Key: &quot; + k + &quot;, Value: &quot; + v );</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p><code>callback</code>(键,值)</p>\n<p>Demo:<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Key: name, Value: trigkit4</span><br><span class=\"line\">Key: lang, Value: JS</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"trigger\"><a href=\"#trigger\" class=\"headerlink\" title=\".trigger()\"></a>.trigger()</h1><p>描述: 根据绑定到匹配元素的给定的事件类型执行所有的处理程序和行为。</p>\n<p>当相应的事件发生时，任何通过.on()、.bind()或一个快捷方法绑定的事件处理程序将被触发。但是，它们可以用.trigger()方法手动触发<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class=\"line\">    $(document).bind(&apos;abc&apos;,function()&#123;</span><br><span class=\"line\">        console.log(&apos;hello&apos;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">$(document).trigger(&apos;abc&apos;);</span><br><span class=\"line\">//Output  &apos;hello&apos;;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"attr-和-prop\"><a href=\"#attr-和-prop\" class=\"headerlink\" title=\".attr()和.prop()\"></a>.attr()和.prop()</h1><p><code>.attr()</code>：获取匹配的元素集合中的第一个元素的属性的值 或 设置每一个匹配元素的一个或多个属性。</p>\n<p><code>.prop()</code>：同上<br>jQuery 1.6之前 ，<code>.attr()</code>方法在取某些 <code>attribute</code> 的值时，会返回 <code>property</code> 的值，这就导致了结果的不一致。从 jQuery 1.6 开始， <code>.prop()</code>方法 方法返回 <code>property</code> 的值,而 <code>.attr()</code> 方法返回 <code>attributes</code> 的值。</p>\n<p>例如, <code>selectedIndex, tagName, nodeName, nodeType, ownerDocument, defaultChecked</code>, 和 <code>defaultSelected</code> 应使用<code>.prop()</code>方法进行取值或赋值。</p>\n<p>他们没有相应的属性（<code>attributes</code>），只有特性(<code>property</code>)。</p>\n<h1 id=\"after-和-insertAfter\"><a href=\"#after-和-insertAfter\" class=\"headerlink\" title=\".after()和.insertAfter()\"></a>.after()和.insertAfter()</h1><h2 id=\"after\"><a href=\"#after\" class=\"headerlink\" title=\".after()\"></a>.after()</h2><p>描述:<br>在所有段落中后插入一个jQuery对象(类似于一个DOM元素数组)。</p>\n<p>HTML 代码:<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;b&gt;Hello&lt;/b&gt;&lt;p&gt;I would like to say: &lt;/p&gt;</span><br></pre></td></tr></table></figure></p>\n<p>jQuery 代码:<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$(&quot;p&quot;).after( $(&quot;b&quot;) );</span><br></pre></td></tr></table></figure></p>\n<p>结果:<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;p&gt;I would like to say: &lt;/p&gt;&lt;b&gt;Hello&lt;/b&gt;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"insertAfter\"><a href=\"#insertAfter\" class=\"headerlink\" title=\"insertAfter()\"></a>insertAfter()</h2><p>描述:<br>把所有段落插入到一个元素之后。与 $(“#foo”).after(“p”)相同</p>\n<p>HTML 代码:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;p&gt;I would like to say: &lt;/p&gt;&lt;div id=&quot;foo&quot;&gt;Hello&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<p>jQuery 代码:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$(&quot;p&quot;).insertAfter(&quot;#foo&quot;);</span><br></pre></td></tr></table></figure>\n<p>结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;foo&quot;&gt;Hello&lt;/div&gt;&lt;p&gt;I would like to say: &lt;/p&gt;</span><br></pre></td></tr></table></figure>\n<h1 id=\"before-和-insertBefore\"><a href=\"#before-和-insertBefore\" class=\"headerlink\" title=\".before()和.insertBefore()\"></a>.before()和.insertBefore()</h1><h2 id=\"before\"><a href=\"#before\" class=\"headerlink\" title=\"before()\"></a>before()</h2><p>描述:<br>在所有段落中前插入一个jQuery对象(类似于一个DOM元素数组)。</p>\n<p>HTML 代码:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;p&gt;I would like to say: &lt;/p&gt;&lt;b&gt;Hello&lt;/b&gt;</span><br></pre></td></tr></table></figure>\n<p>jQuery 代码:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$(&quot;p&quot;).before( $(&quot;b&quot;) );</span><br></pre></td></tr></table></figure>\n<p>结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;b&gt;Hello&lt;/b&gt;&lt;p&gt;I would like to say: &lt;/p&gt;</span><br></pre></td></tr></table></figure>\n<h1 id=\"append-和-appendTo\"><a href=\"#append-和-appendTo\" class=\"headerlink\" title=\".append()和.appendTo()\"></a>.append()和.appendTo()</h1><h2 id=\"append\"><a href=\"#append\" class=\"headerlink\" title=\"append()\"></a>append()</h2><p>描述：向所有段落中追加一些HTML标记。</p>\n<p>HTML 代码:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;p&gt;I would like to say: &lt;/p&gt;</span><br></pre></td></tr></table></figure>\n<p>jQuery 代码:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$(&quot;p&quot;).append(&quot;&lt;b&gt;Hello&lt;/b&gt;&quot;);</span><br></pre></td></tr></table></figure>\n<p>结果:</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;p&gt;I would like to say: &lt;b&gt;Hello&lt;/b&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"appendTo\"><a href=\"#appendTo\" class=\"headerlink\" title=\"appendTo()\"></a>appendTo()</h2><p>描述：新建段落追加div中并加上一个class</p>\n<p>HTML 代码:<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>\n<p>jQuery 代码:<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$(&quot;&lt;p/&gt;&quot;)</span><br><span class=\"line\">    .appendTo(&quot;div&quot;)</span><br><span class=\"line\">    .addClass(&quot;test&quot;)</span><br><span class=\"line\">    .end()</span><br><span class=\"line\">    .addClass(&quot;test2&quot;);</span><br></pre></td></tr></table></figure></p>\n<p>结果:<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div&gt;&lt;p class=&quot;test test2&quot;&gt;&lt;/p&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;div&gt;&lt;p class=&quot;test&quot;&gt;&lt;/p&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"prepend-和-prependTo\"><a href=\"#prepend-和-prependTo\" class=\"headerlink\" title=\".prepend()和.prependTo()\"></a>.prepend()和.prependTo()</h1><h2 id=\"prepend\"><a href=\"#prepend\" class=\"headerlink\" title=\"prepend()\"></a>prepend()</h2><p>描述：向所有段落中前置一个jQuery对象(类似于一个DOM元素数组)。</p>\n<p>HTML 代码:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;p&gt;I would like to say: &lt;/p&gt;&lt;b&gt;Hello&lt;/b&gt;</span><br><span class=\"line\">`</span><br></pre></td></tr></table></figure>\n<p>jQuery 代码:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$(&quot;p&quot;).prepend( $(&quot;b&quot;) );</span><br></pre></td></tr></table></figure>\n<p>结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;p&gt;&lt;b&gt;Hello&lt;/b&gt;I would like to say: &lt;/p&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"prependTo\"><a href=\"#prependTo\" class=\"headerlink\" title=\"prependTo()\"></a>prependTo()</h2><p>描述：把所有段落追加到ID值为foo的元素中。</p>\n<p>HTML 代码:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;p&gt;I would like to say: &lt;/p&gt;&lt;div id=&quot;foo&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<p>jQuery 代码:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$(&quot;p&quot;).prependTo(&quot;#foo&quot;);</span><br></pre></td></tr></table></figure>\n<p>结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;foo&quot;&gt;&lt;p&gt;I would like to say: &lt;/p&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">1. .insertAfter()和.after()：在现存元素的外部，从后面插入元素  </span><br><span class=\"line\">2. .insertBefore()和.before()：在现存元素的外部，从前面插入元素  </span><br><span class=\"line\">3. .appendTo()和.append()：在现存元素的内部，从后面插入元素  </span><br><span class=\"line\">4. .prependTo()和.prepend()  ：在现存元素的内部，从前面插入元素</span><br></pre></td></tr></table></figure>\n<h1 id=\"data-key-value\"><a href=\"#data-key-value\" class=\"headerlink\" title=\".data( key, value )\"></a>.data( key, value )</h1><p><code>.data()</code>方法允许我们在DOM元素上绑定任意类型的数据,</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$(&quot;div&quot;).data(&quot;test&quot;, &#123; first: 16, last: &quot;pizza!&quot; &#125;);</span><br></pre></td></tr></table></figure>\n<h1 id=\"promise-type-target\"><a href=\"#promise-type-target\" class=\"headerlink\" title=\".promise( [type ] [, target ] )\"></a>.promise( [type ] [, target ] )</h1><p>在 <code>Javascript</code> 中，有外一种异步处理模式被叫做 <code>Promises</code>， <code>CommonJS</code> 标准委员会于是发布了一个规范，就把这个 <code>API</code> 叫做 <code>Promises</code> 了。</p>\n<p><code>Promise</code> 背后的概念非常简单，有两部分:</p>\n<p><code>Deferreds</code>，定义工作单元，<br><code>Promises</code>，从 <code>Deferreds</code> 返回的数据。<br><code>Promise</code> 不同于回调的很重要的一个点是，你可以在 <code>Promise</code> 状态变成执行(<code>resolved</code>)之后追加处理句柄。这就允许你传输数据，而忽略它是否已经被应用获取，然后缓存它，等等之类的操作，因此你可以对数据执行操作，而不管它是否已经或者即将可用。</p>\n<p>你可以给一个 <code>promise</code> 追加多个处理(<code>then()</code>)。<code>Promise API</code> 好玩的地方在于允许链式处理:<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!-- lang: js --&gt;</span><br><span class=\"line\">promise</span><br><span class=\"line\">    .then(doSomething)</span><br><span class=\"line\">    .then(doSomethingElse)</span><br><span class=\"line\">    .then(doSomethingMore)</span><br><span class=\"line\">    .catch(logError);</span><br></pre></td></tr></table></figure></p>\n<p>  <em>原文见</em>：<a href=\"http://segmentfault.com/a/1190000000660257\" target=\"_blank\" rel=\"noopener\">trigkit4</a></p>\n","categories":["前端积累"],"tags":["web前端","jQuery"]},{"title":"XMLHttpRequest学习笔记","url":"http://dearxiaojie.top/article/2015-05-29-XMLHttpRequest学习笔记.html","content":"<p>对于xhr的学习后的一个例子<br><a id=\"more\"></a><br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">&lt;title&gt;first&lt;/title&gt;</span><br><span class=\"line\">&lt;link rel=&quot;stylesheet&quot; href=&quot;css/bootstrap.min.css&quot; /&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;button id=&quot;btn&quot;&gt;请求数据&lt;/button&gt;</span><br><span class=\"line\">    &lt;div id=&quot;myDiv&quot;&gt;</span><br><span class=\"line\">        &lt;table class=&quot;table table-bordered table-condensed&quot;&gt;</span><br><span class=\"line\">            &lt;thead&gt;</span><br><span class=\"line\">                &lt;tr&gt;</span><br><span class=\"line\">                    &lt;th&gt;number&lt;/th&gt;</span><br><span class=\"line\">                    &lt;th&gt;title&lt;/th&gt;</span><br><span class=\"line\">                    &lt;th&gt;author&lt;/th&gt;</span><br><span class=\"line\">                    &lt;th&gt;year&lt;/th&gt;</span><br><span class=\"line\">                    &lt;th&gt;price&lt;/th&gt;</span><br><span class=\"line\">                &lt;/tr&gt;</span><br><span class=\"line\">            &lt;/thead&gt;</span><br><span class=\"line\">            &lt;tbody id=&quot;mytbody&quot;&gt;&lt;/tbody&gt;</span><br><span class=\"line\">        &lt;/table&gt;</span><br><span class=\"line\">        &lt;p&gt;getAllResponseHeaders()&lt;/p&gt;</span><br><span class=\"line\">        &lt;p id=&quot;pp&quot;&gt;&lt;/p&gt;</span><br><span class=\"line\">        &lt;p&gt;getResponseHeader(&quot;Last-Modified&quot;)&lt;/p&gt;</span><br><span class=\"line\">        &lt;p id=&quot;ppp&quot;&gt;&lt;/p&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">    &lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-1.7.2.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">    &lt;script type=&quot;text/javascript&quot; src=&quot;js/bootstrap.min.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">    &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class=\"line\">        function loadXHR() &#123;</span><br><span class=\"line\">            var XHR;</span><br><span class=\"line\">            if (window.XMLHttpRequest) &#123;</span><br><span class=\"line\">                XHR = new XMLHttpRequest();</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                XHR = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            XHR.open(&quot;GET&quot;, &quot;./text/books.xml&quot;, true);</span><br><span class=\"line\">            //通过 XML HTTP 加载 XML 文件</span><br><span class=\"line\">            XHR.send();</span><br><span class=\"line\">            XHR.onreadystatechange = function() &#123;</span><br><span class=\"line\">                if (XHR.readyState == 4 &amp;&amp; XHR.status == 200) &#123;</span><br><span class=\"line\">                // 4 = &quot;loaded&quot; 200 = “OK”</span><br><span class=\"line\">                    var xmlDoc = XHR.responseXML;</span><br><span class=\"line\">                    var txt = &quot;&lt;tr&gt;&quot;;</span><br><span class=\"line\">                    var x = xmlDoc.getElementsByTagName(&quot;book&quot;);</span><br><span class=\"line\">                    for (var i = 0; i &lt; x.length; i++) &#123;</span><br><span class=\"line\">                    //把 XML 文件显示为 HTML 表格</span><br><span class=\"line\">                        txt += &quot;&lt;td&gt;&quot; + i + &quot;&lt;/td&gt;&quot;;</span><br><span class=\"line\">                        xx = x[i].getElementsByTagName(&quot;title&quot;);</span><br><span class=\"line\">                        txt += &quot;&lt;td&gt;&quot; + xx[0].childNodes[0].nodeValue + &quot;&lt;/td&gt;&quot;;</span><br><span class=\"line\">                        xx = x[i].getElementsByTagName(&quot;author&quot;);</span><br><span class=\"line\">                        txt += &quot;&lt;td&gt;&quot; + xx[0].childNodes[0].nodeValue + &quot;&lt;/td&gt;&quot;;</span><br><span class=\"line\">                        xx = x[i].getElementsByTagName(&quot;year&quot;);</span><br><span class=\"line\">                        txt += &quot;&lt;td&gt;&quot; + xx[0].childNodes[0].nodeValue + &quot;&lt;/td&gt;&quot;;</span><br><span class=\"line\">                        xx = x[i].getElementsByTagName(&quot;price&quot;);</span><br><span class=\"line\">                        txt += &quot;&lt;td&gt;&quot; + xx[0].childNodes[0].nodeValue</span><br><span class=\"line\">                                + &quot;&lt;/td&gt;&lt;/tr&gt;&quot;;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    document.getElementById(&quot;mytbody&quot;).innerHTML = txt;</span><br><span class=\"line\">                    //通过 XML HTTP 进行一次 HEAD 请求</span><br><span class=\"line\">                    document.getElementById(&quot;pp&quot;).innerHTML = XHR.getAllResponseHeaders();</span><br><span class=\"line\">                    //通过 XML HTTP 进行一次指定的 HEAD 请求</span><br><span class=\"line\">                    document.getElementById(&quot;ppp&quot;).innerHTML = XHR.getResponseHeader(&quot;Last-Modified&quot;);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        document.getElementById(&quot;btn&quot;).onclick = function() &#123;</span><br><span class=\"line\">            loadXHR();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br><span class=\"line\">//books.xml</span><br><span class=\"line\">    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class=\"line\">&lt;bookstore&gt;</span><br><span class=\"line\">\t&lt;book category=&quot;children&quot;&gt;</span><br><span class=\"line\">\t\t&lt;title lang=&quot;en&quot;&gt;Harry Potter&lt;/title&gt;</span><br><span class=\"line\">\t\t&lt;author&gt;J K. Rowling&lt;/author&gt;</span><br><span class=\"line\">\t\t&lt;year&gt;2005&lt;/year&gt;</span><br><span class=\"line\">\t\t&lt;price&gt;29.99&lt;/price&gt;</span><br><span class=\"line\">\t&lt;/book&gt;</span><br><span class=\"line\">\t&lt;book category=&quot;cooking&quot;&gt;</span><br><span class=\"line\">\t\t&lt;title lang=&quot;en&quot;&gt;Everyday Italian&lt;/title&gt;</span><br><span class=\"line\">\t\t&lt;author&gt;Giada De Laurentiis&lt;/author&gt;</span><br><span class=\"line\">\t\t&lt;year&gt;2005&lt;/year&gt;</span><br><span class=\"line\">\t\t&lt;price&gt;30.00&lt;/price&gt;</span><br><span class=\"line\">\t&lt;/book&gt;</span><br><span class=\"line\">\t&lt;book category=&quot;web&quot; cover=&quot;paperback&quot;&gt;</span><br><span class=\"line\">\t\t&lt;title lang=&quot;en&quot;&gt;Learning XML&lt;/title&gt;</span><br><span class=\"line\">\t\t&lt;author&gt;Erik T. Ray&lt;/author&gt;</span><br><span class=\"line\">\t\t&lt;year&gt;2003&lt;/year&gt;</span><br><span class=\"line\">\t\t&lt;price&gt;39.95&lt;/price&gt;</span><br><span class=\"line\">\t&lt;/book&gt;</span><br><span class=\"line\">\t&lt;book category=&quot;web&quot;&gt;</span><br><span class=\"line\">\t\t&lt;title lang=&quot;en&quot;&gt;XQuery Kick Start&lt;/title&gt;</span><br><span class=\"line\">\t\t&lt;author&gt;James McGovern&lt;/author&gt;</span><br><span class=\"line\">\t\t&lt;author&gt;Per Bothner&lt;/author&gt;</span><br><span class=\"line\">\t\t&lt;author&gt;Kurt Cagle&lt;/author&gt;</span><br><span class=\"line\">\t\t&lt;author&gt;James Linn&lt;/author&gt;</span><br><span class=\"line\">\t\t&lt;author&gt;Vaidyanathan Nagarajan&lt;/author&gt;</span><br><span class=\"line\">\t\t&lt;year&gt;2003&lt;/year&gt;</span><br><span class=\"line\">\t\t&lt;price&gt;49.99&lt;/price&gt;</span><br><span class=\"line\">\t&lt;/book&gt;</span><br><span class=\"line\">&lt;/bookstore&gt;</span><br></pre></td></tr></table></figure></p>\n","categories":["学习笔记"],"tags":["XMLHttpRequest"]},{"title":"web前端笔试练习","url":"http://dearxiaojie.top/article/2015-05-28-web前端笔试练习.html","content":"<blockquote>\n<p>1.将一个32位十进制数组转化成2进制后，翻转这个2进制数，再转换成十进制数<br><a id=\"more\"></a><br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//res1</span><br><span class=\"line\">function reverseB(num) &#123;</span><br><span class=\"line\">  var bits = num.toString(2);</span><br><span class=\"line\">  var len = 32 - bits.length;</span><br><span class=\"line\">  bits = bits.split(&quot;&quot;).reverse().join(&quot;&quot;);</span><br><span class=\"line\">  while(len--) &#123;</span><br><span class=\"line\">  \tbits+=&quot;0&quot;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  \treturn parseInt(bits,2);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(reverseB(43261596));//964176192  </span><br><span class=\"line\">  //res2</span><br><span class=\"line\">function reverseBs(n)&#123;</span><br><span class=\"line\">  var m = 0;</span><br><span class=\"line\">  for (var i = 0; i &lt; 31; i++) &#123;</span><br><span class=\"line\">    m|=(n&amp;1);</span><br><span class=\"line\">    n &gt;&gt;= 1;</span><br><span class=\"line\">    m &lt;&lt;= 1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">    m|=(n&amp;01);</span><br><span class=\"line\">    return m;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">console.log(reverseBs(43261596));//964176192</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<!--more-->\n<blockquote>\n<p>2.罗马数组转换成十进制数字</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var romObj = &#123;I:1, V:5, X:10, L:50, C:100, D:500, M:1000&#125;;</span><br><span class=\"line\">var romanToInt = function(str) &#123;</span><br><span class=\"line\">    var sum = 0;</span><br><span class=\"line\">    for(var i = 0; i &lt; str.length; i++) &#123;</span><br><span class=\"line\">        rom1 = romObj[str.substring(i,i+1)];</span><br><span class=\"line\">        rom2 = romObj[str.substring(i+1,i+2)];</span><br><span class=\"line\">        if(str.substring(i+1,i+2) !== &quot;&quot; &amp;&amp; rom1 &lt; rom2) &#123;</span><br><span class=\"line\">            sum += rom2 - rom1;</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">        &#125; else</span><br><span class=\"line\">            sum += rom1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return sum;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">console.log(romanToInt(&apos;II&apos;));</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>3.总共有n阶楼梯，每次只能上一步或者两部，要到达楼上有多少种方式<br>分析，当列举了当n为1,2,3,4,5时得出有1,2,3,5,8种方式<br>就是一个斐波拉契数列</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var climbStairs = function(n) &#123;</span><br><span class=\"line\">    var a = 1,</span><br><span class=\"line\">        b = 2,</span><br><span class=\"line\">        sum = 1;</span><br><span class=\"line\">        if(n == 1) return a;</span><br><span class=\"line\">        if(n == 2) return b;</span><br><span class=\"line\">        n -= 2;</span><br><span class=\"line\">    while(n--)&#123;</span><br><span class=\"line\">        sum = a + b;</span><br><span class=\"line\">        a = b;</span><br><span class=\"line\">        b = sum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return sum;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">console.log(climbStairs(3));</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>4.给数组增加一种方法，可以去除数组中的重复项并返回数组</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//fun1--hash</span><br><span class=\"line\">Array.prototype.delWeight = function()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    var n=[],r=[]; //n为hash表，r为临时数组</span><br><span class=\"line\">    for(var i = 0; i &lt; this.length; i++) //遍历当前数组</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (!n[this[i]]) //如果hash表中没有当前项</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            n[this[i]] = true; //存入hash表</span><br><span class=\"line\">            r.push(this[i]); //把当前数组的当前项push到临时数组里面</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return r;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var arr = [1,1,1,1,1,2,2,33,4,5,6,5,6];</span><br><span class=\"line\">console.log(arr.delWeight());</span><br><span class=\"line\">//fun2--利用数组的indexOf方法</span><br><span class=\"line\">function delWeight (arr) &#123;</span><br><span class=\"line\">    var result = [];</span><br><span class=\"line\">    for (var i = 0; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">        if (result.indexOf(arr[i]) == -1) result.push(arr[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>5.对不确定数量的数进行排序</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function mySort() &#123;</span><br><span class=\"line\">    var tags = new Array();//使用数组作为参数存储容器</span><br><span class=\"line\">    for(var i = 0,len = arguments.length;i&lt;len;i++)&#123;</span><br><span class=\"line\">        tags.push(arguments[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    tags.sort(function(a,b)&#123;</span><br><span class=\"line\">        return a - b;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    return tags;//返回已经排序的数组</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var result = mySort(50,11,16,32,24,99,57,100);//传入参数个数不确定</span><br><span class=\"line\">console.info(result);//显示结果</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>6.用短路求值的方式求前n项和</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function sumr(n) &#123;</span><br><span class=\"line\">    var ans = n;</span><br><span class=\"line\">    ans &amp;&amp; (ans += sumr(n-1));</span><br><span class=\"line\">    return ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(sumr(5));</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>7.正则表达式判断一个数是不是素数</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function is_prime(x)&#123;</span><br><span class=\"line\">     var r=[],s=&quot;&quot;;</span><br><span class=\"line\">     while(r.length&lt;x)&#123;</span><br><span class=\"line\">         r.push(&quot;1&quot;);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     s=r.join(&quot;&quot;);</span><br><span class=\"line\">     return !/^1?$|^(11+?)\\1+$/.test(s);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(is_prime(5));</span><br><span class=\"line\">console.log(is_prime(10));</span><br><span class=\"line\">console.log(is_prime(13));</span><br><span class=\"line\">console.log(is_prime(60));</span><br><span class=\"line\">console.log(is_prime(99));</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>8.辗转相除求最大公约数</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function ff(a,b)&#123;</span><br><span class=\"line\">    if (b&gt;a) ff(b,a);</span><br><span class=\"line\">    return !(a%b)?b:ff(b,a%b);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(ff(10,3));</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>9.Json数据按照某一字段排序的方法</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var stuJson = [&#123; name: &quot;daming&quot;, age: 21, weight: 66, sex:&quot;boy&quot; &#125;,</span><br><span class=\"line\">                   &#123; name: &quot;lisa&quot;, age: 19, weight: 45, sex:&quot;girl&quot; &#125;,</span><br><span class=\"line\">                   &#123; name: &quot;lili&quot;, age: 20, weight: 50, sex:&quot;boy&quot;&#125;];</span><br><span class=\"line\">     //按age升序</span><br><span class=\"line\">   stuJson.sort(function(a,b)&#123;</span><br><span class=\"line\">                    return a.age - b.age;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">console.log(stuJson);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>10.求一个数组中的最大最小值</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var arr = [32,42,12,42,21,23,56,75,3,33,53,23,36];</span><br><span class=\"line\">var min =   Math.min.apply(null,arr);</span><br><span class=\"line\">   console.log(min);</span><br><span class=\"line\">var aMax = Math.max.apply(null,arr);</span><br><span class=\"line\">   console.log(aMax);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>11.将一个匿名函数作为函数的一个参数</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">  function map(f,a) &#123;</span><br><span class=\"line\">  var result = [], // Create a new Array</span><br><span class=\"line\">      i;</span><br><span class=\"line\">  for (i = 0; i != a.length; i++)</span><br><span class=\"line\">    result[i] = f(a[i]);</span><br><span class=\"line\">  return result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">   //调用的时候实现这个引用参数函数</span><br><span class=\"line\">  var re = map(function(x) &#123;return x * x * x&#125;, [0, 1, 2, 5, 10]);</span><br><span class=\"line\">  console.log(re);//[0, 1, 8, 125, 1000].</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>12.字符传中的大小写相互转换</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function upperToggleLower(str)&#123;</span><br><span class=\"line\">  var s =&quot;&quot;;</span><br><span class=\"line\">  for(var i = 0,len = str.length;i&lt;len;i++)&#123;</span><br><span class=\"line\">    if (str[i]&lt;=&apos;z&apos;&amp;&amp;str[i]&gt;=&apos;a&apos;||str[i]&lt;=&apos;Z&apos;&amp;&amp;str[i]&gt;=&apos;A&apos;) &#123;</span><br><span class=\"line\">      s+=String.fromCharCode(str.charCodeAt(i)^32);</span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">      s+=str[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return s;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var str = &apos;abcdef FEDCBA&apos; ;</span><br><span class=\"line\">console.log(upperToggleLower(str));//&quot;ABCDEF fedcba&quot;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>13.js快排</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function quick_sort(array,l,r)&#123;</span><br><span class=\"line\">  if(l &lt; r)&#123;</span><br><span class=\"line\">    var i = l,j = r,x = array[l];</span><br><span class=\"line\">    while(i &lt; j)&#123;</span><br><span class=\"line\">      while(i &lt; j &amp;&amp; array[j]&gt;=x)&#123;</span><br><span class=\"line\">        j--;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      if(i &lt; j)&#123;</span><br><span class=\"line\">        array[i++] = array[j];</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      while(i &lt; j &amp;&amp; array[i] &lt; x)&#123;</span><br><span class=\"line\">        i++;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      if(i &lt; j)&#123;</span><br><span class=\"line\">        array[j--] = array[i];</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    array[i] = x;</span><br><span class=\"line\">    quick_sort(array,l,i -1 );</span><br><span class=\"line\">    quick_sort(array,i + 1,r);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return array;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>14.给出2*n + 1 个的数字，除其中一个数字之外其他每个数字均出现两次，找到这个数字</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\"> * @param A: Array of integers.</span><br><span class=\"line\"> * @return: The single number.</span><br><span class=\"line\"> */</span><br><span class=\"line\">int singleNumber(vector&lt;int&gt; &amp;A) &#123;</span><br><span class=\"line\">    if (!A.size()) return 0;</span><br><span class=\"line\">    int a = A[0];</span><br><span class=\"line\">    for(int i = 1;i&lt;A.size();i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        a^=A[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return a;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>15.给出两个整数a和b, 求他们的和, 但不能使用 + 等数学运算符。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\"> * @param a: The first integer</span><br><span class=\"line\"> * @param b: The second integer</span><br><span class=\"line\"> * @return: The sum of a and b</span><br><span class=\"line\"> */</span><br><span class=\"line\">    int aplusb(int a, int b) &#123;</span><br><span class=\"line\">        int n1;</span><br><span class=\"line\">        do&#123;</span><br><span class=\"line\">            n1 = a ^ b;</span><br><span class=\"line\">            b = (a &amp; b) &lt;&lt; 1;</span><br><span class=\"line\">            a = n1;</span><br><span class=\"line\">        &#125;while(b != 0);</span><br><span class=\"line\">        return n1;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>16.计算在一个 32 位的整数的二进制表式中有多少个 1.</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\"> * @param num: an integer</span><br><span class=\"line\"> * @return: an integer, the number of ones in num</span><br><span class=\"line\"> */</span><br><span class=\"line\">  int countOnes(int num) &#123;</span><br><span class=\"line\">        int count = 0;</span><br><span class=\"line\">        while(num!=0)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">             num = num&amp;(num-1);</span><br><span class=\"line\">             count++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return count;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>17.找到单链表倒数第n个节点，保证链表中节点的最少数量为n。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Definition of ListNode</span><br><span class=\"line\"> * class ListNode &#123;</span><br><span class=\"line\"> * public:</span><br><span class=\"line\"> *     int val;</span><br><span class=\"line\"> *     ListNode *next;</span><br><span class=\"line\"> *     ListNode(int val) &#123;</span><br><span class=\"line\"> *         this-&gt;val = val;</span><br><span class=\"line\"> *         this-&gt;next = NULL;</span><br><span class=\"line\"> *     &#125;</span><br><span class=\"line\"> * &#125;</span><br><span class=\"line\"> * @param head: The first node of linked list.</span><br><span class=\"line\"> * @param n: An integer.</span><br><span class=\"line\"> * @return: Nth to last node of a singly linked list.</span><br><span class=\"line\"> */</span><br><span class=\"line\">    ListNode *nthToLast(ListNode *head, int n) &#123;</span><br><span class=\"line\">        if (!head) return NULL;</span><br><span class=\"line\">        ListNode *h,*d;</span><br><span class=\"line\">        h = d = head;</span><br><span class=\"line\">        while(--n)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            h = h-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        while(h-&gt;next!=NULL)&#123;</span><br><span class=\"line\">            h = h-&gt;next;</span><br><span class=\"line\">            d = d-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return d;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>18.写出一个高效的算法来搜索 m × n矩阵中的值。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 这个矩阵具有以下特性：</span><br><span class=\"line\"> * 1.每行中的整数从左到右是排序的。</span><br><span class=\"line\"> * 2.每行的第一个数大于上一行的最后一个整数。</span><br><span class=\"line\"> * @param matrix, a list of lists of integers</span><br><span class=\"line\"> * @param target, an integer</span><br><span class=\"line\"> * @return a boolean, indicate whether matrix contains target</span><br><span class=\"line\"> */</span><br><span class=\"line\">    bool searchMatrix(vector&lt;vector&lt;int&gt; &gt; &amp;matrix, int target) &#123;</span><br><span class=\"line\">        if(!matrix.size()) return false;</span><br><span class=\"line\">        int i,j;</span><br><span class=\"line\">        for(i = 0; i &lt; matrix.size(); i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            if(target &lt; matrix[i][0])</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            if(target == matrix[i][0])</span><br><span class=\"line\">                return true;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        i--;</span><br><span class=\"line\">        for(j = 0;j &lt; matrix[i].size();j++)</span><br><span class=\"line\">            if(target == matrix[i][j]) return true;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>19.设计一种方法，将一个字符串中的所有空格替换成 %20 。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 你可以假设该字符串有足够的空间来加入新的字符，且你得到的是“真实的”字符长度</span><br><span class=\"line\"> * @param string: An array of Char</span><br><span class=\"line\"> * @param length: The true length of the string</span><br><span class=\"line\"> * @return: The true length of new string</span><br><span class=\"line\"> */</span><br><span class=\"line\">    int replaceBlank(char string[], int length) &#123;</span><br><span class=\"line\">        // Write your code here</span><br><span class=\"line\">      int space_cnt = 0;</span><br><span class=\"line\">      int new_length = 0;</span><br><span class=\"line\">      char *p,*q;</span><br><span class=\"line\">      for(int i = 0; i &lt; length; i++)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        if (string[i] == &apos; &apos;) space_cnt++;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      new_length = space_cnt * 2 +length;</span><br><span class=\"line\">      p = string + (length - 1);</span><br><span class=\"line\">      q = string + (new_length - 1);</span><br><span class=\"line\">      while(p != q)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        if(*p == &apos; &apos;) *q = &apos;0&apos;,q--,*q = &apos;2&apos;,q--,*q = &apos;%&apos;;</span><br><span class=\"line\">        else *q = *p;</span><br><span class=\"line\">        p--;</span><br><span class=\"line\">        q--;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      return new_length;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>20.统计一个字符串中每个单词的个数</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> *@param &#123;string&#125; str 输入的字符串</span><br><span class=\"line\"> *@return &#123;Object&#125; o 单词及对应数量</span><br><span class=\"line\"> */</span><br><span class=\"line\">function countWordNum(str) &#123;</span><br><span class=\"line\">    if (!str) return ;</span><br><span class=\"line\">    var wordsArr = str.split(&apos; &apos;);</span><br><span class=\"line\">    var o = &#123;&#125;;</span><br><span class=\"line\">    for (var i = 0, len = wordsArr.length; i &lt; len; i++)&#123;</span><br><span class=\"line\">        if (wordsArr[i] in o) &#123; //or if (o[wordsArr[i]]) &#123;   or if (o.hasOwnProperty(wordsArr[i])) &#123;</span><br><span class=\"line\">            o[wordsArr[i]]++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else &#123;</span><br><span class=\"line\">          o[wordsArr[i]] = 1;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return o;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>21.给你六种面额 1、5、10、20、50、100 元的纸币，假设每种币值的数量都足够多，编写程序求组成N元（N为0~10000的非负整数）的不同组合的个数</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">public class changeDP &#123;</span><br><span class=\"line\">  static int v [] = &#123;1, 5, 10, 20, 50, 100&#125;;</span><br><span class=\"line\">  public static int change (int n, int i)&#123;</span><br><span class=\"line\">    if (n &lt; 0) return 0;</span><br><span class=\"line\">    if (n == 0) return 1;</span><br><span class=\"line\">    if (i &lt; 0) return 0;</span><br><span class=\"line\">    return change(n,i-1)+change(n-v[i],i);    </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  public static void main (String[] args)&#123;</span><br><span class=\"line\">    System.out.println(change(100,v.length-1));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>22.给定非空整型数组 arr 和整数 limit ，两次从 arr 中随机抽取元素（可能抽到同一个元素），获得整数 x ,y ，得到和 s = x + y 。求所有不超过 limit 的 s 值中的最大数。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function limitedMaxSum(arr, limit) &#123;</span><br><span class=\"line\">    var max = 0;</span><br><span class=\"line\">    for (var i = 0, len = arr.length; i &lt; len; i++) &#123;</span><br><span class=\"line\">        for(var j = 0; j &lt; len; j++) &#123;</span><br><span class=\"line\">            var sum = arr[i] + arr[j];</span><br><span class=\"line\">            if (sum &lt;= limit &amp;&amp; sum &gt;= max) &#123;</span><br><span class=\"line\">                max = sum;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return max;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><em>持续更新ing…</em></p>\n","categories":["笔试&面试"],"tags":["web前端","笔试"]},{"title":"CSS选择器","url":"http://dearxiaojie.top/article/2015-05-26-CSS选择器.html","content":"<h2 id=\"层次选择器\"><a href=\"#层次选择器\" class=\"headerlink\" title=\"层次选择器\"></a>层次选择器</h2><ul>\n<li><code>$(&quot;body &gt; div&quot;)</code>   body中子元素中的div</li>\n<li><code>$(&quot;#one + div&quot;)</code>   id为one的下一个紧挨着的div(兄弟)</li>\n<li><code>$(&quot;#two ~ div&quot;)</code>   id为two的后面的所有div(兄弟)<a id=\"more\"></a>\n拓展</li>\n<li><code>$(&quot;#one&quot;).sibling(&quot;div&quot;)</code>  id为one的所有div兄弟元素</li>\n<li><code>$(&quot;#one&quot;).nextAll(&quot;span&quot;)</code>  id为one的后面所有span元素</li>\n<li><code>$(&quot;#one&quot;).prevAll(&quot;div&quot;)</code>  id为one的前面的所有的div</li>\n<li><code>$(&quot;#one&quot;).nextAll(&quot;span:first&quot;)</code>  id为one的后面所有span元素的第一个</li>\n</ul>\n<h2 id=\"过滤选择器：以”-”开头\"><a href=\"#过滤选择器：以”-”开头\" class=\"headerlink\" title=\"过滤选择器：以”:”开头\"></a>过滤选择器：以”:”开头</h2><ul>\n<li><code>$(&quot;div:first&quot;)</code> 第一个div</li>\n<li><code>$(&quot;div:last&quot;)</code>   最后一个div</li>\n<li><code>$(&quot;div:not(.one)&quot;)</code>  class不为one的div</li>\n<li><code>$(&quot;div:even&quot;)</code> 索引值偶数div</li>\n<li><code>$(&quot;div:odd&quot;)</code>   索引值奇数div</li>\n<li><code>$(&quot;div:gt(3)&quot;)</code>   索引值大于3的div</li>\n<li><code>$(&quot;div:eq(3)&quot;)</code>   索引值等于3的div</li>\n<li><code>$(&quot;div:lt(3)&quot;)</code>   索引值小于3的div</li>\n<li><code>$(&quot;li:gt(1):lt(4)&quot;)</code>  不是第2个到第5个，而是在第二个的基础上增加4</li>\n<li><code>$(&quot;:header&quot;)</code>  所有的标题元素</li>\n<li><code>$(&quot;:animated&quot;)</code> 正在执行动画的所有元素</li>\n</ul>\n<h2 id=\"内容过滤选择器\"><a href=\"#内容过滤选择器\" class=\"headerlink\" title=\"内容过滤选择器\"></a>内容过滤选择器</h2><ul>\n<li><code>$(&quot;div:contains(&#39;ss&#39;)&quot;)</code>   文本含有ss的div元素</li>\n<li><code>$(&quot;div:empty&quot;)</code>   文本为空的div元素</li>\n<li><code>$(&quot;div:has(.mini)&quot;)</code>  含有class为mini的所有div元素</li>\n<li><code>$(div:parent)或者$(&quot;div:not(:empty)&quot;)</code> 所有非空的div元素</li>\n</ul>\n<h2 id=\"可见性过滤选择器\"><a href=\"#可见性过滤选择器\" class=\"headerlink\" title=\"可见性过滤选择器\"></a>可见性过滤选择器</h2><ul>\n<li><code>$(&quot;div:visible&quot;)</code> 所有可见的div</li>\n<li><code>$(&quot;div:hidden&quot;).show(time)</code>  所有不可见的div元素显示，time为时间，单位为毫秒</li>\n<li><code>$(&quot;input:hidden&quot;).val()</code>   所有不可见的input元素的value</li>\n</ul>\n<h2 id=\"属性过滤选择器\"><a href=\"#属性过滤选择器\" class=\"headerlink\" title=\"属性过滤选择器\"></a>属性过滤选择器</h2><ul>\n<li><code>$(&quot;div:[title]&quot;)</code>  含有属性title的div元素</li>\n<li><code>$(&quot;div:[title==&#39;test&#39;]&quot;)</code> title属性等于test的div元素</li>\n<li><code>$(&quot;div:[title!=&#39;test&#39;]&quot;)</code> title属性不等于test的div元素，包括没有title属性的元素</li>\n<li><code>$(&quot;div:[title^=&#39;te&#39;]&quot;)</code>  title属性以te开始的div元素</li>\n<li><code>$(&quot;div:[title$=&#39;est&#39;]&quot;)</code>  title属性以est结束的div元素</li>\n<li><code>$(&quot;div:[title*=&#39;es&#39;]&quot;)</code>   title属性值含有es的div元素</li>\n<li><code>$(&quot;div:[id][title*=&#39;es&#39;]&quot;)</code>  有id属性的div元素中的title属性值中含有es的div元素</li>\n<li><code>$(&quot;div:[title][title!=&#39;test&#39;]&quot;)</code>  含有title属性，且title属性值不为test的div元素</li>\n</ul>\n<h2 id=\"子元素过滤选择器（冒号前面有个空格，选取子元素需要在选取器前加空格）\"><a href=\"#子元素过滤选择器（冒号前面有个空格，选取子元素需要在选取器前加空格）\" class=\"headerlink\" title=\"子元素过滤选择器（冒号前面有个空格，选取子元素需要在选取器前加空格）\"></a>子元素过滤选择器（冒号前面有个空格，选取子元素需要在选取器前加空格）</h2><ul>\n<li><code>$(&quot;.one :nth-child(2)&quot;)</code>  class为one的第二个子元素，不是索引值为2</li>\n<li><code>$(&quot;.one :first-child&quot;)</code>   class为one的第一个子元素</li>\n<li><code>$(&quot;.one :last-child&quot;)</code>    class为one的最后一个子元素</li>\n<li><code>$(&quot;.one :only-child&quot;)</code>    class为one的只有一个节点的节点元素</li>\n<li><code>$(&quot;div.one :nth-child(2)&quot;)</code>   class为one的第二个div子元素</li>\n</ul>\n<h2 id=\"表单对象属性过滤选择器\"><a href=\"#表单对象属性过滤选择器\" class=\"headerlink\" title=\"表单对象属性过滤选择器\"></a>表单对象属性过滤选择器</h2><ul>\n<li><code>$(&quot;:text:enabled&quot;).val(&quot;hello&quot;)</code>  使所有可用的单行文本框的value值变为hello</li>\n<li><code>$(&quot;:text:disabled&quot;).val(&quot;hello&quot;)</code>   设置所有不可用单行文本框value值为hello</li>\n<li><code>$(&quot;:checkbox[name=&#39;haha&#39;]:checked&quot;).length</code>    多选框name为haha的被选中的个数</li>\n<li><code>$(&quot;select :selected&quot;).length</code>   select的option子节点，冒号前加空格，下拉选择框的选中的长度</li>\n<li><code>$(&quot;select :selected&quot;).val()</code>   因为$(“select :selected”)选中的是一个数组，当有多个元素时，.val()获取的是第一个选中的值。</li>\n</ul>\n","categories":["学习笔记"],"tags":["CSS"]},{"title":"2015阿里web前端笔试题（部分）","url":"http://dearxiaojie.top/article/2015-05-25-2015阿里web前端笔试题（部分）.html","content":"<blockquote>\n<p>1.给定一个随机数组，数组可能包含数组（也就是说数组元素可能为数组）。要求用js实现一个函数，返回该数组中所有元素。例如，例如：数组[2,3,[4,6,[1,8]],12,10]，返回结果为：[2,3,4,6,1,8,12,10]</p>\n</blockquote>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getArray</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> arrs = [];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>,l=arr.length;i &lt; l;i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!<span class=\"built_in\">Array</span>.isArray(arr[i])) arrs.push(arr[i]);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> arrs = arrs.concat( getArray(arr[i]) );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arrs;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<blockquote>\n<p>2.用js实现随机选取10–100之间的不同的10个数字，存入一个数组，并降序排序</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">    var aArray = [];</span><br><span class=\"line\">    var i = 0;</span><br><span class=\"line\">    for (i = 0; i &lt; 10; i++) &#123;</span><br><span class=\"line\">      randomNub();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    aArray.sort(function (a, b) &#123;</span><br><span class=\"line\">       return b - a</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    document.write(aArray)</span><br><span class=\"line\">    function randomNub() &#123;</span><br><span class=\"line\">      var nowNub = parseInt(Math.random() * 100);</span><br><span class=\"line\">      if (nowNub &lt; 10) &#123;</span><br><span class=\"line\">        randomNub();</span><br><span class=\"line\">        return;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      for (var j = 0; j &lt; aArray.length; j++) &#123;</span><br><span class=\"line\">        if (nowNub == aArray[j]) &#123;</span><br><span class=\"line\">          randomNub();</span><br><span class=\"line\">          return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      aArray.push(nowNub);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>3.下面代码希望在点击每段内容的时候给它加个灰色背景，可是下面这段代码好像没有满足需求，请帮忙修改下。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">for (var i = 0; i &lt; document.getElementsByTagName(&apos;p&apos;).length; i++) &#123;</span><br><span class=\"line\">  var item = document.getElementsByTagName(&apos;p&apos;) [i];</span><br><span class=\"line\">  (function (j) &#123;</span><br><span class=\"line\">    document.getElementsByTagName(&apos;p&apos;) [i].onclick = function () &#123;</span><br><span class=\"line\">      item.style.backgroundColor = &apos;#eee&apos;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;(i))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//修改后</span><br><span class=\"line\">for (var i = 0; i &lt; document.getElementsByTagName(&apos;p&apos;).length; i++) &#123;</span><br><span class=\"line\">  var item = document.getElementsByTagName(&apos;p&apos;) [i];</span><br><span class=\"line\">  (function (j) &#123;</span><br><span class=\"line\">    document.getElementsByTagName(&apos;p&apos;) [i].onclick = function () &#123;</span><br><span class=\"line\">      this.style.backgroundColor = &apos;#eee&apos;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;(i))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>4.为字符串实现一个render方法，实现下面的变量替换功能</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"> var greeting = &apos;my name is $&#123;name&#125;, age $&#123;age&#125;&apos;;</span><br><span class=\"line\"> var result = greeting.render(&#123;name: &apos;XiaoMing&apos;, age: 11&#125;);</span><br><span class=\"line\"> console.log(result);  //my name is XiaoMing, age 11</span><br><span class=\"line\"> String.prototype.render = function (Object) &#123;</span><br><span class=\"line\">   var _$this = this;</span><br><span class=\"line\">   var keys = new Array();</span><br><span class=\"line\">   for (var p in Object)</span><br><span class=\"line\">   if (Object.hasOwnProperty(p))</span><br><span class=\"line\">   keys.push(p);</span><br><span class=\"line\">   for (i = 0; i &lt; keys.length; i++) &#123;</span><br><span class=\"line\">     (function (index) &#123;</span><br><span class=\"line\">       var s = &apos;$&#123;&apos; + keys[index] + &apos;&#125;&apos;;</span><br><span class=\"line\">       str = _$this.replace(s, Object[keys[index]]);</span><br><span class=\"line\">       _$this = str;</span><br><span class=\"line\">     &#125;) (i);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   return str</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> var greeting = &apos;my name is $&#123;name&#125;, age $&#123;age&#125;&apos;;</span><br><span class=\"line\"> var result = greeting.render(&#123;</span><br><span class=\"line\">   name: &apos;XiaoMing&apos;,</span><br><span class=\"line\">   age: 11</span><br><span class=\"line\"> &#125;);</span><br><span class=\"line\"> console.log(result);//my name is XiaoMing, age 11</span><br><span class=\"line\">other:</span><br><span class=\"line\"> String.prototype.render = function (Object) &#123;</span><br><span class=\"line\">   var _this = this;</span><br><span class=\"line\">   for (var p in Object)</span><br><span class=\"line\">   if (Object.hasOwnProperty(p))</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">     var s = &apos;$&#123;&apos; + p + &apos;&#125;&apos;;</span><br><span class=\"line\">     str = _this.replace(s, Object[p]);</span><br><span class=\"line\">     _this = str;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   return str</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> var greeting = &apos;my name is $&#123;name&#125;, age $&#123;age&#125;&apos;;</span><br><span class=\"line\"> var result = greeting.render(&#123;</span><br><span class=\"line\">   name: &apos;XiaoMing&apos;,</span><br><span class=\"line\">   age: 11</span><br><span class=\"line\"> &#125;);</span><br><span class=\"line\"> console.log(result); //my name is XiaoMing, age 11</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>5.对json格式中的某一字段进行排序</p>\n</blockquote>\n  <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">eg：var stuJson = [&#123; name: &quot;daming&quot;, age: 21, weight: 66, sex:&quot;boy&quot; &#125;,</span><br><span class=\"line\">                 &#123; name: &quot;lisa&quot;, age: 19, weight: 45, sex:&quot;girl&quot; &#125;,</span><br><span class=\"line\">                 &#123; name: &quot;lili&quot;, age: 20, weight: 50, sex:&quot;boy&quot;&#125;];</span><br><span class=\"line\">   //eg:按age升序</span><br><span class=\"line\">stuJson.sort(function(a,b)&#123;</span><br><span class=\"line\">                  return a.age - b.age;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">console.log(stuJson);//[ &#123; name: &apos;lisa&apos;, age: 19, weight: 45, sex: &apos;girl&apos; &#125;,</span><br><span class=\"line\">                   //&#123; name: &apos;lili&apos;, age: 20, weight: 50, sex: &apos;boy&apos; &#125;,</span><br><span class=\"line\">                   //&#123; name: &apos;daming&apos;, age: 21, weight: 66, sex: &apos;boy&apos; &#125; ]</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>6.用一句语句对数组去最小或最大值</p>\n</blockquote>\n  <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">eg:var arr = [32,42,12,42,21,23,56,75,3,33,53,23,36];</span><br><span class=\"line\">   var aMin = Math.min.apply(null,arr);</span><br><span class=\"line\">   console.log(min);//3</span><br><span class=\"line\">   var aMax = Math.max.apply(null,arr);//75</span><br><span class=\"line\">   console.log(aMax);</span><br></pre></td></tr></table></figure>\n","categories":["笔试&面试"],"tags":["web前端","笔试"]},{"title":"两个iframe框滚动条联动以及iframe窗口高宽自适应","url":"http://dearxiaojie.top/article/2015-05-25-两个iframe框滚动条联动以及iframe窗口高宽自适应.html","content":"<p>由于iframe没有onsccoll方法，所以采用把iframe放进固定大小且带有滑动条的div中，然后先给iframe一个适合的宽度，页面加载后再让iframe窗口自适应src链接的页面。<br><a id=\"more\"></a></p>\n   <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;div1&quot;  style=&quot;width:620px;height:500px ; float:left;overflow:scroll&quot; onscroll=&quot;funcsrcoll1()&quot;&gt;</span><br><span class=\"line\">\t   &lt;iframe name=&quot;left&quot; id=&quot;left&quot; scrolling=&quot;no&quot; width=&quot;600px&quot; height=&quot;500px&quot; src=&quot;2.html&quot;&gt;&lt;/iframe&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;div id=&quot;div2&quot; style=&quot;width:620px; height:500px ;float:left;overflow:scroll&quot; onscroll=&quot;funcsrcoll2()&quot;&gt;</span><br><span class=\"line\">\t&lt;iframe name=&quot;right&quot; id=&quot;right&quot; scrolling=&quot;no&quot; width=&quot;600px&quot; height=&quot;500px&quot; src=&quot;3.html&quot;&gt;&lt;/iframe&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">\t//控制两个div的滚动条联动，便于页面对比</span><br><span class=\"line\">\tfunction funcsrcoll1()</span><br><span class=\"line\">\t  &#123;</span><br><span class=\"line\">\t      div2.scrollLeft = div1.scrollLeft;</span><br><span class=\"line\">\t      div2.scrollTop = div1.scrollTop;</span><br><span class=\"line\">\t  &#125;</span><br><span class=\"line\">\tfunction funcsrcoll2()</span><br><span class=\"line\">\t  &#123;</span><br><span class=\"line\">\t      div1.scrollLeft = div2.scrollLeft;</span><br><span class=\"line\">\t      div1.scrollTop = div2.scrollTop;</span><br><span class=\"line\">\t  &#125;</span><br><span class=\"line\">\t  //调整iframe窗口大小适应src链接的页面</span><br><span class=\"line\">\t  function func()&#123;</span><br><span class=\"line\">\t  $(&apos;iframe&apos;).each(function()&#123;</span><br><span class=\"line\">\t      this.style.height = this.contentWindow.document.body.scrollHeight+20 + &apos;px&apos;;</span><br><span class=\"line\">\t        //为了显示完整，额外加了20px的宽度</span><br><span class=\"line\">\t      this.style.width = this.contentWindow.document.body.scrollWidth+20 + &apos;px&apos;;</span><br><span class=\"line\">\t  &#125;);    </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n","categories":["前端积累"],"tags":["iframe","scroll"]},{"title":"高性能JavaScript","url":"http://dearxiaojie.top/article/2015-05-24-高性能JavaScript.html","content":"<h2 id=\"javascript加载和运行\"><a href=\"#javascript加载和运行\" class=\"headerlink\" title=\"javascript加载和运行\"></a>javascript加载和运行</h2><h3 id=\"脚本位置\"><a href=\"#脚本位置\" class=\"headerlink\" title=\"脚本位置\"></a>脚本位置</h3><p>尽管浏览器已经允许并行下载javascript文件，但是javascript下载过程仍然会阻塞其他资源的下载，如图片。页面仍然需要等待所有javascript代码下载并执行完成才能继续所以优化javascript的首要原则：将脚本放在底部（<code>&lt;/body&gt;</code>之前)<br><a id=\"more\"></a></p>\n<h3 id=\"组织脚本\"><a href=\"#组织脚本\" class=\"headerlink\" title=\"组织脚本\"></a>组织脚本</h3><p>每个<code>&lt;script&gt;</code>标签初始下载都会阻塞页面渲染，所以减少页面包含的<code>&lt;script&gt;</code>标签数量有助于改善这一情况。考虑到到HTTP请求会额外带来性能的开销。下载单个100B的文件比下载4个25B的文件更快。所以，减少页面中外链脚本文件的数量会改善性能。</p>\n<!--more-->\n<h3 id=\"无阻塞的脚本\"><a href=\"#无阻塞的脚本\" class=\"headerlink\" title=\"无阻塞的脚本\"></a>无阻塞的脚本</h3><ul>\n<li>延迟的脚本：带有defer属性的<code>&lt;script&gt;</code>标签，需要浏览器支持</li>\n<li>动态脚本元素:在跨浏览器兼容性和易用的优势，是最通用的无阻塞加载解决方案</li>\n<li><p>XMLHttpRequest注入：先创建一个XHR对象，然后用她下载javascript文件，最后通过创建动态<code>&lt;script&gt;</code>元素将代码注入页面中</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var xhr = new XMLHttpRequest();</span><br><span class=\"line\">xhr.open(&quot;get&quot;,&quot;file.js&quot;,true);</span><br><span class=\"line\">xhr.onreadystatechange = funtion()&#123;</span><br><span class=\"line\">     if(xhr.readyState == 4)&#123;</span><br><span class=\"line\">          if(xhr.status&gt;=200&amp;&amp;xhr.status&lt;300||xhr.status==304)&#123;</span><br><span class=\"line\">               var script = document.creatElement(&quot;script&quot;);</span><br><span class=\"line\">               script.type=&quot;text/javascript&quot;;</span><br><span class=\"line\">               script.text=xhr.responseText;</span><br><span class=\"line\">               document.body.appendChild(script);</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">          &#125;    </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">xhr.send(null);</span><br><span class=\"line\">//由于代码是在&lt;script&gt;标签之前返回的，因此它下载后不会自动执行。</span><br><span class=\"line\">//同样的代码在所有主流浏览器中无一例外都能正常工作</span><br><span class=\"line\">//局限性在于：javascript文件必须与请求的页面处于相同的域，即javascript不能从CDN下载</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"无阻塞脚本加载工具\"><a href=\"#无阻塞脚本加载工具\" class=\"headerlink\" title=\"无阻塞脚本加载工具\"></a>无阻塞脚本加载工具</h3><p>lazyLoad类库、LABjs等等</p>\n<p>##管理作用域</p>\n<h3 id=\"作用域链和标识符解析\"><a href=\"#作用域链和标识符解析\" class=\"headerlink\" title=\"作用域链和标识符解析\"></a>作用域链和标识符解析</h3><p>在函数执行的过程中，没遇到一个变量，都会经历一次标识符解析过程以决定从哪里获取或存储数据。该过程搜索运行期上下文的作用域链，查找同名的标识符。搜索过程从作用域链头部开始也就是当前运行函数的活动对象，如果找到了，就使用这个标示符对应的变量；如果没有找到，继续搜索作用域链中的下一个对象，直到标识符被找到，或者没有可用于搜索的对象为止，这种情况下标识符被认为是未定义的。正是这个搜索过程影响了性能。</p>\n<h3 id=\"标识符解析的性能\"><a href=\"#标识符解析的性能\" class=\"headerlink\" title=\"标识符解析的性能\"></a>标识符解析的性能</h3><p>一个标识符所在的位置越深，他的读写速度就越慢，因此读写局部变量总是最快的，而读写全局变量通常是最慢的。全局变量总是存在于运行期上下文作用域链的最末端，因此是最远的。在没有优化javascript引擎的浏览器中，尽量使用局部变量，如果某个跨作用域的值在函数中被引用了多次，就把他存储到局部变量里。</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function initUI() &#123;</span><br><span class=\"line\">  var doc = document,</span><br><span class=\"line\">      bd = doc.body,</span><br><span class=\"line\">      links = doc.getElementByTagName(&apos;a&apos;);</span><br><span class=\"line\">  var i = 0,</span><br><span class=\"line\">      len = links.length;</span><br><span class=\"line\">  while (i &lt; len) &#123;</span><br><span class=\"line\">      update(links[i++]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  doc.getElementById(&apos;btn&apos;).onclick = function() &#123;</span><br><span class=\"line\">      start();</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">     bd.className = &apos;active&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    //首先将document对象引用存储到局部变量doc中，全局变量的访问减少，当有很多全局变量</span><br><span class=\"line\">    //被反复访问时，这种方法对性能的改善是很明显的。</span><br></pre></td></tr></table></figure>\n<h3 id=\"闭包，作用域和内存\"><a href=\"#闭包，作用域和内存\" class=\"headerlink\" title=\"闭包，作用域和内存\"></a>闭包，作用域和内存</h3><p>将常用的跨作用域变量存储在局部变量中，然后访问局部变量嵌套的对象成员会明显影响性能，尽量少用<br>通常来说，把常用的对象成员、数组元素、跨域变量保存在局部变量中来改善javascript性能，因为局部变量访问速度更快。</p>\n<p>DOM</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function initHtml1()&#123;</span><br><span class=\"line\">     for(var i = 0;i&lt;15000;i++)&#123;</span><br><span class=\"line\">     document.getElementById(&apos;here&apos;).innerHTML+=&apos;a&apos;;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function initHtml2()&#123;</span><br><span class=\"line\">     var html = &quot;&quot;;</span><br><span class=\"line\">     for(var i=0;i&lt;15000;i++)&#123;</span><br><span class=\"line\">     html+=&apos;a&apos;;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     document.getElementById(&apos;here&apos;).innerHTML = html;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>initHtml1()比initHtml2()速度慢很多，initHtml2()使用局部变量存储更新后的内容，减少了DOM访问，因此，减少DOM访问次数，讲运算尽量留在ECMAScript这端处理。</p>\n","categories":["学习笔记"],"tags":["javascript","性能优化"]},{"title":"about","url":"http://dearxiaojie.top/about/index.html","content":"","categories":[],"tags":[]},{"title":"category","url":"http://dearxiaojie.top/category/index.html","content":"","categories":[],"tags":[]},{"title":"","url":"http://dearxiaojie.top/css/personal-style.css","content":"@font-face {\n    font-family: \"Meiryo\";\n    src: url(\"/fonts/Meiryo.eot\");\n    /* IE9 */\n    src: url(\"/fonts/Meiryo.eot?#iefix\") format(\"embedded-opentype\"), /* IE6-IE8 */\n    url(\"/fonts/Meiryo.woff\") format(\"woff\"), /* chrome, firefox */\n    url(\"/fonts/Meiryo.ttf\") format(\"truetype\"), /* chrome, firefox, opera, Safari, Android, iOS 4.2+ */\n    url(\"/fonts/Meiryo.svg#Meiryo\") format(\"svg\");\n    /* iOS 4.1- */\n    font-style: normal;\n    font-weight: normal;\n  }\n  html.page-home {\n    position: absolute;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    background-color: transparent;\n    background-size: cover;\n    background-position: center center;\n    background-repeat: no-repeat;\n  \n    background: linear-gradient( #1abc9c, transparent), linear-gradient( 90deg, skyblue, transparent), linear-gradient( -90deg, coral, transparent);\n    background-blend-mode: screen;\n  \n    /*background: linear-gradient(to left, #5f2c82, #49a09d);*/\n  }","categories":[],"tags":[]},{"title":"link","url":"http://dearxiaojie.top/link/index.html","content":"","categories":[],"tags":[]},{"title":"project","url":"http://dearxiaojie.top/project/index.html","content":"","categories":[],"tags":[]},{"title":"search","url":"http://dearxiaojie.top/search/index.html","content":"","categories":[],"tags":[]},{"title":"tag","url":"http://dearxiaojie.top/tag/index.html","content":"","categories":[],"tags":[]}]