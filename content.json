[{"title":"javascirpt常用函数实现","date":"2018-07-03T12:02:30.000Z","path":"article/2018-07-03-javascirpt-common-method.html","text":"随手记录点好玩的东西 实现一个sleep函数// promise const sleep = time => { return new Promise(resolve => { setTimeout(resolve, time); }); }; const t1 = +new Date(); sleep(1000).then(() => { const t2 = +new Date(); console.log(t2 - t1); // 1005 }) //await/async const sleep = time => { return new Promise(resolve => { setTimeout(resolve, time); }); }; const ts = async () => { const t1 = +new Date(); await sleep(1000); const t2 = +new Date(); console.log(t2 - t1); } ts(); // 1001 在社区能找到一个https://github.com/erikdubbelboer/node-sleep,不过需要安装才能使用 const sleep = require('sleep'); const t1 = +new Date(); sleep.msleep(1000); const t2 = +new Date(); console.log(t2 - t1); // 1000 数组去重// 双重循环 const arr = [1, 2, 3, '4', 3, 1]; const unique = arr => { const rst = []; let i, j, len, lens; for (i = 0, len = arr.length; i &lt; len; i++) { let item = arr[i]; for (j = 0, lens = rst.length; j &lt; lens; j++) { if (item === rst[j]) { break; } } lens === j &amp;&amp; rst.push(item) } return rst; }; console.log(unique(arr)); //[ 1, 2, 3, '4' ] 待续","tags":[]},{"title":"go-practice-follow-offical-tour","date":"2018-06-15T09:37:50.000Z","path":"article/2018-06-15-go-practice-follow-offical-tour.html","text":"最近在学习go相关的东西，以下为Go官方指南中的练习记录 循环与函数实现一个平方根函数：用牛顿法实现平方根函数 package main import ( \"fmt\" ) func Sqrt(x float64) float64 { z := x / 2 cnt := 10 for cnt > 0 { z -= (z * z - x) / (2 * z) cnt = cnt - 1 } return z } func main() { fmt.Println(Sqrt(3)) // 1.7320508075688772 } 切片实现 Pic。它应当返回一个长度为 dy 的切片，其中每个元素是一个长度为 dx，元素类型为 uint8 的切片。当你运行此程序时，它会将每个整数解释为灰度值（好吧，其实是蓝度值）并显示它所对应的图像 package main import \"golang.org/x/tour/pic\" func Pic(dx, dy int) [][]uint8 { pic := make([][]uint8, dy*dx) for i := 0; i &lt; dy; i++ { in := make([]uint8, dx) for j := 0; j &lt; dx; j++ { in[j] = uint8(1 &lt;&lt; uint8(j%8)) } pic[i] = in } return pic } func main() { pic.Show(Pic) } 映射实现 WordCount。它应当返回一个映射，其中包含字符串 s 中每个“单词”的个数。函数 wc.Test 会对此函数执行一系列测试用例，并输出成功还是失败 package main import ( \"strings\" \"golang.org/x/tour/wc\" ) func WordCount(s string) map[string]int { m := make(map[string]int) field := strings.Fields(s) for i := 0; i &lt; len(field); i++ { if m[field[i]] > 0 { m[field[i]] = m[field[i]] + 1 } else { m[field[i]] = 1 } } return m } /* output func main() { wc.Test(WordCount) } PASS f(\"I am learning Go!\") = map[string]int{\"I\":1, \"am\":1, \"learning\":1, \"Go!\":1} PASS f(\"The quick brown fox jumped over the lazy dog.\") = map[string]int{\"dog.\":1, \"The\":1, \"fox\":1, \"over\":1, \"the\":1, \"quick\":1, \"brown\":1, \"jumped\":1, \"lazy\":1} PASS f(\"I ate a donut. Then I ate another donut.\") = map[string]int{\"another\":1, \"I\":2, \"ate\":2, \"a\":1, \"donut.\":2, \"Then\":1} PASS f(\"A man a plan a canal panama.\") = map[string]int{\"plan\":1, \"canal\":1, \"panama.\":1, \"A\":1, \"man\":1, \"a\":2} */ 斐波纳契闭包实现一个 fibonacci 函数，它返回一个函数（闭包），该闭包返回一个斐波纳契数列 (0, 1, 1, 2, 3, 5, ...)。 package main import \"fmt\" func fibonacci() func() int { a, b, c := -1, 0, 0 return func() int { if a == -1 { a = 0 return a } else if a == 0 { a = 1 return a } else { c = a + b b = a a = c return c } } } func main() { f := fibonacci() for i := 0; i &lt; 10; i++ { fmt.Println(f()) } } // 0, 1, 1, 2, 3, 5, 8, 13, 21, 34 Stringer通过让 IPAddr 类型实现 fmt.Stringer 来打印点号分隔的地址。例如，IPAddr{1, 2, 3, 4} 应当打印为 “1.2.3.4”。 package main import \"fmt\" type IPAddr [4]byte func (ip IPAddr) String() string { var result string for i, v := range ip { result += fmt.Sprintf(\"%v\", v) if i &lt; len(ip) - 1 { result += \".\" } } return result } func main() { hosts := map[string]IPAddr{ \"loopback\": {127, 0, 0, 1}, \"googleDNS\": {8, 8, 8, 8}, } for name, ip := range hosts { fmt.Printf(\"%v: %v\\n\", name, ip) } } // loopback: 127.0.0.1 // googleDNS: 8.8.8.8 note(方法与指针) 带指针参数的函数必须接受一个指针,而以指针为接收者的方法被调用时，接收者既能为值又能为指针。 由于指针参数的函数方法有一个指针接收者，为方便起见，Go 会将语句 v.Scale(5) 解释为 (&amp;v).Scale(5)； 接受一个值作为参数的函数必须接受一个指定类型的值，而以值为接收者的方法被调用时，接收者既能为值又能为指针，方法调用 p.Abs() 会被解释为 (*p).Abs() 使用指针接收者的原因有二： 首先，方法能够修改其接收者指向的值。 其次，这样可以避免在每次调用方法时复制该值。若值的类型为大型结构体时，这样做会更加高效。","tags":[]},{"title":"陌与墨语","date":"2018-05-04T06:51:45.000Z","path":"article/2018-05-04-陌与墨语.html","text":"似乎很久没写博客了，今天趁上班摸鱼时间，想着干点啥，那就写写自己博客吧。 回忆第一次在github上搭博客以来，已经换了三个域名了，从最初的xiaojwithu.info到后来的dearxiaojie.xyz,两个域名都只维持了一年的时间就没有续费了，当时只是出于玩的目的，所以并没有花什么精力在上面。再看写过的文章，大多都是笔试面试，学习笔记，采坑总结，没有半点干货输出。但是我不会删掉它们，一是因为删了就没内容了（囧…），其次，那也是自己写博客的开始，留点记忆吧。目前换成了新的域名dearxiaojie.top，时间也更长了些，前些天github pages正好支持https了，也将博客设置成https的了。 心里一直有个todolist，但是却久未执行。可能是工作时间长了精力也分散了，买的一摞书也只是堆在那，偶尔躺床上的时候翻开几页看看，和买书时的初衷有些相悖。面对快速更新的技术，有时候显得手足无措。虽然自己知道应该从哪开始，选择哪些，但是心里还是会有莫名的慌乱，学的越多越觉得自己知道的太少，以至于觉得要学的东西就更多，甚至就偏离了方向。 将TODO列出来一个一个执行我估计我还是办不到，至少现在没有心思去整理。 虽不是得过且过，但我一直坚持在学习。 我告诉自己，接下来的路还很长。 以后还是多更新博客吧。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://dearxiaojie.top/tag/随笔/"}]},{"title":"使用JavaScript处理点九图","date":"2018-01-09T09:56:03.000Z","path":"article/2018-01-09-use-javascript-to-handle-9-patch.html","text":"前言在前端开发中，常会将图片作为某个元素的背景图，但是背景图的大小和比例和元素有偏差，所以一般要使元素有全背景的话，只能将图片拉伸。这里不考虑background-repeat。最好的办法还是将图片修改为比例和元素相同以等比缩放。使用微信或者QQ的人应该会发现聊天气泡，气泡会随着内容多少的改变而去适应它，但是并没有使气泡图片有拉伸的效果，这里就用到了点九图 点九图关于点九图这里不做过多介绍，简单来说，它是andriod平台的应用软件开发里的一种特殊的图片形式，扩展名为.9.png。它有两个重要的特点是：四周必须要有四条一像素纯黑的线或点；左上两条线控制拉伸区，右下两条线控制内容区。这里我们需要将上传的点九图片拉伸成指定的或者自适应的比例，在没有接触点九图之前根本没有任何想法，于是上github上找到一个在web端处理点九图的库，将代码拉取到本地即可看到demo。 分析阅读源码发现主要使用border-image和用canvas绘制两种方式实现。首先先取出点九图左边和上边1px，这里以水平方向为例： let tempCtx, tempCanvas; tempCanvas = document.createElement('canvas'); tempCtx = tempCanvas.getContext('2d'); tempCtx.drawImage(this.bgImage, 0, 0); let data = tempCtx.getImageData(0, 0, this.bgImage.width, 1).data; 上面的data存放的为只读的ImageData.data属性，返回Uint8ClampedArray,描述一个一维数组，包含以 RGBA 顺序的数据，数据使用 0 至 255（包含）的整数表示。然后遍历这个一维数组，每4位一个step，找到可拉伸的区间数量和区域。 NinePatch.prototype.getPieces = function(data, staticColor, repeatColor) { var tempDS, tempPosition, tempWidth, tempColor, tempType; var tempArray = new Array(); tempColor = data[4] + ',' + data[5] + ',' + data[6] + ',' + data[7]; tempDS = (tempColor == staticColor ? 's' : (tempColor == repeatColor ? 'r' : 'd')); tempPosition = 1; for (var i = 4, n = data.length - 4; i &lt; n; i += 4) { tempColor = data[i] + ',' + data[i + 1] + ',' + data[i + 2] + ',' + data[i + 3]; tempType = (tempColor == staticColor ? 's' : (tempColor == repeatColor ? 'r' : 'd')); if (tempDS != tempType) { // box changed colors tempWidth = (i / 4) - tempPosition; tempArray.push(new Array(tempDS, tempPosition, tempWidth)); tempDS = tempType; tempPosition = i / 4; tempWidth = 1 } } // push end tempWidth = (i / 4) - tempPosition; tempArray.push(new Array(tempDS, tempPosition, tempWidth)); return tempArray; } 上面的getPieces方法存放了可用于判断拉伸区间数量和可拉伸范围的数组。在将其传入绘制函数中。 for (var i = 0, n = this.horizontalPieces.length; i &lt; n; i++) { if (this.horizontalPieces[i][0] == 's') { tempStaticWidth += this.horizontalPieces[i][2]; } else { tempDynamicCount++; // 拉伸区间数量 } } fillWidth = (dWidth - tempStaticWidth) / tempDynamicCount; // 可拉伸区间 再将取得的水平和垂直的1px获取到的数组进行嵌套循环，去填充拉伸图片，这里就不贴代码了，可以查阅源码理解。 新问题找到的这种方式只能将图片进行放大，如果点九图比需要预览的图大，那就不适用了，还有个新问题是，点九图的宽或高跟预览图相比，有个的值大，有一个的值小，如：W点九 &gt; W预览，H点九 &lt; H预览。这种情景也不适用，所以考虑处理点九图。这里只说最终的解决办法，当点九图的宽或高其中一个大于预览图的对应值时，将对应边缩小到预览图的值，再将另一边等比缩小，产生新的点九图片，这样新的点九图肯定比预览图小，可以正常拉伸了。 if (this.div.offsetWidth &lt; this.bgImage.width &amp;&amp; this.div.offsetHeight > this.bgImage.height) { tmpCanvas.width = this.div.offsetWidth; tmpCanvas.height = Math.floor(this.bgImage.height * this.div.offsetWidth / this.bgImage.width); tmpCtx.drawImage(this.bgImage, 0, 0, this.div.offsetWidth, Math.floor(this.bgImage.height * this.div.offsetWidth / this.bgImage.width)); let tmpImage = new Image(); tmpImage.src = tmpCanvas.toDataURL(\"image/png\"); this.bakImage = this.bgImage; this.bgImage = tmpImage; } 遗留的问题按照上面的缩放方式，不论是宽还是高缩小，都会影响原点九图左边或者上面的1px的边界，导致在 getPieces方法中误取可拉伸区间值，这种情况一般发生在边界线离点九图非透明色边界距离较近时发生，暂时没有想到解决方案。想到其实这也是种模拟实现的方式，在实际的产品中不可能多用。不过这个过程收获也是挺大。有好的解决方案欢迎轻敲~~","tags":[{"name":"javascript","slug":"javascript","permalink":"http://dearxiaojie.top/tag/javascript/"},{"name":"canvas","slug":"canvas","permalink":"http://dearxiaojie.top/tag/canvas/"},{"name":"9-patch","slug":"9-patch","permalink":"http://dearxiaojie.top/tag/9-patch/"}]},{"title":"记一次多图上传+本地预览中遇到的问题","date":"2017-11-30T06:54:54.000Z","path":"article/2017-11-30-mutiple-image-upload.html","text":"在web开发中常会遇到图片预览的场景，比如在图片上传的情况下，一个办法是将图片上传到服务器之后，服务端将存储的URL返回来，然后异步通过URL加载刚上传的图片，达到图片的预览。但是在这个过程中会有两次web请求，一次是发送文件，一次是下载文件。我们可以在图片上传前就进行图片的预览，这样可以避免不必要的网络请求和等待。 图片添加&lt;input type=\"file\" id=\"uploadcontainer\" name=\"images\" multiple=\"multiple\" accept=\"image/*\"> 如上，input将type设置为file即可以上传文件，accept可以设置接收文件类型，这里是上传图片，所以设置成了image/*, multiple 属性可以支持多文件上传。 图片预览 以下代码默认加载了jquery // 监听图片添加 $('#uploadcontainer').on('change', function() { let files = $(this).prop('files'); that.preview(files); }); preview: function(files) { let that = this; // 遍历预览 $.each(files, function(index, item) { let fileReader = new FileReader(); let tpl = new Template($('#tpl').html()); fileReader.readAsDataURL(item); fileReader.onload = function(e) { that.FILES.push(item); // *** 图片onload过程中将图片存在一个全局的数组中,因为在预览过程中还会有分类等处理，会在真正上传的时候添加更多参数 html = tpl.render({ cover_url: e.currentTarget.result, title: item.name.split('.')[0], }); // ... 将html放到页面 }; }); } 图片上传 假定我们的接口只支持每次只能上传一张图片 upload: function(f, cb) { // 递归 (function uploads() { let file = f.shift(); if (file) { // 避免重名导致上传混乱，每次都重新创建新的对象 let formData = new FormData(); formData.append('image', file.image); formData.append('title', file.title); formData.append('category', file.category); $.ajax({ type: 'POST', url: '****', data: formData, contentType: false,// * cache: false, processData: false // * }).always(function(rst) { if (rst.ret == 1) { console.log(file.title + ' 上传中...') } else { console.log(ret.msg || file.title + ' 上传失败...') } uploads(); }); } else { console.log('上传完成...'); cb(); } })(); }, 后记 使用FormData对象，设置contentType为false, processData为false fileReader.onload的时候缓存图片，不然不能对应图片及增加的参数，导致图片和参数对应混乱 递归上传，每次创建FormData对象，避免重复上传和重名混乱","tags":[{"name":"js","slug":"js","permalink":"http://dearxiaojie.top/tag/js/"}]},{"title":"highcharts线型图表处理","date":"2017-08-29T07:05:40.000Z","path":"article/2017-08-29-diy-highcharts.html","text":"问题分析某次需求中，需要使用highcharts展示数据以对比。可是这批数据量级相差较大，如果在同一张图表中展示，会导致线条相隔很远或者没有波动幅度；还需要在点击某根线条的时候改变图表Y轴为当前线条数量级的，并处理他们的样式以区分。 那么，第一个问题，要在同一张表中展示不同量级的数据，且相互具有参考性，有个办法就是将数据统一处理成一个维度的，如数据归一化，将数据映射到0~1之间的小数，那不同量级的数据之间就有一定的参考性了。第二个问题的话本来想过改源码，但是感觉意义不大，使用场景不多，就找highcharts的api文档，各种拼接。差不多实现了需求. 数据归一化采用min-max标准化，也叫离差标准化，对原始数据的线性变化，结果落到[0, 1]之间。将需要处理的数据组，即series数据先处理，找到每组的最大最小，并计算. function normalizing(arr) { var data = []; for (var i = 0, len = arr.length; i &lt; len; i++) { var cur = arr[i].data; arr[i].visible = false; var name = arr[i].name; arr[i].showInLegend = false; var max = Math.max.apply(null, cur); var min = Math.min.apply(null, cur); var news = cur.map(function (x) { return (x - min) / max; }); var item = { name: name, data: news }; arr.push(item) } return arr; }; 上面代码中，将原数据的每个线条设置为不显示，再将归一化后的数据push到数组后面。即最终图表上显示的是处理后的数据绘制的线条，这样的操作会引发后面的问题，接下来会提到。 展示真实数据在上面一步中，将所有数据都处理成了[0, 1]之间的数据，那鼠标hover上去显示的就是计算后的数据。这显然不是我们想要的，所以才没有去除原来的数据。查看highcharts的api，发现可以改变hover显示的格式，那我只需要找到计算后与之相对应的原数据就能正确显示了。现在hover能够正确显示数据了，图表里的线条也有了一定的对比性，但是Y轴坐标依然是按照归一化后数据量级来的。在考虑到需要在点击线条的时候显示成其原数据量级的Y轴，所以采用以下办法。取出选中线条数据中的最大最小，按照归一化算法逆回去，那么其实现在图表中的线条已经不是[0, 1]之间的数据了，而是分别乘上点击线条最大值，并加上最小值后的数据。那么，Y轴的自然就变成了当前的数据量级。 function adjustSeries(activeName) { var data = chart.series; var max, min; for (var i = 0, len = 6; i &lt; len; i++) { var curName = data[i + 6].name var current = data[i]; if (curName === activeName) { max = Math.max.apply(null, current.yData); min = Math.min.apply(null, current.yData); } } for (var i = 6, len = originData.length; i &lt; len; i++) { var cur = originData[i].data || []; var newc = cur.map(function (item, index) { var cnt = Math.round(item * max) + min; return cnt; }); var upObj = { data: newc, lineWidth: 1, dashStyle: 'Dash', dataLabels: { enabled: false }, className: 'half-opacity' }; if (originData[i].name === activeName) { upObj = { data: newc, lineWidth: 4, dashStyle: 'Solid', dataLabels: { enabled: true }, className: 'no-opacity' } } chart.series[i].update(upObj); } }; 上面代码中的originData其实就是归一化后存起来的一个副本，因为后面每次点击都会使用这个数据，所以在存数据的时候一定要保证originData不变，存放的是真实数据，而不是数据引用，javascript基础知识，不清楚的可查看javascript中的深拷贝和浅拷贝。 使用到的API plotOptions.series.event.click 点击线条的时候处理相关逻辑 tooltip.formatter 更改鼠标hover的时候显示的数据和样式 chart.series[i].update 动态更新图表数据，定制线条样式 其他… reference Highcharts API 成品链接","tags":[{"name":"js","slug":"js","permalink":"http://dearxiaojie.top/tag/js/"}]},{"title":"在浏览器中懒加载ES2015模块","date":"2017-06-05T11:51:28.000Z","path":"article/2017-06-05-lazy-loading-es2015-modules-in-the-browser.html","text":"ES2015模块在浏览器懒加载 在过去的几年里，开发者们已经无情的将服务端网站移动到了客户端，前提是那样能使页面的性能得到提高。 然而，这可能是不够的。你是否考虑过你的网站也许加载更多于它实际用到的东西？遇到懒加载，一个延迟初始化（加载/分配）某个资源(代码/数据/静态资源)直到它需要的时候再加载。 与此同时，ES2015已经能在生产环境中使用了，通过一些transpilers如Babel。现在你不用参与到使用AMD还是CommonJS的战争中，参照这篇文章的描述（The mind-boggling universe of JavaScript Module strategies）,因为你可以写ES2015模块和让他们transpiled并交付给浏览器同时支持现有CommonJS或AMD模块。 在这篇文章中，我将讨论如何使用System.js同步(在页面加载的时候)和异步(懒加载)加载ES2015模块。 页面加载 vs 懒加载在浏览器上开发JavaScript代码执行时,你必须决定什么时候你让它执行。有一些代码必须在页面加载的同时就执行，比如SPA应用使用了一些框架如Angular，Ember，Backbone，或者React，这些代码可能通过一个或多个&lt;script&gt;标签，必须在一个页面请求返回到浏览器后被引用到HTML文档的主体结构中。 在另一方面，你可能有更多的代码块在一些特定的触发条件发生的时候在执行。经典的例子如： 内容折叠。比如一个评论面板，在用户滚动到页底的时候才显示 事件触发内容显示。比如一个放大的覆盖层，在用户点击图片的时候在显示 少数内容。比如一个‘免运费’的控件，只只用于一些小的页面上 有时间间隔的内容显示。比如一个客服聊天框 这样的话，对于给出一个类似上面的功能，如果他的触发条件未发生，他的代码块就永远不会被执行。因此，那个代码块在页面加载的时候明显是不需要的，是可以延迟加载的。 为了延迟加载，你只需要将在页面加载期间执行的代码从代码块中提取出来。这样在他的触发条件第一次发生的时候就被执行。 这种异步加载引用代码的方式，或者叫懒加载，在提升页面性能上扮演了一个重要的角色，从减少页面首屏时间和速度指数上来看的话。 为了学习更多关于对比页面加载和懒加载对页面性和速度指数的影响的知识，可以阅读这篇文章 Leveling up: Simple steps to optimize the Critical Rendering Path AMD陷阱AMD标准是为在浏览器上异步加载加载创造的，是第一个作为全局JavaScript文件散落在页面的成功替代品。根据Require.js文档: The AMD format comes from wanting a module format that was better than today’s “write a bunch of script tags with implicit dependencies that you have to manually order” and something that was easy to use directly in the browser. 它是基于模块设计模式Module Design Pattern的授权，有一个模块加载器，依赖注入和异步能力。它的一个主要的作用就是执行模块的懒加载。 尽管是一个可怕的想法，它带来了一些固有的复杂性：也就是说，之前理解运行时模块的timelines是不那么重要的。这就意味着开发者们需要知道每个异步模块是什么时候做它预期的工作的。 如果不明白这点，开发者们发现这样的情况：它有时候能正常工作，有时候不能。由于竞态，调试是非常困难的。因为这样的事情，AMD失去了大量的势头和牵引。 学习更多关于AMD的陷阱，查看Moving Past RequireJS ES2015模块101在继续下去之前，我们回顾一下ES2015模块。如果你已经非常熟悉了，那这是一个快速的复习。在ES2015中，模块已经成为官方JavaScript语言的一部分，它们非常强大而且很容易去掌握，站在CommonJS模块这个巨人的肩膀上的话。 作用域通常，一个ES2015模块所有的全局变量仅作用于自己这个文件，模块可以导出数据，也可以导入其他的模块。 导出和导入在一个你想导出的项目(如一个变量，函数、类)的前面加上一个关键词export就可以导出，在下面这个例子中，我们导出Dog和Wolf: // zoo.js var getBarkStyle = function(isHowler) { return isHowler? 'woooooow!': 'woof, woof!'; }; export class Dog { constructor(name, breed) { this.name = name; this.breed = breed; } bark() { return `${this.name}: ${getBarkStyle(this.breed === 'husky')}`; }; } export class Wolf { constructor(name) { this.name = name; } bark() { return `${this.name}: ${getBarkStyle(true)}`; }; } 让我们想想如果在一个单元测试（如Mocha/Chai）用引入这个模块。使用语法import &lt;object&gt; from &lt;path&gt;，至于&lt;object&gt;我们可以选择我们想导入的元素–命名导入（named imports）。接下来我们可以从chai中导入expect，同样，从Zoo中导入Dog和Wolf。这种命名导入的语法很像ES2015的另一个方便的特性–解构赋值 // zoo_spec.js import { expect } from 'chai'; import { Dog, Wolf } from '../src/zoo'; describe('the zoo module', () => { it('should instantiate a regular dog', () => { var dog = new Dog('Sherlock', 'beagle'); expect(dog.bark()).to.equal('Sherlock: woof, woof!'); }); it('should instantiate a husky dog', () => { var dog = new Dog('Whisky', 'husky'); expect(dog.bark()).to.equal('Whisky: woooooow!'); }); it('should instantiate a wolf', () => { var wolf = new Wolf('Direwolf'); expect(wolf.bark()).to.equal('Direwolf: woooooow!'); }); }); 默认如果你只有一个项目要导出，你可以使用export default来将你需要导出的项目作为一个对象 // cat.js export default class Cat { constructor(name) { this.name = name; } meow() { return `${this.name}: You gotta be kidding that I'll obey you, right?`; } } 导入默认的模块更简单，至于结构赋值就不再用到了，你可以直接从模块中导入 // cat_spec.js import { expect } from 'chai'; import Cat from '../src/cat'; describe('the cat module', () => { it('should instantiate a cat', () => { var cat = new Cat('Bugsy'); expect(cat.meow()).to.equal('Bugsy: You gotta be kidding that I\\'ll obey you, right?'); }); }); 学习更多关于ES2015模块的知识，查看文章Exploring ES6 — Modules. ES2015模块加载器和System.js惊奇的发现，ES2015实际上没有一个模块加载规范。这儿是一个非常受欢迎的对动态模块加载的提议–es6-module-loader–受System.js的启发。这个提议已经被撤回了，但是有个WhatWG在讨论阶段的新的加载规范和Domenic Denicola提出的动态导入规范。 然而，System.js目前是最常使用的支持ES2015的模块加载器实现之一，它支持ES2015，AMD，CommonJS和浏览器中的全局脚本，还有NodeJS。它提供了一个异步模块加载器（对比Require.js）和ES2015转换，通过Babel,Traceur或者Typescript。 System.js使用Promises-based API实现了异步模块加载。自从promises可以被链式调用和组合，这是非常长强大和方便的方法。举个例子，如果你想平行的加载多个模块，你可以使用Promises.all，当所有promises都被解决后，listener就可以被解除了。 最后，动态导入规范正在得到更多的牵引，而且已经被编入webpack 2。你可以看看它在webpack2指南上是如何工作的Code splitting with ES2015，这也是受system.js的启发，所以过度起来也很简单。 同步和异步导入模块为了以同步和异步两种方式说明模块的加载，这里有一个简单的项目，将会在页面加载的时候同步加载我们的Cat模块，在用户点击按钮的时候懒加载Zoo模块。代码的github地址lazy-load-es2015-systemjs。 让我们看一看主要的代码块中在页面加载时加载的代码，我们的main.js。 首先，注意通过import同步加载Cat时的表现，然后，创建了一个Cat的实例，调用它的方法meow()，然后添加结果到DOM中： // main.js // Importing Cat module synchronously import Cat from 'cat'; // DOM content node let contentNode = document.getElementById('content'); // Rendering cat let myCat = new Cat('Bugsy'); contentNode.innerHTML += myCat.meow(); 最后，注意通过System.import(&#39;zoo&#39;)异步导入Zoo，最后，Dog和Wolf分别调用他们的方法back()，再次将结果添加到DOM中： // Button to lazy load Zoo contentNode.innerHTML += `&lt;p>&lt;button id='loadZoo'>Lazy load &lt;b>Zoo&lt;/b>&lt;/button>&lt;/p>`; // Listener to lazy load Zoo document.getElementById('loadZoo').addEventListener('click', e => { // Importing Zoo module asynchronously System.import('zoo').then(Zoo => { // Rendering dog let myDog = new Zoo.Dog('Sherlock', 'beagle'); contentNode.innerHTML += `${myDog.bark()}`; // Rendering wolf let myWolf = new Zoo.Wolf('Direwolf'); contentNode.innerHTML += `&lt;br/>${myWolf.bark()}`; }); }); 结论掌握遵守页面加载最少必须加载和懒加载可延迟加载的模块可以明显的提升你的页面性能，AMD和CommonJS为ES2015模块铺路。你可以开始使用System.js加载ES2015模块，或者通过webpack 2使用动态导入规范。但是官方的解决方案至今还未发布。 referencelazy-loading-es2015-modules-in-the-browser","tags":[{"name":"ES2015","slug":"ES2015","permalink":"http://dearxiaojie.top/tag/ES2015/"}]},{"title":"8个npm常用技巧和简写","date":"2017-06-03T09:17:15.000Z","path":"article/2017-06-03-several-npm-shorthand-or-trick.html","text":"在篇文章里,将介绍一些非常有用的npm技巧。在这有许多我们不能完全覆盖,所以主要介绍和我们开发工作最相关和最有用的技巧。 最基本的一些简写为了大家在同一起跑线，特别是针对于我们的新手，下面先快速的复习一些基本的简写来保证没人忘记任何简单的东西。 安装package常规：npm install pkg 简写：npm i pkg 全局安装常规： npm install --global pkg 简写：npm i -g pkg 作为项目依赖常规：npm install --save pkg 简写： npm i -S pkg 作为开发依赖常规： npm install --save-dev pkg 简写： npm i -D pkg 更多的简写请查看npm的简写表接下来开始有趣的东西。 初始化一个package我们都知道使用npm init，这是我们创建一个package需要做的第一步。但是，在默认情况下，我们会不停的敲enter键，所以我们怎么避免呢。npm init -y 或 npm init -f就可以一次搞定。 测试命令另一个我们都会的命令是npm test，基本上每天都会使用很多次。倘若我告诉你减少约40%的字符后可以做同样的事呢？非常幸运，这里有个命令npm t，确实能够做到。 列举可用的脚本我们得到了一个新项目,不知道如何开始。通常想知道：如何运行它?哪些脚本可用?有一种方式是打开package.json文件，查看scripts部分。但是我们可以做的更好，所以我们可以简单的运行npm run，之后就可以获得可用脚本的列表。另一个方式是安装ntl(npm i -g ntl)，然后在项目根目录运行ntl，就会列举出可用脚本，并可以直接选择运行，非常方便。 列举已安装的packages类似于可用的脚本,有时候我们需要知道在我们的项目的依赖关系。再次的，我们可以打开package.json文件查看。但是我们已经知道我们可以做的更好，那就是npm ls --depth 0如果需要列出全局安装的packages，我们运行同样的命令加上-g标志。npm ls -g --depth 0 运行安装的可执行文件我们安装了一个包在我们的项目中,它带有一个可执行的文件,但只有通过npm脚本运行它。你想知道为什么,或者如何克服它吗?首先，我们理解为什么–当我们在我们终端执行命令的时候，其根本其实是在我们PATH环境变量中列举的路径中寻找同名的可执行文件。这就是他们可从任何地方访问的神奇之处。本地安装包在本地注册他们的可执行文件,所以他们没有列在我们的PATH中，也就不会被发现。当我们通过一个npm脚本运行可执行文件，它是如何工作的？好问题！因为这种方式运行时,是npm的一个小技巧,增加了一个额外的文件夹路径&lt;project-directory&gt;/node_modules/.bin到PATH，npm添加了一些更有趣的东西，你可以通过运行npm run env | grep &quot;$PATH&quot;看见它。你也可以只是运行npm run env来查看所有可用的环境变量。如果你想知道，node_modules/.bin巧好是本地安装包存放他们可执行文件的地方。例如，如果在你的项目中安装了mocha，直接在项目中运行./node_modules/.bin/mocha看有什么动作so easy,对吧？无论何时你想运行一个本地安装包的可执行文件，只需要运行./node_modules/.bin/&lt;command&gt; 在网上找你的package在package.json文件中，你可能会看到repository的入口(‘entry’)，想知道它有什么好处呢？要回答这个问题，只需要运行npm repo就可以在你的浏览器中看到。顺便说一下,npm home命令和npm homepage同样适用,如果你想在npmjs打开你的package，这里也有个不错的简写npm docs 在其他脚本前后运行脚本也许你熟悉某些脚本例如pretest,这个允许你定义在test脚本运行前运行的代码。你可能会惊讶地发现,你可以为每一个脚本增加预先和滞后执行的脚本,包括您自己的自定义脚本!对于使用npm作为构建工具和有很多脚本需要编排的项目来说，是非常有用的。 更换package的版本你有一个package，也许使用semver做版本控制，在一个新版本发布前需要更换版本。一种方式是打开package.json文件手动的改变版本，但在这里我们不这样。一个简单的方式是运行npm version加上major、minor或者patch。That’s all 最后另外值得一提的是一些组合命令，如npm it将会运行安装和测试命令，等同于npm install &amp;&amp; npm test,非常方便。如果你知道更多的有用的技巧,请在评论中分享一下吧! reference8-npm-tricks-you-can-use-to-impress-your-colleaguesshorthands-and-other-cli-niceties","tags":[{"name":"npm","slug":"npm","permalink":"http://dearxiaojie.top/tag/npm/"}]},{"title":"使用Python发送HTML邮件","date":"2017-05-25T16:13:29.000Z","path":"article/2017-05-26-use-python-smtp-to-send-mail.html","text":"这段时间在慢慢学习Python，正巧有个与Python相关的活，借此机会好练练手 为什么要学习Python呢，作为一个前端，为什么不学习nodejs，而选择学习Python，对呀，其实我也这么问自己，但是，有什么影响嘛，爱学啥学啥，我不觉得啥该学不该学。学了如果不用，也慢慢会忘。扯远了，其实我是比较喜欢Python的语法和它的严格缩进，学了一段时间后，发现还是有和es6/es7相似的方法。 SMTPSMTP是发送邮件的协议，Python内置对SMTP的支持，可以发送纯文本、HTML邮件。其中有两个用到的模块，email负责邮件构造，smtplib发送邮件。 '''using python send gmail''' # !/usr/bin/env python3 # -*- coding: utf-8 -*- import smtplib from email.header import Header from email.mime.text import MIMEText from email.mime.multipart import MIMEMultipart from email.utils import parseaddr, formataddr class SendGmail(object): '''send mail via gmail''' def __init__(self): self._from_addr = input('From:') self._password = input('Password:') self._to_addr = input('To:') self._smtp_server = smtplib.SMTP('smtp.gmail.com', 587) self._msg = MIMEMultipart('alternative') self._msg['From'] = self._format_addrs('&lt;%s>' % self._from_addr) # 发件人 self._msg['To'] = self._format_addrs('&lt;%s>' % self._to_addr) # 收件人 subject = 'hello python' self._msg['Subject'] = Header(subject, 'utf-8').encode() # 主题 def get_content(self, mail_tmp_path='mail.html'): '''get mail content''' page = mail_tmp_path file = open(page, 'r', encoding='utf8') content = file.read() content = content.replace('&lt;#send_name#>', self._from_addr) content = content.replace('&lt;#name#>', self._to_addr) self._msg.attach(MIMEText(content, 'html', 'utf-8')) def send_mail(self): '''send mail''' server = self._smtp_server server.ehlo() server.starttls() server.login(self._from_addr, self._password) server.sendmail(self._from_addr, [self._to_addr], self._msg.as_string()) print('success send to %s!' % self._to_addr) server.quit() @classmethod def _replace_tmp(cls, string): pass @classmethod def _format_addrs(cls, string): '''format addr''' name, addr = parseaddr(string) return formataddr((Header(name, 'utf-8').encode(), addr)) if __name__ == '__main__': MESSAGE = SendGmail() MESSAGE.get_content() MESSAGE.send_mail()","tags":[{"name":"Python","slug":"Python","permalink":"http://dearxiaojie.top/tag/Python/"},{"name":"SMTP","slug":"SMTP","permalink":"http://dearxiaojie.top/tag/SMTP/"},{"name":"mail","slug":"mail","permalink":"http://dearxiaojie.top/tag/mail/"}]},{"title":"使用Travis CI自动部署Hexo博客到Github上","date":"2017-05-04T15:27:53.000Z","path":"article/2017-05-04-use-travisci-build-your-hexo-site.html","text":"写在前面自从在github page上搭建博客以来，都是使用的hexo，每次都是通过hexo命令build生成静态文件，再push到github上，后来找到一个deploy插件，只需要填写好github的repos地址就好。但是源码的保存是个问题，更换电脑想要写博客很不方便，甚至蠢到将源码保存到u盘里面，这样每次提交后又要备份一次，很容易忘记。说到这里那为什么不将源码保存到github上呢。 其实也是因为懒，给博客换了几次主题后，使得博客源码很乱，甚至自己也忘了改了主题的哪些代码，加上主题也是个repos，直接提交博客源码是提不上的，涉及到子模块问题，麻烦。想到自己还喜欢改动别人的主题，索性将主题文件夹.git文件删掉，让他成为一个普通的文件夹，这样就能提交到github了。废话不多说，估计是很久没写博客了，没有重点，下面简单说说使用Travis CI自动部署Hexo博客到github上。 什么是Travis CI？ Travis CI 是目前新兴的开源持续集成构建项目，它与jenkins，GO的很明显的特别在于采用yaml格式，简洁清新独树一帜。目前大多数的github项目都已经移入到Travis CI的构建队列中，据说Travis CI每天运行超过4000次完整构建。 构建首先进入Travis CI官网，使用github账号登录，如下图登录成功后进入如下界面，以为我再此之前已经构建过，所以会用红色框内的内容，如果没有使用过是没有的。然后点击My Repositories右边的+，添加需要自动构建的repos，进入如下页面。可以看到这个界面会显示当前github账号的所以项目，如果没有显示，点击右上角的Sync account按钮，就可以同步过来了，点击需要构建的repos前面的按钮为ON，再点击其后的原形设置图标，进入如下界面如图中设置，将Build only if .travis.yml is present及另外两个设置为ON，功能如字面意思不多说。到目前为止，已经将需要构建的repos开启，那么，我们如何在将源码提交到github的时候，它就自动构建并将build后的静态文件push到我的静态文件branch或者repos呢（我是将build后的静态文件放到一个单独的repos了，也可以放在源码repos的另一个branch，例如起名叫hexo），接下来说如何让Travis CI访问github. Access Token我们需要在Travis上配置Access Token，就可以在构建完毕后自动push到github上保存静态文件的repos了。 生成Access Token登录github，进入个人主页，点击setting，进入界面后找到下图所指位置。点击Personal access tokens，进入页面后，在点击右上角Generate new token,会再次让输入github密码，然后在Token description下起一个名字，再勾选一些权限，我是全给勾选上了，在点击下面Generate token这里就不多截图了。复制生成的token码。 配置Travis CI回到Travis的setting页面，如上面图，在Environment Variables这一栏，点击Add，起一个名字到Name，将复制的token码粘贴到Value框中，到这步为止，已经完成了Travis的设置。到博客源码根目录，创建一个.travis.yml的配置文件，内容如下，附注释，注意缩进 language: node_js #设置语言 node_js: stable #设置相应的版本 install: - npm install #安装hexo及插件 script: - hexo clean #清除 - hexo g #生成 after_script: - cd ./public - git init - git config user.name \"swust-xiaoj\" #修改name - git config user.email \"swustxiaojie@163.com\" #修改email - git add . - git commit -m \"update site\" - git push --force \"https://${travis}@${GH_REF}\" master:master #travis是在Travis中配置token的名称 branches: only: - master #只监测master，可根据自己情况设置，若是存放同一个仓库，这儿可以选择存放源码的branch，如hexo env: global: - GH_REF: github.com/swust-xiaoj/tb.git #设置GH_REF，注意更改yourname 因为我是新起了一个repos来存放静态文件了，所以上面的GH_REF是对应那个repos地址，若是放同一个repos中，那这儿一般都是yourname.github.io那个仓库。到此，配置已经完成了。 创建文章我们可以创建一篇文章hexo new post use-travis-build-your-hexo-site，添加内容后，并push到github，正常情况下，进入Travis网站就可以看到已经在构建了，如图完成后，访问链接就可以看到这篇文章了。 写在后面很久没有花时间写点东西了，不管有没有价值，总是一种对知识的积累和总结，输出也意味着输入，所以以后还是将学到的东西和积累总结下，自己可以将知识梳理的同时能帮助到别人是更好的了。 更新master commit 树被清空仔细查看上面的配置文件，我们发现每次都是将 public 目录下的文件重新生成了一个git项目，然后强制覆盖提交到了 master 分支下，这就是问题的所在。为了解决这个问题，我将配置文件改为了如下的内容： after_script: - git clone https://${GH_REF} .deploy_git - cd .deploy_git - git checkout master - cd ../ - mv .deploy_git/.git/ ./public/ - cd ./public - git config user.name \"swust-xiaoj\" #修改name - git config user.email \"swustxiaojie@163.com\" #修改email - git add . - git commit -m \"Travis CI Auto Builder\" - git push --force --quiet \"https://${travis}@${GH_REF}\" master:master #travis是在Travis中配置token的名称 在 after_script 部分，我先将博客项目 clone 到本地的 .deploy_git 目录下（目录名可自定义）,然后切换到 master 分支，将 master 分支下的 .git 目录拷贝到了 public 目录下，接着继续后面的 commit 操作。 添加 commit 时间戳按照前面的方法配置 travis.yml 的内容，在 master 分支下的提交记录是这样的： Travis CI Auto Builder Travis CI Auto Builder Travis CI Auto Builder ... 看到每次的提交记录中没有提交的时间戳，所以考虑着要把 commit 的时间戳给加上。script 命令下是可以执行 shell 命令的，所以对 travis.yml 文件进行了修改。在 shell 中获取当前的时间戳，可以这样: #/bin/bash > date +\"%Y-%m-%d %H:%M\" 2018-05-05 12:13 Travis CI 中使用的linux系统在编译生成时使用的是UTC时间，这样我们在github中的提交列表中看到的提交时间就会晚8小时。我们需要在执行时将时区改为东八区。 before_install: - export TZ='Asia/Shanghai' 然后将after_script中的命令移到单独的shell文件中。最终的两个文件内容如下 > build.sh #!/bin/bash set -ev git clone https://${GH_REF} .deploy_git cd .deploy_git git checkout master cd ../ mv .deploy_git/.git/ ./public/ cd ./public git config user.name \"swust-xiaoj\" #修改name git config user.email \"swustxiaojie@163.com\" #修改email git add . git commit -m \"Travis CI Auto Builder at `date +\"%Y-%m-%d %H:%M\"`\" git push --force --quiet \"https://${travis}@${GH_REF}\" master:master #travis是在Travis中配置token的名称 > .travis.yml language: node_js node_js: stable cache: apt: true directories: - node_modules before_install: - export TZ='Asia/Shanghai' # 更改时区 - npm install hexo-cli -g - chmod +x ./build.sh # 为shell文件添加可执行权限 install: - npm install script: - hexo clean - hexo g after_script: - ./build.sh branches: only: - master env: global: - GH_REF: github.com/swust-xiaoj/swust-xiaoj.github.io.git 参考 Customizing the Build IT 范儿 | 使用Travis CI自动部署Hexo博客","tags":[{"name":"hexo","slug":"hexo","permalink":"http://dearxiaojie.top/tag/hexo/"}]},{"title":"Show 'Search' button in iPhone/iPad Safari keyboard","date":"2016-10-23T09:36:09.000Z","path":"article/2016-10-23-search-btn.html","text":"问题描述点击搜索框的时候，需要将软键盘的return go 前往 按键文案变成 搜索或 search，并且点击的时候发起搜索。实现方式是将input框type 设置成 search，并在外层套一个form，在一般浏览器如QQ浏览器，uc浏览器等上能将软键盘显示成搜索,但是在safari浏览器上并不能正常将软键盘文案改变。 解决办法在form上设置action,并将其值设置成.,但是需要控制在搜索的时候应将表单默认行为拦截，form上添加return false即可。 源代码&lt;!-- 搜索框 --> &lt;form class=\"search-top\" action=\".\"> &lt;div class=\"search-wrap\"> &lt;input type=\"search\" name='key' id='search-input' placeholder=\"keyword...\" autocapitalize=\"off\" autocomplete=\"off\" autocorrect=\"off\" > &lt;span class=\"search\">&lt;i class=\"icon-search\">&lt;/i>&lt;/span> &lt;i class=\"icon-reset reset\">&lt;/i> &lt;/div> &lt;div class=\"cancel-btn\">取消&lt;/div> &lt;/form> $('.search-top').on('submit', function (e) { var text = $('#search-input').val().trim(); text &amp;&amp; that.emit.emit('search', text); return false; }); reference Show ‘Search’ button in iPhone/iPad Safari keyboard","tags":[{"name":"CSS","slug":"CSS","permalink":"http://dearxiaojie.top/tag/CSS/"}]},{"title":"Gulp Connect发送post请求返回405","date":"2016-04-10T13:29:57.000Z","path":"article/2016-04-10-Gulp Connect发送post请求返回405.html","text":"问题在使用gulp过程中，遇到了在使用gulp-connect启动服务的时候，发送ajax请求不能发送post，返回错误: 405 Method Not Allowed 解决通过自定义一个中间件来完成POST、PUT、DELETE 请求。首先，引入fs、path和connect var fs = require('fs'), path = require('path'), connect = require('gulp-connect'); 接着，在配置中增加自己的中间件。 gulp.task('server',function(){ connect.server({ middleware: function(connect, options) { return [ function(req, res, next) { var filepath = path.join(options.root, req.url); if ('POSTPUTDELETE'.indexOf(req.method.toUpperCase()) > -1 &amp;&amp; fs.existsSync(filepath) &amp;&amp; fs.statSync(filepath).isFile()) { return res.end(fs.readFileSync(filepath)); } return next(); } ]; }, hostname: '127.0.0.1', port: 8090, livereload: true }); }); References让 Gulp Connect 支持 POST、PUT、DELETE 请求","tags":[{"name":"gulp","slug":"gulp","permalink":"http://dearxiaojie.top/tag/gulp/"}]},{"title":"删除node_modules不成功","date":"2015-11-23T11:11:31.000Z","path":"article/2015-11-23-删除node-modules不成功.html","text":"Question Windows做Node.js开发的你或许碰到过无法删除node_modules文件夹的情况,如下图： Reasonwindows 在文件目录的长度有限制，因为node packages 有众多dependencies，每一个dependency又有其他的dependency，这些dependency或许还有其他的dependency，所以导致node_modules有超级复杂的文件目录。比如： D:\\codetest\\node_modules\\edpx-mobile\\node_modules\\edp-webserver\\node_modules\\babel\\node_modules\\chokidar\\node_modules\\anymatch\\node_modules Solutioninstallnpm install -g rimraf deleterimraf node_modules 亲测有效","tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://dearxiaojie.top/tag/nodejs/"}]},{"title":"remove white space below image","date":"2015-10-20T10:23:18.000Z","path":"article/2015-10-20-remove-white-space-below-image.html","text":"最近遇到过关于&lt;img&gt;标签显示一张图片在一个&lt;div&gt;里面，&lt;div&gt;的宽高由image撑起。可是在图片的底部和&lt;div&gt;底部之间，多出神秘的2~3px的空白。如下图：我知道&lt;img&gt;是个特殊的元素，为什么会出现这种现象？ Reason&lt;img&gt; 元素在默认情况下是inline元素，inline元素默认和父级元素的baseline对齐的，而baseline又和父级底边有一定距离，注意下面两段文字。 Look at this line of text. Notice there are no letters that breach the baseline 另一段： By just crossing the bridge he probably got away. 注意比较上面两段文字中字母y,j,p,g,下图更形象的显示因为浏览器提供空间低于inline元素来适应字体。这就是上面出现的白边。这不是CSS的padding或margin,所以开发中不容易发现。 Solution 给&lt;img&gt;元素设置display:block 给&lt;img&gt;元素设置vertical-align:bottom或者vertical-align:top 给&lt;img&gt;元素设置font-size:0; vertical-align:middle; 给&lt;div&gt;元素设置line-height:0 给&lt;div&gt;元素设置font-size:0 给&lt;img&gt;元素设置vertical-align:text-bottom 以上最后一条效果并不好，设置后仍有1px的白边，如下图：而正常处理后是没有白边的，如下图： Code source源码与在线演示 References Mystery white space underneath image tag How to Remove the Space Below Images and Other Inline-Block Elements Remove white space below image 欢迎补充","tags":[{"name":"CSS","slug":"CSS","permalink":"http://dearxiaojie.top/tag/CSS/"}]},{"title":"CSS伪元素::after提示用法","date":"2015-09-05T11:40:37.000Z","path":"article/2015-09-05-CSS伪元素-after.html","text":"概述CSS伪元素::after用来匹配已选中元素的一个虚拟的最后子元素，通常会配合content属性来为该元素添加装饰内容.这个虚拟元素默认是行内元素 语法 element:after { style properties } / CSS2 语法 /element::after { style properties } / CSS3 语法 / ::after表示法是在CSS 3中引入的,::符号是用来区分伪类和伪元素的.支持CSS3的浏览器同时也都支持CSS2中引入的表示法:after. ##例子 用::after伪元素，attr()CSS表达式和一个自定义数据属性 data-descr 创建一个纯CSS, 词汇表提示工具 &lt;body> &lt;p>这是一段并没有什么用的 &lt;span data-descr='collection of words and punctuation'>文字&lt;/span> ，完全是为了凑数才出现的文字，实现一个 &lt;span data-descr='small popups which also hide again'>提示&lt;/span> 功能，可以吧鼠标放上去 &lt;span data-descr='not to be taken literrlly'>看看&lt;/span> &lt;/p> &lt;/body> span[data-descr] { position: relative; text-decoration: underline; color: #00F; cursor: help; } span[data-descr]:hover::after { content: attr(data-descr); position: absolute; left: 0; top: 24px; min-width: 200px; border: 1px #aaaaaa solid; border-radius: 10px; background-color: #ffffcc; padding: 12px; color: #000000; font-size: 14px; z-index: 1; } 在线演示 效果图 浏览器兼容性 References ::after (:after)","tags":[{"name":"CSS","slug":"CSS","permalink":"http://dearxiaojie.top/tag/CSS/"}]},{"title":"图解Javascript上下文与作用域","date":"2015-08-04T06:54:54.000Z","path":"article/2015-08-04-图解Javascript上下文与作用域.html","text":"本文尝试阐述Javascript中的上下文与作用域背后的机制，主要涉及到执行上下文（execution context）、作用域链（scope chain）、闭包（closure）、this等概念。 Execution context执行上下文（简称上下文）决定了Js执行过程中可以获取哪些变量、函数、数据，一段程序可能被分割成许多不同的上下文，每一个上下文都会绑定一个变量对象（variable object），它就像一个容器，用来存储当前上下文中所有已定义或可获取的变量、函数等。位于最顶端或最外层的上下文称为全局上下文（global context），全局上下文取决于执行环境，如Node中的global和Browser中的window：需要注意的是，上下文与作用域（scope）是不同的概念。Js本身是单线程的，每当有function被执行时，就会产生一个新的上下文，这一上下文会被压入Js的上下文堆栈（context stack）中，function执行结束后则被弹出，因此Js解释器总是在栈顶上下文中执行。在生成新的上下文时，首先会绑定该上下文的变量对象，其中包括arguments和该函数中定义的变量；之后会创建属于该上下文的作用域链（scope chain），最后将this赋予这一function所属的Object，这一过程可以通过下图表示： this上文提到this被赋予function所属的Object，具体来说，当function是定义在global对中时，this指向global；当function作为Object的方法时，this指向该Object： var x = 1; var f = function(){ console.log(this.x); } f(); // -> 1 var ff = function(){ this.x = 2; console.log(this.x); } ff(); // -> 2 x // -> 2 var o = {x: \"o's x\", f: f}; o.f(); // \"o's x\" Scope chain上文提到，在function被执行时生成新的上下文时会先绑定当前上下文的变量对象，再创建作用域链。我们知道function的定义是可以嵌套在其他function所创建的上下文中，也可以并列地定义在同一个上下文中（如global）。作用域链实际上就是自下而上地将所有嵌套定义的上下文所绑定的变量对象串接到一起，使嵌套的function可以“继承”上层上下文的变量，而并列的function之间互不干扰： var x = 'global'; function a(){ var x = \"a's x\"; function b(){ var y = \"b's y\"; console.log(x); }; b(); } function c(){ var x = \"c's x\"; function d(){ console.log(y); }; d(); } a(); // -> \"a's x\" c(); // -> ReferenceError: y is not defined x // -> \"global\" y // -> ReferenceError: y is not defined Closure如果理解了上文中提到的上下文与作用域链的机制，再来看闭包的概念就很清楚了。每个function在调用时会创建新的上下文及作用域链，而作用域链就是将外层（上层）上下文所绑定的变量对象逐一串连起来，使当前function可以获取外层上下文的变量、数据等。如果我们在function中定义新的function，同时将内层function作为值返回，那么内层function所包含的作用域链将会一起返回，即使内层function在其他上下文中执行，其内部的作用域链仍然保持着原有的数据，而当前的上下文可能无法获取原先外层function中的数据，使得function内部的作用域链被保护起来，从而形成“闭包”。看下面的例子： var x = 100; var inc = function(){ var x = 0; return function(){ console.log(x++); }; }; var inc1 = inc(); var inc2 = inc(); inc1(); // -> 0 inc1(); // -> 1 inc2(); // -> 0 inc1(); // -> 2 inc2(); // -> 1 x; // -> 100 执行过程如下图所示，inc内部返回的匿名function在创建时生成的作用域链包括了inc中的x，即使后来赋值给inc1和inc2之后，直接在global context下调用，它们的作用域链仍然是由定义中所处的上下文环境决定，而且由于x是在function inc中定义的，无法被外层的global context所改变，从而实现了闭包的效果： this in closure我们已经反复提到执行上下文和作用域实际上是通过function创建、分割的，而function中的this与作用域链不同，它是由执行该function时当前所处的Object环境所决定的，这也是this最容易被混淆用错的一点。一般情况下的例子如下： var name = \"global\"; var o = { name: \"o\", getName: function(){ return this.name } }; o.getName(); // -> \"o\" 由于执行o.getName()时getName所绑定的this是调用它的o，所以此时this == o；更容易搞混的是在closure条件下： var name = \"global\"; var oo = { name: \"oo\", getNameFunc: function(){ return function(){ return this.name; }; } } oo.getNameFunc()(); // -> \"global\" 此时闭包函数被return后调用相当于： getName = oo.getNameFunc(); getName(); // -> \"global\" 换一个更明显的例子： var ooo = { name: \"ooo\", getName: oo.getNameFunc() // 此时闭包函数的this被绑定到新的Object }; ooo.getName(); // -> \"ooo\" 当然，有时候为了避免闭包中的this在执行时被替换，可以采取下面的方法： var name = \"global\"; var oooo = { name: \"ox4\", getNameFunc: function(){ var self = this; return function(){ return self.name; }; } }; oooo.getNameFunc()(); // -> \"ox4\" 或者是在调用时强行定义执行的Object： var name = \"global\"; var oo = { name: \"oo\", getNameFunc: function(){ return function(){ return this.name; }; } } oo.getNameFunc()(); // -> \"global\" oo.getNameFunc().bind(oo)(); // -> \"oo\" 总结Js是一门很有趣的语言，由于它的很多特性是针对HTML中DOM的操作，因而显得随意而略失严谨，但随着前端的不断繁荣发展和Node的兴起，Js已经不再是”toy language”或是jQuery时代的”CSS扩展”，本文提到的这些概念无论是对新手还是从传统Web开发中过度过来的Js开发人员来说，都很容易被混淆或误解，希望本文可以有所帮助。 写这篇总结的原因是我在Github上分享的Learn javascript in one picture，刚开始有人质疑这只能算是一张语法表（syntax cheat sheet），根本不会涉及更深层的闭包、作用域等内容，但是出乎意料的是这个项目竟然获得3000多个star，所以不能虎头蛇尾，以上。 References Understanding Scope and Context in JavaScript this - JavaScript | MDN 闭包 - JavaScript | MDN 原文猛戳","tags":[{"name":"javascript","slug":"javascript","permalink":"http://dearxiaojie.top/tag/javascript/"},{"name":"概念理解","slug":"概念理解","permalink":"http://dearxiaojie.top/tag/概念理解/"}]},{"title":"javascript性能优化小知识","date":"2015-07-27T02:22:26.000Z","path":"article/2015-07-27-javascript性能优化小知识.html","text":"前面有一篇也是关于javascript性能方面的文章，是看了《高性能javascript》后的笔记，这是一篇自己在项目和学习过程中的积累，部分参考了一些学习博客。对面试和代码的编写都有帮助。 避免全局查找在一个函数中会用到全局对象存储为局部变量来减少全局查找，因为访问局部变量的速度要比访问全局变量的速度更快些。 字符串的连接如果要连接多个字符串，应该少使用+=，如 s+=a; s+=b; s+=c; 应该写成s+=a + b + c；而如果是收集字符串，比如多次对同一个字符串进行+=操作的话，最好使用一个缓存，使用JavaScript数组来收集，最后使用join方法连接起来。 数字转换成字符串(&quot;&quot; +) &gt; String() &gt; .toString() &gt; new String()字符串如’1322’转换成数字的时候可以在前面加’+’,如var str = &#39;123&#39;;var num = +str,那么typeof num为number 浮点数转换成整型很多人喜欢使用parseInt()，其实parseInt()是用于将字符串转换成数字，而不是浮点数和整型之间的转换，我们应该使用Math.floor()或者Math.round()。 使用DocumentFragment优化多次append一旦需要更新DOM,请考虑使用文档碎片来构建DOM结构，然后再将其添加到现存的文档中。 for (var i = 0; i &lt; 1000; i++) { var el = document.createElement('p'); el.innerHTML = i; document.body.appendChild(el); } //可以替换为： var frag = document.createDocumentFragment(); for (var i = 0; i &lt; 1000; i++) { var el = document.createElement('p'); el.innerHTML = i; frag.appendChild(el); } document.body.appendChild(frag); 使用一次innerHTML赋值代替构建dom元素对于大的DOM更改，使用innerHTML要比使用标准的DOM方法创建同样的DOM结构快得多。 var frag = document.createDocumentFragment(); for (var i = 0; i &lt; 1000; i++) { var el = document.createElement('p'); el.innerHTML = i; frag.appendChild(el); } document.body.appendChild(frag); //可以替换为： var html = []; for (var i = 0; i &lt; 1000; i++) { html.push('&lt;p>' + i + '&lt;/p>'); } document.body.innerHTML = html.join(''); 使用事件代理任何可以冒泡的事件都不仅仅可以在事件目标上进行处理，目标的任何祖先节点上也能处理，使用这个知识就可以将事件处理程序附加到更高的地方负责多个目标的事件处理，同样，对于内容动态增加并且子节点都需要相同的事件处理函数的情况，可以把事件注册提到父节点上，这样就不需要为每个子节点注册事件监听了。另外，现有的js库都采用observe方式来创建事件监听,其实现上隔离了DOM对象和事件处理函数之间的循环引用,所以应该尽量采用这种方式来创建事件监听 缩短否定检测if (oTest != '#ff0000') { //do something } if (oTest != null) { //do something } if (oTest != false) { //do something } //虽然这些都正确，但用逻辑非操作符来操作也有同样的效果： if (!oTest) { //do something } 条件分支将条件分支，按可能性顺序从高到低排列：可以减少解释器对条件的探测次数在同一条件子的多（&gt;2）条件分支时，使用switch优于if：switch分支选择的效率高于if，在IE下尤为明显。4分支的测试，IE下switch的执行时间约为if的一半。使用三目运算符替代条件分支 if (a > b) { num = a; } else { num = b; } //可以替换为： num = a > b ? a : b; 续。。。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://dearxiaojie.top/tag/javascript/"},{"name":"性能优化","slug":"性能优化","permalink":"http://dearxiaojie.top/tag/性能优化/"}]},{"title":"jQuery常用方法归纳","date":"2015-06-26T17:16:35.000Z","path":"article/2015-06-27-jQuery常用方法归纳总结.html","text":"$.grep()$.grep( array, function(elementOfArray, indexInArray) [, invert ] ) 功能：查找满足过滤函数的数组元素： &lt;script src=\"js/jquery1.42.min.js\">&lt;/script> &lt;script type=\"text/javascript\"> $(function () { var arr = [23,45,5,1,4,67,8,100,-2]; var arrGrep = $.grep(arr, function (element,index) { return (index&lt;5)&amp;&amp;(element != 4);//整体返回一个数组 }) alert(arrGrep);//23,45,5,1 }) &lt;/script> $.map() $.map( array, callback(elementOfArray, indexInArray) ) 功能：将一个数组中的所有元素转换到另一个数组中。 &lt;script src=\"js/jquery1.42.min.js\">&lt;/script> &lt;script type=\"text/javascript\"> $(function () { var arr = [5,1,4,67,8,100,-2]; var arrMap = $.map(arr, function (element,index) { // return (index&lt;3)&amp;&amp;(element != 4);这里按布尔值返回 if(index&lt;3 &amp;&amp; element&lt; 4){ return element; } }); alert(arrMap);//1 }) &lt;/script> mouseover()/mouserout()当鼠标进入/离开某个元素或它的后代元素时触发mouseover/mouseout事件。mouseover事件大多数时候会与 mouseout 事件一起使用。 mouseover/mouserout事件由于冒泡机制，经常在不需要的时候不小心触发，从而导致一些脚本问题。 mouseenter()/mouseleave()mouseenter/mouseleave当且仅当鼠标进入被选元素时才触发，当鼠标穿过任何子元素时不会触发。它不关心目标元素是否有子元素。 focusin()和focusout().focusin()：一个元素或它的子元素得到焦点时触发此事件.focusout()：一个元素或它的子元素失去焦点时触发此事件 与 focus() 方法不同的是，focusin() 方法在任意子元素获得焦点时也会触发。 &lt;body> &lt;p>&lt;input type=\"text\"> &lt;span>focusin fire&lt;/span>&lt;/p> &lt;p>&lt;input type=\"password\"> &lt;span>focusin fire&lt;/span>&lt;/p> &lt;script> $( \"p\" ).focusin(function() { $( this ).find( \"span\" ).css( \"display\", \"inline\" ).fadeOut( 1000 ); }); &lt;/script> &lt;/body> eq()和get().get()： 通过jQuery对象获取一个对应的DOM元素。.eq()：从集合的一个元素中构造新的jQuery对象 eq返回的是一个jQuery对象，get返回的是一个DOM对象。举个例子： $( \"li\" ).get( 0 ).css(\"color\", \"red\"); //错误 $( \"li\" ).eq( 0 ).css(\"color\", \"red\"); //正确 那么，什么是DOM对象，什么又是jQuery对象呢？ DOM对象就是用js获得的对象，而juqery对象是用jQuery类库的选择器获得的对象。 如： var $obj = $(\"div\");//jQuery对象 get方法本质上是把jQuery对象转换成DOM对象，但是css属于jQuery构造器的，DOM是不存在这个方法的，如果需要用jQuery的方法，我们必须这样写： var li = $(\"li\").get(0); $(li).css(\"color\",\"black\");//用$包装 filter() filter()方法:筛选出与指定表达式匹配的元素集合。这个方法用于缩小匹配的范围。用逗号分隔多个表达式。 filter(expression)：（字符串|函数）如果参数是字符串，则制定jQuery选择器，用于从包装集里删除所有与选择器不匹配的元素，最后留下与选择器匹配的元素；如果参数是函数，则用于确定筛选条件。为包装集里的每一个元素各调用一次该函数，函数调用返回值为false的任何元素都会从包装集里删除。 以下代码意为：保留第一个以及带有select类的元素 HTML 代码: &lt;p>Hello&lt;/p>&lt;p>Hello Again&lt;/p>&lt;p class=\"selected\">And Again&lt;/p> jQuery 代码: $(\"p\").filter(\".selected, :first\"); 结果: &lt;p>Hello&lt;/p>, &lt;p class=\"selected\">And Again&lt;/p> 再看一个function的例子，一个函数用来作为测试元素的集合。它接受一个参数index，这是元素在jQuery集合的索引。在函数， this指的是当前的DOM元素。 HTML 代码: &lt;p>&lt;ol>&lt;li>Hello&lt;/li>&lt;/ol>&lt;/p>&lt;p>How are you?&lt;/p> jQuery 代码: $(\"p\").filter(function(index) { return $(\"ol\", this).length == 0; }); 结果: &lt;p>How are you?&lt;/p> .bind()、.live()和.delegate()方法.bind()：绑定事件处理函数的最基本方式是使用.bind()方法。它和live()方法一样，接受两个参数： .bind(event type, event handler)两种绑定事件处理函数的方法： $(document).ready(function(){ $('.mydiv').bind('click',test); function test(){ alert(\"￼Hello World!\"); } }); 事件处理函数也可以使用匿名函数，如下所示： $(document).ready(function(){ $(\"#mydiv\").bind(\"click\",function(){ alert(\"￼Hello World!\"); }) }); .live()：live方法和bind方法的唯一区别在于.live()不仅作用于DOM中当前存在的元素，还作用于将来可能存在（动态生成）的元素 $(document).ready(function(){ $('.box').live('click',function(){ $(this).clone().appendTo('.container'); }); }); &lt;div class=\"container\"> &lt;div class=\"box\">&lt;/div> &lt;/div> 使用live方法绑定事件的缺点在于它无法使用链式调用，那有没有既可以像live方法那样绑定事件，又可以支持链式调用的方法呢？答案就是下面的delegate方法。 delegate()方法：为指定的元素（属于被选元素的子元素）添加一个或多个事件处理程序，并规定当这些事件发生时运行的函数。从jQuery 1.7开始，.delegate()已经被.on()方法取代。语法： $(selector).delegate(childSelector,event type,function)参数说明： childSelector 必需。规定要附加事件处理程序的一个或多个子元素。 event 必需。规定附加到元素的一个或多个事件。由空格分隔多个事件值。必须是有效的事件。 function 必需。规定当事件发生时运行的函数。 $(document).ready(function(){ $('.container').delegate('.box','click',function(){ $(this).clone().appendTo('.container'); }); }); delegate()会在以下两个情况下使用到： 1、如果你有一个父元素，需要给其下的子元素添加事件，这时你可以使用delegate()了，代码如下： $(\"ul\").delegate(\"li\", \"click\", function(){ $(this).hide(); }); 2、当元素在当前页面中不可用时，可以使用delegate() end()方法 end()方法：在jquery命令链内调用，以便退回到前一个包装集。每次过滤方法都会被压入栈中。当我们需要返回到前一个状态时，我们可以使用end() 进行出栈操作，来返回栈中的前一个状态。 end() 方法结束当前链条中的最近的筛选操作，并将匹配元素集还原为之前的状态。 &lt;head> &lt;meta http-equiv=\"Content-Type\" content=\"text/html;charset=UTF-8\" /> &lt;title>&lt;/title> &lt;script src=\"http://libs.baidu.com/jquery/1.9.0/jquery.js\">&lt;/script> &lt;/head> &lt;body> &lt;ul class=\"one\"> &lt;li class=\"two\">item 1&lt;/li> &lt;li>item 2&lt;/li> &lt;li class=\"three\">item 3&lt;/li> &lt;/ul> &lt;script type=\"text/javascript\"> $('ul.one').find(\".two\").css(\"color\",\"red\").find('.three').css(\"background\",\"blue\"); &lt;/script> 在上面的代码例子中，我们只会看到item 1的字体颜色改变了，而背景颜色没有改变。这是因为第二个find()方法之前的状态返回的是红色字体的class值为two的对象，因此，第二次find()只会查找&lt;ul class=&quot;one&quot;&gt; 中的.two，使用end()方法修改该链式操作的代码如下： &lt;script type=\"text/javascript\"> $('ul.one').find(\".two\").css(\"color\",\"red\").end().find('.three').css(\"background\",\"blue\"); &lt;/script> end()方法在这里是 返回调用 find() 之前的状态，也就是$(&#39;ul.one&#39;) toggleClass()toggleClass()方法：如果在元素中指定类名称不存在，则添加指定类名称；如果元素已经拥有指定类名称，则从元素中删除指定类名称。css(name,value)方法：设定指定的值到每个已匹配元素的指定的css样式属性 wrap()和wrapInner()wrap()和wrapInner()：前者把所有匹配的元素用其他元素的结构化标记包裹起来；后者将每一个匹配的元素的子内容(包括文本节点)用一个HTML结构包裹起来。看下面一个wrap()的例子：用原先div的内容作为新div的class，并将每一个元素包裹起来 HTML 代码: &lt;div class=\"container\"> &lt;div class=\"inner\">Hello&lt;/div> &lt;div class=\"inner\">Goodbye&lt;/div> &lt;/div> jQuery 代码: $('.inner').wrap(function() { return '&lt;div class=\"' + $(this).text() + '\" />'; }); 结果: &lt;div class=\"container\"> &lt;div class=\"Hello\"> &lt;div class=\"inner\">Hello&lt;/div> &lt;/div> &lt;div class=\"Goodbye\"> &lt;div class=\"inner\">Goodbye&lt;/div> &lt;/div> &lt;/div> 接着再看下面一个wrapInner()的例子: 用原先div的内容作为新div的class，并将每一个元素包裹起来 HTML 代码: &lt;div class=\"container\"> &lt;div class=\"inner\">Hello&lt;/div> &lt;div class=\"inner\">Goodbye&lt;/div> &lt;/div> jQuery 代码: $('.inner').wrapInner(function() { return '&lt;div class=\"' + $(this).text() + '\" />'; }); 结果: &lt;div class=\"container\"> &lt;div class=\"inner\"> &lt;div class=\"Hello\">Hello&lt;/div> &lt;/div> &lt;div class=\"inner\"> &lt;div class=\"Goodbye\">Goodbye&lt;/div> &lt;/div> &lt;/div> detach、empty和remove方法.detach( [selector ] )：从DOM中去掉所有匹配的元素。当需要移走一个元素，不久又将该元素插入DOM时，就需要用到detach方法。 .empty()：这个方法不仅移除子元素（和其他后代元素），同样移除元素里的文本。因为，根据说明，元素里任何文本字符串都被看做是该元素的子节点。 .remove( [selector ] )：将元素从DOM中移除，同时移除元素上的事件及 jQuery 数据 empty()的例子： &lt;ul class=\"one\"> &lt;li class=\"two\">item 1&lt;/li> &lt;li>item 2&lt;/li> &lt;li class=\"three\">item 3&lt;/li> &lt;/ul> &lt;script type=\"text/javascript\"> $(\".two\").empty();//item 1 文本节点被移除，li的小圆点还在，证明li没有被移除 &lt;/script> 看下面一个remove()例子： 描述：从DOM中把所有段落删除 HTML 代码: &lt;p>Hello&lt;/p> how are &lt;p>you?&lt;/p> jQuery 代码: $(\"p\").remove(); 结果: how are val()方法val()：获得匹配元素的当前值。描述:获取文本框中的值 jQuery 代码: $(\"input\").val(); jQuery 代码: $(\"input\").val(\"hello world!\"); each()和map()each()和map()方法：each返回的是原来的数组，并不会新创建一个数组。而map方法会返回一个新的数组。如果在没有必要的情况下使用map，则有可能造成内存浪费。 each方法：定义一个空数组，通过each方法，往数组添加ID值；最后将数组转换成字符串后，alert这个值； $(function(){ var arr = []; $(\":checkbox\").each(function(index){ arr.push(this.id); }); var str = arr.join(\",\"); alert(str); }) map方法:将每个:checkbox执行return this.id；并将这些返回值，自动的保存为jQuery对象，然后用get方法将其转换成原生Javascript数组，再使用join方法转换成字符串，最后alert这个值； $(function(){ var str = $(\":checkbox\").map(function() { return this.id; }).get().join(); alert(str); }) 当有需一个数组的值的时候，用map方法，很方便。 $.each()jQuery的$(selector).each()函数可以遍历循环选中的子元素，而jQuery的$.each()函数则可以遍历任何集合，包括对象和数组，它接收要遍历的集合以及一个回调函数，回调函数每次传递一个数组的下标和这个下标所对应的数组的值。 $.each(array,callback); $.each(object,callback); 数组实例$.each( [ \"one\", \"two\", \"three\" ], function( i, l ){ alert( \"index #\" + i + \": \" + l ); }); callback(索引,索引值)DEMO： index 0: one index 1: two; index 2: three 对象实例$.each({ name: \"trigkit4\", lang: \"JS\" }, function( k, v ) { alert( \"Key: \" + k + \", Value: \" + v ); }); callback(键,值) Demo: Key: name, Value: trigkit4 Key: lang, Value: JS .trigger()描述: 根据绑定到匹配元素的给定的事件类型执行所有的处理程序和行为。 当相应的事件发生时，任何通过.on()、.bind()或一个快捷方法绑定的事件处理程序将被触发。但是，它们可以用.trigger()方法手动触发 &lt;script type=\"text/javascript\"> $(document).bind('abc',function(){ console.log('hello'); }); $(document).trigger('abc'); //Output 'hello'; &lt;/script> .attr()和.prop().attr()：获取匹配的元素集合中的第一个元素的属性的值 或 设置每一个匹配元素的一个或多个属性。 .prop()：同上jQuery 1.6之前 ，.attr()方法在取某些 attribute 的值时，会返回 property 的值，这就导致了结果的不一致。从 jQuery 1.6 开始， .prop()方法 方法返回 property 的值,而 .attr() 方法返回 attributes 的值。 例如, selectedIndex, tagName, nodeName, nodeType, ownerDocument, defaultChecked, 和 defaultSelected 应使用.prop()方法进行取值或赋值。 他们没有相应的属性（attributes），只有特性(property)。 .after()和.insertAfter().after()描述:在所有段落中后插入一个jQuery对象(类似于一个DOM元素数组)。 HTML 代码: &lt;b>Hello&lt;/b>&lt;p>I would like to say: &lt;/p> jQuery 代码: $(\"p\").after( $(\"b\") ); 结果: &lt;p>I would like to say: &lt;/p>&lt;b>Hello&lt;/b> insertAfter()描述:把所有段落插入到一个元素之后。与 $(“#foo”).after(“p”)相同 HTML 代码: &lt;p>I would like to say: &lt;/p>&lt;div id=\"foo\">Hello&lt;/div> jQuery 代码: $(\"p\").insertAfter(\"#foo\"); 结果: &lt;div id=\"foo\">Hello&lt;/div>&lt;p>I would like to say: &lt;/p> .before()和.insertBefore()before()描述:在所有段落中前插入一个jQuery对象(类似于一个DOM元素数组)。 HTML 代码: &lt;p>I would like to say: &lt;/p>&lt;b>Hello&lt;/b> jQuery 代码: $(\"p\").before( $(\"b\") ); 结果: &lt;b>Hello&lt;/b>&lt;p>I would like to say: &lt;/p> .append()和.appendTo()append()描述：向所有段落中追加一些HTML标记。 HTML 代码: &lt;p>I would like to say: &lt;/p> jQuery 代码: $(\"p\").append(\"&lt;b>Hello&lt;/b>\"); 结果: &lt;p>I would like to say: &lt;b>Hello&lt;/b>&lt;/p> appendTo()描述：新建段落追加div中并加上一个class HTML 代码: &lt;div>&lt;/div>&lt;div>&lt;/div> jQuery 代码: $(\"&lt;p/>\") .appendTo(\"div\") .addClass(\"test\") .end() .addClass(\"test2\"); 结果: &lt;div>&lt;p class=\"test test2\">&lt;/p>&lt;/div> &lt;div>&lt;p class=\"test\">&lt;/p>&lt;/div> .prepend()和.prependTo()prepend()描述：向所有段落中前置一个jQuery对象(类似于一个DOM元素数组)。 HTML 代码: &lt;p>I would like to say: &lt;/p>&lt;b>Hello&lt;/b> jQuery 代码: $(\"p\").prepend( $(\"b\") ); 结果: &lt;p>&lt;b>Hello&lt;/b>I would like to say: &lt;/p> prependTo()描述：把所有段落追加到ID值为foo的元素中。 HTML 代码: &lt;p>I would like to say: &lt;/p>&lt;div id=\"foo\">&lt;/div> jQuery 代码: $(\"p\").prependTo(\"#foo\"); 结果: &lt;div id=\"foo\">&lt;p>I would like to say: &lt;/p>&lt;/div> 总结1. .insertAfter()和.after()：在现存元素的外部，从后面插入元素 2. .insertBefore()和.before()：在现存元素的外部，从前面插入元素 3. .appendTo()和.append()：在现存元素的内部，从后面插入元素 4. .prependTo()和.prepend() ：在现存元素的内部，从前面插入元素 .data( key, value ).data()方法允许我们在DOM元素上绑定任意类型的数据, $(\"div\").data(\"test\", { first: 16, last: \"pizza!\" }); .promise( [type ] [, target ] )在 Javascript 中，有外一种异步处理模式被叫做 Promises， CommonJS 标准委员会于是发布了一个规范，就把这个 API 叫做 Promises 了。 Promise 背后的概念非常简单，有两部分: Deferreds，定义工作单元，Promises，从 Deferreds 返回的数据。Promise 不同于回调的很重要的一个点是，你可以在 Promise 状态变成执行(resolved)之后追加处理句柄。这就允许你传输数据，而忽略它是否已经被应用获取，然后缓存它，等等之类的操作，因此你可以对数据执行操作，而不管它是否已经或者即将可用。 你可以给一个 promise 追加多个处理(then())。Promise API 好玩的地方在于允许链式处理: &lt;!-- lang: js --> promise .then(doSomething) .then(doSomethingElse) .then(doSomethingMore) .catch(logError); 原文见：trigkit4","tags":[{"name":"web前端","slug":"web前端","permalink":"http://dearxiaojie.top/tag/web前端/"},{"name":"jQuery","slug":"jQuery","permalink":"http://dearxiaojie.top/tag/jQuery/"}]},{"title":"XMLHttpRequest学习笔记","date":"2015-05-29T09:16:54.000Z","path":"article/2015-05-29-XMLHttpRequest学习笔记.html","text":"对于xhr的学习后的一个例子 &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>first&lt;/title> &lt;link rel=\"stylesheet\" href=\"css/bootstrap.min.css\" /> &lt;/head> &lt;body> &lt;button id=\"btn\">请求数据&lt;/button> &lt;div id=\"myDiv\"> &lt;table class=\"table table-bordered table-condensed\"> &lt;thead> &lt;tr> &lt;th>number&lt;/th> &lt;th>title&lt;/th> &lt;th>author&lt;/th> &lt;th>year&lt;/th> &lt;th>price&lt;/th> &lt;/tr> &lt;/thead> &lt;tbody id=\"mytbody\">&lt;/tbody> &lt;/table> &lt;p>getAllResponseHeaders()&lt;/p> &lt;p id=\"pp\">&lt;/p> &lt;p>getResponseHeader(\"Last-Modified\")&lt;/p> &lt;p id=\"ppp\">&lt;/p> &lt;/div> &lt;script type=\"text/javascript\" src=\"js/jquery-1.7.2.js\">&lt;/script> &lt;script type=\"text/javascript\" src=\"js/bootstrap.min.js\">&lt;/script> &lt;script type=\"text/javascript\"> function loadXHR() { var XHR; if (window.XMLHttpRequest) { XHR = new XMLHttpRequest(); } else { XHR = new ActiveXObject(\"Microsoft.XMLHTTP\"); } XHR.open(\"GET\", \"./text/books.xml\", true); //通过 XML HTTP 加载 XML 文件 XHR.send(); XHR.onreadystatechange = function() { if (XHR.readyState == 4 &amp;&amp; XHR.status == 200) { // 4 = \"loaded\" 200 = “OK” var xmlDoc = XHR.responseXML; var txt = \"&lt;tr>\"; var x = xmlDoc.getElementsByTagName(\"book\"); for (var i = 0; i &lt; x.length; i++) { //把 XML 文件显示为 HTML 表格 txt += \"&lt;td>\" + i + \"&lt;/td>\"; xx = x[i].getElementsByTagName(\"title\"); txt += \"&lt;td>\" + xx[0].childNodes[0].nodeValue + \"&lt;/td>\"; xx = x[i].getElementsByTagName(\"author\"); txt += \"&lt;td>\" + xx[0].childNodes[0].nodeValue + \"&lt;/td>\"; xx = x[i].getElementsByTagName(\"year\"); txt += \"&lt;td>\" + xx[0].childNodes[0].nodeValue + \"&lt;/td>\"; xx = x[i].getElementsByTagName(\"price\"); txt += \"&lt;td>\" + xx[0].childNodes[0].nodeValue + \"&lt;/td>&lt;/tr>\"; } document.getElementById(\"mytbody\").innerHTML = txt; //通过 XML HTTP 进行一次 HEAD 请求 document.getElementById(\"pp\").innerHTML = XHR.getAllResponseHeaders(); //通过 XML HTTP 进行一次指定的 HEAD 请求 document.getElementById(\"ppp\").innerHTML = XHR.getResponseHeader(\"Last-Modified\"); } } } document.getElementById(\"btn\").onclick = function() { loadXHR(); } &lt;/script> &lt;/body> &lt;/html> //books.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;bookstore> &lt;book category=\"children\"> &lt;title lang=\"en\">Harry Potter&lt;/title> &lt;author>J K. Rowling&lt;/author> &lt;year>2005&lt;/year> &lt;price>29.99&lt;/price> &lt;/book> &lt;book category=\"cooking\"> &lt;title lang=\"en\">Everyday Italian&lt;/title> &lt;author>Giada De Laurentiis&lt;/author> &lt;year>2005&lt;/year> &lt;price>30.00&lt;/price> &lt;/book> &lt;book category=\"web\" cover=\"paperback\"> &lt;title lang=\"en\">Learning XML&lt;/title> &lt;author>Erik T. Ray&lt;/author> &lt;year>2003&lt;/year> &lt;price>39.95&lt;/price> &lt;/book> &lt;book category=\"web\"> &lt;title lang=\"en\">XQuery Kick Start&lt;/title> &lt;author>James McGovern&lt;/author> &lt;author>Per Bothner&lt;/author> &lt;author>Kurt Cagle&lt;/author> &lt;author>James Linn&lt;/author> &lt;author>Vaidyanathan Nagarajan&lt;/author> &lt;year>2003&lt;/year> &lt;price>49.99&lt;/price> &lt;/book> &lt;/bookstore>","tags":[{"name":"XMLHttpRequest","slug":"XMLHttpRequest","permalink":"http://dearxiaojie.top/tag/XMLHttpRequest/"}]},{"title":"web前端笔试练习","date":"2015-05-27T16:50:13.000Z","path":"article/2015-05-28-web前端笔试练习.html","text":"1.将一个32位十进制数组转化成2进制后，翻转这个2进制数，再转换成十进制数 //res1 function reverseB(num) { var bits = num.toString(2); var len = 32 - bits.length; bits = bits.split(\"\").reverse().join(\"\"); while(len--) { bits+=\"0\"; } return parseInt(bits,2); } console.log(reverseB(43261596));//964176192 //res2 function reverseBs(n){ var m = 0; for (var i = 0; i &lt; 31; i++) { m|=(n&amp;1); n >>= 1; m &lt;&lt;= 1; } m|=(n&amp;01); return m; } console.log(reverseBs(43261596));//964176192 2.罗马数组转换成十进制数字 var romObj = {I:1, V:5, X:10, L:50, C:100, D:500, M:1000}; var romanToInt = function(str) { var sum = 0; for(var i = 0; i &lt; str.length; i++) { rom1 = romObj[str.substring(i,i+1)]; rom2 = romObj[str.substring(i+1,i+2)]; if(str.substring(i+1,i+2) !== \"\" &amp;&amp; rom1 &lt; rom2) { sum += rom2 - rom1; i++; } else sum += rom1; } return sum; }; console.log(romanToInt('II')); 3.总共有n阶楼梯，每次只能上一步或者两部，要到达楼上有多少种方式分析，当列举了当n为1,2,3,4,5时得出有1,2,3,5,8种方式就是一个斐波拉契数列 var climbStairs = function(n) { var a = 1, b = 2, sum = 1; if(n == 1) return a; if(n == 2) return b; n -= 2; while(n--){ sum = a + b; a = b; b = sum; } return sum; }; console.log(climbStairs(3)); 4.给数组增加一种方法，可以去除数组中的重复项并返回数组 //fun1--hash Array.prototype.delWeight = function() { var n=[],r=[]; //n为hash表，r为临时数组 for(var i = 0; i &lt; this.length; i++) //遍历当前数组 { if (!n[this[i]]) //如果hash表中没有当前项 { n[this[i]] = true; //存入hash表 r.push(this[i]); //把当前数组的当前项push到临时数组里面 } } return r; } var arr = [1,1,1,1,1,2,2,33,4,5,6,5,6]; console.log(arr.delWeight()); //fun2--利用数组的indexOf方法 function delWeight (arr) { var result = []; for (var i = 0; i &lt; arr.length; i++) { if (result.indexOf(arr[i]) == -1) result.push(arr[i]); } return result; } 5.对不确定数量的数进行排序 function mySort() { var tags = new Array();//使用数组作为参数存储容器 for(var i = 0,len = arguments.length;i&lt;len;i++){ tags.push(arguments[i]); } tags.sort(function(a,b){ return a - b; }); return tags;//返回已经排序的数组 } var result = mySort(50,11,16,32,24,99,57,100);//传入参数个数不确定 console.info(result);//显示结果 6.用短路求值的方式求前n项和 function sumr(n) { var ans = n; ans &amp;&amp; (ans += sumr(n-1)); return ans; } console.log(sumr(5)); 7.正则表达式判断一个数是不是素数 function is_prime(x){ var r=[],s=\"\"; while(r.length&lt;x){ r.push(\"1\"); } s = r.join(\"\"); return !/^1?$|^(11+?)\\1+$/.test(s); } console.log(is_prime(5)); console.log(is_prime(10)); console.log(is_prime(13)); console.log(is_prime(60)); console.log(is_prime(99)); 8.辗转相除求最大公约数 function ff(a,b){ if (b>a) ff(b,a); return !(a%b)?b:ff(b,a%b); } console.log(ff(10,3)); 9.Json数据按照某一字段排序的方法 var stuJson = [{ name: \"daming\", age: 21, weight: 66, sex:\"boy\" }, { name: \"lisa\", age: 19, weight: 45, sex:\"girl\" }, { name: \"lili\", age: 20, weight: 50, sex:\"boy\"}]; //按age升序 stuJson.sort(function(a,b){ return a.age - b.age; }); console.log(stuJson); 10.求一个数组中的最大最小值 var arr = [32,42,12,42,21,23,56,75,3,33,53,23,36]; var min = Math.min.apply(null,arr); console.log(min); var aMax = Math.max.apply(null,arr); console.log(aMax); 11.将一个匿名函数作为函数的一个参数 function map(f,a) { var result = [], // Create a new Array i; for (i = 0; i != a.length; i++) result[i] = f(a[i]); return result; } //调用的时候实现这个引用参数函数 var re = map(function(x) {return x * x * x}, [0, 1, 2, 5, 10]); console.log(re);//[0, 1, 8, 125, 1000]. 12.字符传中的大小写相互转换 function upperToggleLower(str){ var s =\"\"; for (var i = 0, len = str.length; i&lt;len; i++) { if (str[i] &lt;= 'z' &amp;&amp; str[i] >= 'a' || str[i] &lt;= 'Z' &amp;&amp; str[i] >= 'A') { s += String.fromCharCode(str.charCodeAt(i) ^ 32); } else { s += str[i]; } } return s; } var str = 'abcdef FEDCBA' ; console.log(upperToggleLower(str));//\"ABCDEF fedcba\" 13.js快排 function quick_sort(array,l,r) { if (l &lt; r) { var i = l,j = r,x = array[l]; while (i &lt; j) { while (i &lt; j &amp;&amp; array[j] >= x) { j--; } if (i &lt; j) { array[i++] = array[j]; } while(i &lt; j &amp;&amp; array[i] &lt; x) { i++; } if (i &lt; j) { array[j--] = array[i]; } } array[i] = x; quick_sort(array,l,i -1 ); quick_sort(array,i + 1,r); } return array; } 14.给出2*n + 1 个的数字，除其中一个数字之外其他每个数字均出现两次，找到这个数字 /* * @param A: Array of integers. * @return: The single number. */ int singleNumber(vector&lt;int> &amp;A) { if (!A.size()) return 0; int a = A[0]; for(int i = 1;i&lt;A.size();i++) { a^=A[i]; } return a; } 15.给出两个整数a和b, 求他们的和, 但不能使用 + 等数学运算符。 /* * @param a: The first integer * @param b: The second integer * @return: The sum of a and b */ int aplusb(int a, int b) { int n1; do{ n1 = a ^ b; b = (a &amp; b) &lt;&lt; 1; a = n1; }while(b != 0); return n1; } 16.计算在一个 32 位的整数的二进制表式中有多少个 1. /* * @param num: an integer * @return: an integer, the number of ones in num */ int countOnes(int num) { int count = 0; while(num!=0) { num = num&amp;(num-1); count++; } return count; } 17.找到单链表倒数第n个节点，保证链表中节点的最少数量为n。 /** * Definition of ListNode * class ListNode { * public: * int val; * ListNode *next; * ListNode(int val) { * this->val = val; * this->next = NULL; * } * } * @param head: The first node of linked list. * @param n: An integer. * @return: Nth to last node of a singly linked list. */ ListNode *nthToLast(ListNode *head, int n) { if (!head) return NULL; ListNode *h,*d; h = d = head; while(--n) { h = h->next; } while(h->next!=NULL){ h = h->next; d = d->next; } return d; } 18.写出一个高效的算法来搜索 m × n矩阵中的值。 /** * 这个矩阵具有以下特性： * 1.每行中的整数从左到右是排序的。 * 2.每行的第一个数大于上一行的最后一个整数。 * @param matrix, a list of lists of integers * @param target, an integer * @return a boolean, indicate whether matrix contains target */ bool searchMatrix(vector&lt;vector&lt;int> > &amp;matrix, int target) { if(!matrix.size()) return false; int i,j; for(i = 0; i &lt; matrix.size(); i++) { if(target &lt; matrix[i][0]) break; if(target == matrix[i][0]) return true; } i--; for(j = 0;j &lt; matrix[i].size();j++) if(target == matrix[i][j]) return true; return false; } 19.设计一种方法，将一个字符串中的所有空格替换成 %20 。 /** * 你可以假设该字符串有足够的空间来加入新的字符，且你得到的是“真实的”字符长度 * @param string: An array of Char * @param length: The true length of the string * @return: The true length of new string */ int replaceBlank(char string[], int length) { // Write your code here int space_cnt = 0; int new_length = 0; char *p,*q; for(int i = 0; i &lt; length; i++) { if (string[i] == ' ') space_cnt++; } new_length = space_cnt * 2 +length; p = string + (length - 1); q = string + (new_length - 1); while(p != q) { if(*p == ' ') *q = '0',q--,*q = '2',q--,*q = '%'; else *q = *p; p--; q--; } return new_length; } 20.统计一个字符串中每个单词的个数 /** *@param {string} str 输入的字符串 *@return {Object} o 单词及对应数量 */ function countWordNum(str) { if (!str) return ; var wordsArr = str.split(' '); var o = {}; for (var i = 0, len = wordsArr.length; i &lt; len; i++){ if (wordsArr[i] in o) { //or if (o[wordsArr[i]]) { or if (o.hasOwnProperty(wordsArr[i])) { o[wordsArr[i]]++; } else { o[wordsArr[i]] = 1; } } return o; } 21.给你六种面额 1、5、10、20、50、100 元的纸币，假设每种币值的数量都足够多，编写程序求组成N元（N为0~10000的非负整数）的不同组合的个数 public class changeDP { static int v [] = {1, 5, 10, 20, 50, 100}; public static int change (int n, int i){ if (n &lt; 0) return 0; if (n == 0) return 1; if (i &lt; 0) return 0; return change(n,i-1)+change(n-v[i],i); } public static void main (String[] args){ System.out.println(change(100,v.length-1)); } } 22.给定非空整型数组 arr 和整数 limit ，两次从 arr 中随机抽取元素（可能抽到同一个元素），获得整数 x ,y ，得到和 s = x + y 。求所有不超过 limit 的 s 值中的最大数。 function limitedMaxSum(arr, limit) { var max = 0; for (var i = 0, len = arr.length; i &lt; len; i++) { for(var j = 0; j &lt; len; j++) { var sum = arr[i] + arr[j]; if (sum &lt;= limit &amp;&amp; sum >= max) { max = sum; } } } return max; } 持续更新ing…","tags":[{"name":"web前端","slug":"web前端","permalink":"http://dearxiaojie.top/tag/web前端/"},{"name":"笔试","slug":"笔试","permalink":"http://dearxiaojie.top/tag/笔试/"}]},{"title":"CSS选择器","date":"2015-05-26T05:17:00.000Z","path":"article/2015-05-26-CSS选择器.html","text":"层次选择器 $(&quot;body &gt; div&quot;) body中子元素中的div $(&quot;#one + div&quot;) id为one的下一个紧挨着的div(兄弟) $(&quot;#two ~ div&quot;) id为two的后面的所有div(兄弟) 拓展 $(&quot;#one&quot;).sibling(&quot;div&quot;) id为one的所有div兄弟元素 $(&quot;#one&quot;).nextAll(&quot;span&quot;) id为one的后面所有span元素 $(&quot;#one&quot;).prevAll(&quot;div&quot;) id为one的前面的所有的div $(&quot;#one&quot;).nextAll(&quot;span:first&quot;) id为one的后面所有span元素的第一个 过滤选择器：以”:”开头 $(&quot;div:first&quot;) 第一个div $(&quot;div:last&quot;) 最后一个div $(&quot;div:not(.one)&quot;) class不为one的div $(&quot;div:even&quot;) 索引值偶数div $(&quot;div:odd&quot;) 索引值奇数div $(&quot;div:gt(3)&quot;) 索引值大于3的div $(&quot;div:eq(3)&quot;) 索引值等于3的div $(&quot;div:lt(3)&quot;) 索引值小于3的div $(&quot;li:gt(1):lt(4)&quot;) 不是第2个到第5个，而是在第二个的基础上增加4 $(&quot;:header&quot;) 所有的标题元素 $(&quot;:animated&quot;) 正在执行动画的所有元素 内容过滤选择器 $(&quot;div:contains(&#39;ss&#39;)&quot;) 文本含有ss的div元素 $(&quot;div:empty&quot;) 文本为空的div元素 $(&quot;div:has(.mini)&quot;) 含有class为mini的所有div元素 $(div:parent)或者$(&quot;div:not(:empty)&quot;) 所有非空的div元素 可见性过滤选择器 $(&quot;div:visible&quot;) 所有可见的div $(&quot;div:hidden&quot;).show(time) 所有不可见的div元素显示，time为时间，单位为毫秒 $(&quot;input:hidden&quot;).val() 所有不可见的input元素的value 属性过滤选择器 $(&quot;div:[title]&quot;) 含有属性title的div元素 $(&quot;div:[title==&#39;test&#39;]&quot;) title属性等于test的div元素 $(&quot;div:[title!=&#39;test&#39;]&quot;) title属性不等于test的div元素，包括没有title属性的元素 $(&quot;div:[title^=&#39;te&#39;]&quot;) title属性以te开始的div元素 $(&quot;div:[title$=&#39;est&#39;]&quot;) title属性以est结束的div元素 $(&quot;div:[title*=&#39;es&#39;]&quot;) title属性值含有es的div元素 $(&quot;div:[id][title*=&#39;es&#39;]&quot;) 有id属性的div元素中的title属性值中含有es的div元素 $(&quot;div:[title][title!=&#39;test&#39;]&quot;) 含有title属性，且title属性值不为test的div元素 子元素过滤选择器（冒号前面有个空格，选取子元素需要在选取器前加空格） $(&quot;.one :nth-child(2)&quot;) class为one的第二个子元素，不是索引值为2 $(&quot;.one :first-child&quot;) class为one的第一个子元素 $(&quot;.one :last-child&quot;) class为one的最后一个子元素 $(&quot;.one :only-child&quot;) class为one的只有一个节点的节点元素 $(&quot;div.one :nth-child(2)&quot;) class为one的第二个div子元素 表单对象属性过滤选择器 $(&quot;:text:enabled&quot;).val(&quot;hello&quot;) 使所有可用的单行文本框的value值变为hello $(&quot;:text:disabled&quot;).val(&quot;hello&quot;) 设置所有不可用单行文本框value值为hello $(&quot;:checkbox[name=&#39;haha&#39;]:checked&quot;).length 多选框name为haha的被选中的个数 $(&quot;select :selected&quot;).length select的option子节点，冒号前加空格，下拉选择框的选中的长度 $(&quot;select :selected&quot;).val() 因为$(“select :selected”)选中的是一个数组，当有多个元素时，.val()获取的是第一个选中的值。","tags":[{"name":"CSS","slug":"CSS","permalink":"http://dearxiaojie.top/tag/CSS/"}]},{"title":"2015阿里web前端笔试题（部分）","date":"2015-05-25T12:14:35.000Z","path":"article/2015-05-25-2015阿里web前端笔试题（部分）.html","text":"1.给定一个随机数组，数组可能包含数组（也就是说数组元素可能为数组）。要求用js实现一个函数，返回该数组中所有元素。例如，例如：数组[2,3,[4,6,[1,8]],12,10]，返回结果为：[2,3,4,6,1,8,12,10] function getArray(arr) { var arrs = []; for(var i=0,l=arr.length;i < l;i++) { if(!Array.isArray(arr[i])) arrs.push(arr[i]); else arrs = arrs.concat( getArray(arr[i]) ); } return arrs; } 2.用js实现随机选取10–100之间的不同的10个数字，存入一个数组，并降序排序 var aArray = []; var i = 0; for (i = 0; i &lt; 10; i++) { randomNub(); } aArray.sort(function (a, b) { return b - a }); document.write(aArray) function randomNub() { var nowNub = parseInt(Math.random() * 100); if (nowNub &lt; 10) { randomNub(); return; } for (var j = 0; j &lt; aArray.length; j++) { if (nowNub == aArray[j]) { randomNub(); return; } } aArray.push(nowNub); } 3.下面代码希望在点击每段内容的时候给它加个灰色背景，可是下面这段代码好像没有满足需求，请帮忙修改下。 for (var i = 0; i &lt; document.getElementsByTagName('p').length; i++) { var item = document.getElementsByTagName('p') [i]; (function (j) { document.getElementsByTagName('p') [i].onclick = function () { item.style.backgroundColor = '#eee'; } }(i)) } //修改后 for (var i = 0; i &lt; document.getElementsByTagName('p').length; i++) { var item = document.getElementsByTagName('p') [i]; (function (j) { document.getElementsByTagName('p') [i].onclick = function () { this.style.backgroundColor = '#eee'; } }(i)) } 4.为字符串实现一个render方法，实现下面的变量替换功能 var greeting = 'my name is ${name}, age ${age}'; var result = greeting.render({name: 'XiaoMing', age: 11}); console.log(result); //my name is XiaoMing, age 11 String.prototype.render = function (Object) { var _$this = this; var keys = new Array(); for (var p in Object) if (Object.hasOwnProperty(p)) keys.push(p); for (i = 0; i &lt; keys.length; i++) { (function (index) { var s = '${' + keys[index] + '}'; str = _$this.replace(s, Object[keys[index]]); _$this = str; })(i); } return str } var greeting = 'my name is ${name}, age ${age}'; var result = greeting.render({ name: 'XiaoMing', age: 11 }); console.log(result);//my name is XiaoMing, age 11 // other: String.prototype.render = function (Object) { var _this = this; for (var p in Object) if (Object.hasOwnProperty(p)) { var s = '${' + p + '}'; str = _this.replace(s, Object[p]); _this = str; } return str } var greeting = 'my name is ${name}, age ${age}'; var result = greeting.render({ name: 'XiaoMing', age: 11 }); console.log(result); //my name is XiaoMing, age 11 5.对json格式中的某一字段进行排序 eg：var stuJson = [{ name: \"daming\", age: 21, weight: 66, sex:\"boy\" }, { name: \"lisa\", age: 19, weight: 45, sex:\"girl\" }, { name: \"lili\", age: 20, weight: 50, sex:\"boy\"}]; //eg:按age升序 stuJson.sort(function(a,b){ return a.age - b.age; }); console.log(stuJson);//[ { name: 'lisa', age: 19, weight: 45, sex: 'girl' }, //{ name: 'lili', age: 20, weight: 50, sex: 'boy' }, //{ name: 'daming', age: 21, weight: 66, sex: 'boy' } ] 6.用一句语句对数组去最小或最大值 eg:var arr = [32,42,12,42,21,23,56,75,3,33,53,23,36]; var aMin = Math.min.apply(null,arr); console.log(min);//3 var aMax = Math.max.apply(null,arr);//75 console.log(aMax);","tags":[{"name":"web前端","slug":"web前端","permalink":"http://dearxiaojie.top/tag/web前端/"},{"name":"笔试","slug":"笔试","permalink":"http://dearxiaojie.top/tag/笔试/"}]},{"title":"两个iframe框滚动条联动以及iframe窗口高宽自适应","date":"2015-05-25T12:03:05.000Z","path":"article/2015-05-25-两个iframe框滚动条联动以及iframe窗口高宽自适应.html","text":"由于iframe没有onsccoll方法，所以采用把iframe放进固定大小且带有滑动条的div中，然后先给iframe一个适合的宽度，页面加载后再让iframe窗口自适应src链接的页面。 &lt;div id=\"div1\" style=\"width:620px;height:500px ; float:left;overflow:scroll\" onscroll=\"funcsrcoll1()\"> &lt;iframe name=\"left\" id=\"left\" scrolling=\"no\" width=\"600px\" height=\"500px\" src=\"2.html\">&lt;/iframe> &lt;/div> &lt;div id=\"div2\" style=\"width:620px; height:500px ;float:left;overflow:scroll\" onscroll=\"funcsrcoll2()\"> &lt;iframe name=\"right\" id=\"right\" scrolling=\"no\" width=\"600px\" height=\"500px\" src=\"3.html\">&lt;/iframe> &lt;/div> &lt;script> //控制两个div的滚动条联动，便于页面对比 function funcsrcoll1() { div2.scrollLeft = div1.scrollLeft; div2.scrollTop = div1.scrollTop; } function funcsrcoll2() { div1.scrollLeft = div2.scrollLeft; div1.scrollTop = div2.scrollTop; } //调整iframe窗口大小适应src链接的页面 function func(){ $('iframe').each(function(){ this.style.height = this.contentWindow.document.body.scrollHeight+20 + 'px'; //为了显示完整，额外加了20px的宽度 this.style.width = this.contentWindow.document.body.scrollWidth+20 + 'px'; }); } &lt;/script>","tags":[{"name":"iframe","slug":"iframe","permalink":"http://dearxiaojie.top/tag/iframe/"},{"name":"scroll","slug":"scroll","permalink":"http://dearxiaojie.top/tag/scroll/"}]},{"title":"高性能JavaScript","date":"2015-05-24T11:12:54.000Z","path":"article/2015-05-24-高性能JavaScript.html","text":"javascript加载和运行脚本位置尽管浏览器已经允许并行下载javascript文件，但是javascript下载过程仍然会阻塞其他资源的下载，如图片。页面仍然需要等待所有javascript代码下载并执行完成才能继续所以优化javascript的首要原则：将脚本放在底部（&lt;/body&gt;之前) 组织脚本每个&lt;script&gt;标签初始下载都会阻塞页面渲染，所以减少页面包含的&lt;script&gt;标签数量有助于改善这一情况。考虑到到HTTP请求会额外带来性能的开销。下载单个100B的文件比下载4个25B的文件更快。所以，减少页面中外链脚本文件的数量会改善性能。 无阻塞的脚本 延迟的脚本：带有defer属性的&lt;script&gt;标签，需要浏览器支持 动态脚本元素:在跨浏览器兼容性和易用的优势，是最通用的无阻塞加载解决方案 XMLHttpRequest注入：先创建一个XHR对象，然后用她下载javascript文件，最后通过创建动态&lt;script&gt;元素将代码注入页面中 var xhr = new XMLHttpRequest(); xhr.open(\"get\",\"file.js\",true); xhr.onreadystatechange = funtion(){ if(xhr.readyState == 4){ if(xhr.status>=200&amp;&amp;xhr.status&lt;300||xhr.status==304){ var script = document.creatElement(\"script\"); script.type=\"text/javascript\"; script.text=xhr.responseText; document.body.appendChild(script); } } }; xhr.send(null); //由于代码是在&lt;script>标签之前返回的，因此它下载后不会自动执行。 //同样的代码在所有主流浏览器中无一例外都能正常工作 //局限性在于：javascript文件必须与请求的页面处于相同的域，即javascript不能从CDN下载 无阻塞脚本加载工具lazyLoad类库、LABjs等等 ##管理作用域 作用域链和标识符解析在函数执行的过程中，没遇到一个变量，都会经历一次标识符解析过程以决定从哪里获取或存储数据。该过程搜索运行期上下文的作用域链，查找同名的标识符。搜索过程从作用域链头部开始也就是当前运行函数的活动对象，如果找到了，就使用这个标示符对应的变量；如果没有找到，继续搜索作用域链中的下一个对象，直到标识符被找到，或者没有可用于搜索的对象为止，这种情况下标识符被认为是未定义的。正是这个搜索过程影响了性能。 标识符解析的性能一个标识符所在的位置越深，他的读写速度就越慢，因此读写局部变量总是最快的，而读写全局变量通常是最慢的。全局变量总是存在于运行期上下文作用域链的最末端，因此是最远的。在没有优化javascript引擎的浏览器中，尽量使用局部变量，如果某个跨作用域的值在函数中被引用了多次，就把他存储到局部变量里。 function initUI() { var doc = document, bd = doc.body, links = doc.getElementByTagName('a'); var i = 0, len = links.length; while (i &lt; len) { update(links[i++]); } doc.getElementById('btn').onclick = function() { start(); }; bd.className = 'active' } //首先将document对象引用存储到局部变量doc中，全局变量的访问减少，当有很多全局变量 //被反复访问时，这种方法对性能的改善是很明显的。 闭包，作用域和内存将常用的跨作用域变量存储在局部变量中，然后访问局部变量嵌套的对象成员会明显影响性能，尽量少用通常来说，把常用的对象成员、数组元素、跨域变量保存在局部变量中来改善javascript性能，因为局部变量访问速度更快。 DOM function initHtml1(){ for(var i = 0;i&lt;15000;i++){ document.getElementById('here').innerHTML+='a'; } } function initHtml2(){ var html = \"\"; for(var i=0;i&lt;15000;i++){ html+='a'; } document.getElementById('here').innerHTML = html; } initHtml1()比initHtml2()速度慢很多，initHtml2()使用局部变量存储更新后的内容，减少了DOM访问，因此，减少DOM访问次数，讲运算尽量留在ECMAScript这端处理。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://dearxiaojie.top/tag/javascript/"},{"name":"性能优化","slug":"性能优化","permalink":"http://dearxiaojie.top/tag/性能优化/"}]}]