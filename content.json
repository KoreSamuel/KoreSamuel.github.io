[{"title":"使用git-cherry-pick","date":"2018-07-05T06:44:02.000Z","path":"article/2018-07-05-git-cherry-pick.html","text":"前言在一个项目中可能有多个功能并行开发着，开发完的代码通常就合到develop分支进行测试，即测试环境中会有多个功能在测试，而先后进入测试并不一定先后上线，很有可能因为某些原因，先开发的功能需要延期上线，后开发的功能测试完后得先上线。这时候需要将后开发的功能代码抽出来，git cherry-pick就派上用场 什么是 cherry-pickcherry-pick是git中的一个命令，像pull，push，commit一样。它可以用于将在其他分支上的 commit 修改，移植到当前的分支。如之前所说场景，就可以使用 cherry-pick 命令，将这个功能相关的 commit 提取出来，合入稳定版本的分支上。 如何使用 cherry-pickgit cherry-pick [--edit] [-n] [-m parent-number] [-s] [-x] [--ff] [-S[&lt;keyid>]] &lt;commit>…​ git cherry-pick --continue git cherry-pick --quit git cherry-pick --abort 常用的使用方式是 git cherry-pick commit-id 执行 git log --graph --oneline --all可以看到类似下面的log * f07407f (origin/develop, develop) feat: 这是第三个功能 * 948fa63 feat: 这是第二个功能 * ba09a70 feat: 这是第一个功能 * e6d4aef (HEAD -> master, origin/master, origin/HEAD) Initial commit 如果我们需要将第二个功能摘取出来，即commit-id为948fa63 git cherry-pick 948fa630 执行完之后会产生一个新的commitid,如果遇到有冲突，git diff或者用diff工具修改就行，顺利的话就可以正常提交了。此时执行 git log --graph --oneline --all * 762491f (HEAD -> develop, origin/develop) feat: 这是第二个功能 * f07407f feat: 这是第三个功能 * 948fa63 feat: 这是第二个功能 * ba09a70 feat: 这是第一个功能 * e6d4aef (origin/master, origin/HEAD, master) Initial commit 而当前的代码也是第二个功能时的代码。这时候\b第三个功能也要上线了,那就将它也摘出来吧 git cherry-pick -x f07407f 上面命令多了 -x 参数，这是更高级一点的用法，表示保留原提交的作者信息进行提交。当然，如果需要摘出多个commit-id,首先可以重复执行git cherry-pick，另外可以使用下面的方式 git cherry-pick &lt;start-commit-id>&lt;end-commit-id> 它的范围就是 start-commit-id 到 end-commit-id 之间所有的 commit-id，但是它这是一个 (前开\u001c，后闭] 的区间，也就是说，它将不会包含 start-commit-id 的 commit-id。而如果想要包含 start-commit-id 的话，就需要使用 ^ 标记一下，就会变成一个 [前闭，后闭] 的区间 参考 https://git-scm.com/docs/git-cherry-pick Understanding Git Cherry-pick: How to Use","tags":[{"name":"git","slug":"git","permalink":"http://dearxiaojie.top/tag/git/"}]},{"title":"javascirpt常用函数实现","date":"2018-07-03T12:02:30.000Z","path":"article/2018-07-03-javascirpt-common-method.html","text":"随手记录点好玩的东西 实现一个sleep函数// promise const sleep = time => { return new Promise(resolve => { setTimeout(resolve, time); }); }; const t1 = +new Date(); sleep(1000).then(() => { const t2 = +new Date(); console.log(t2 - t1); // 1005 }) //await/async const sleep = time => { return new Promise(resolve => { setTimeout(resolve, time); }); }; const ts = async () => { const t1 = +new Date(); await sleep(1000); const t2 = +new Date(); console.log(t2 - t1); } ts(); // 1001 在社区能找到一个https://github.com/erikdubbelboer/node-sleep,不过需要安装才能使用 const sleep = require('sleep'); const t1 = +new Date(); sleep.msleep(1000); const t2 = +new Date(); console.log(t2 - t1); // 1000 数组去重// 双重循环 const arr = [1, 2, 3, '4', 3, 1]; const unique = arr => { const rst = []; let i, j, len, lens; for (i = 0, len = arr.length; i &lt; len; i++) { let item = arr[i]; for (j = 0, lens = rst.length; j &lt; lens; j++) { if (item === rst[j]) { break; } } lens === j &amp;&amp; rst.push(item) } return rst; }; console.log(unique(arr)); //[ 1, 2, 3, '4' ] // filter/indexOf const arr = [1, 2, 3, '4', 3, 1]; const unique = arr => { return arr.filter((item, index, arr) => { return arr.indexOf(item) === index; }); }; console.log(unique(arr)); // [ 1, 2, 3, '4' ] // reduce 类似hash const arr = [1, 2, 3, '4', 3, 1]; const unique = arr => { return arr.reduce((acc, cur, index) => { return (!acc[cur] &amp;&amp; acc.push(cur), acc); }, []) } // hash const arr = [1, 2, 3, '4', 3, 1]; const unique = arr => { const hash = {}, rst = []; for (let i = 0, len = arr.length; i &lt; len; i++) { let cur = arr[i]; if (!hash[cur]) { rst.push(cur); hash[cur] = true; } } return rst; }; console.log(unique(arr)); // [ 1, 2, 3, '4' ] 但是如果数组元素不限于 Number 和 String 类型，为了保证 hash key 的唯一性，我们可以传递一个 hasher 函数处理 key。如下 const arr = [1, 2, 3, '4', 3, 1]; const arrs = [1, false, false, 'false', 2, {name: 'ming'}, '4', {name: 'ming'}, 1]; const unique = (arr, hasher) => { // 默认使用JSON.stringify,不过对于Function不适用，可传入其他处理方式 hasher = hasher || JSON.stringify; const rst = [], hash = {}; for (let i = 0, len = arr.length; i&lt; len; i++) { let cur = arr[i]; let hashkey = hasher(cur); if (!hash[hashkey]) { rst.push(cur); hash[hashkey] = true; } } return rst }; console.log(unique(arr)); // [ 1, 2, 3, '4' ] console.log(unique(arrs)); // [ 1, false, 'false', 2, { name: 'ming' }, '4' ] 当然啦，还有最终极的版本，那就是ES6提供的Set.不过处理的\b数据类型也是有限的，可以按情况选择\b哪种方式 const arr = [1, 2, 3, '4', 3, 1]; const arrs = [1, false, false, 'false', 2, {name: 'ming'}, '4', {name: 'ming'}, 1]; const unique = arr => [...new Set(arr)]; console.log(unique(arr)); // [ 1, 2, 3, '4' ] console.log(unique(arrs)); // [ 1, false, 'false', 2, { name: 'ming' }, '4', { name: 'ming' } ] 不符合预期 array-like 转成 array所谓array-like就是按照数组下标排序的对象，有length属性，如{0: &#39;aa&#39;, 1: &#39;bb&#39;, 2: &#39;cc&#39;, length: 3}; 将函数参数arguments转换成数组，常见的处理方式如下 const arr = Array.prototype.slice.call(arguments); // [ 'aa', 'bb', 'cc' ] // 或者 const arr = [].slice.call(arguments); // [ 'aa', 'bb', 'cc' ] 至于上面两种方式的区别，可以查看js中 [].slice 与 Array.prototype.slice 有什么区别?了解使用ES6之后，可以有另外两种方式 const arr = Array.from(arguments); // \band const arr = [...arguments]; // 适用于arguments 用数组reduce方法实现mapArray.prototype.map2 = function(callback) { const arr = this; return arr.reduce((acc, curr, index) => { prev.push(callback(acc, index)); return prev; }, []); } // test const testarr = [1,2,23,4,5,5]; const aftermap2 = testarr.map2((item, index) => { return { [index + '-' + item]: item } }); console.log(aftermap2) //[{\"0-1\":1},{\"1-2\":2},{\"2-23\":23},{\"3-4\":4},{\"4-5\":5},{\"5-5\":5}] // 实现filter同理 \b防抖函数debounce的实现 多次触发事件，在事件触发n秒后执行，如果在一个事件触发的n秒内又触发这个事件，那就以新的事件事件为准，继续等n秒后执行。常见window的resise，scroll，mousemove\b\b等 //第一版， 最简版 function debounce(fn, wait) { let timeout = void 0; return function () { clearTimeout(timeout); timeout = setTimeout(fn, wait); } } // 第二版，处理this function debounce(fn, wait) { let timeout = void 0; return function () { const ctx = this; clearTimeout(timeout) timeout = setTimeout(function() { fn.apply(ctx); }, wait) } } // 第三版 event对象， // 在事件处理函数中会提供事件对象event，如果不传，获取会是undefined function debounce(fn, wait) { let timeout = void 0; return function () { const ctx = this; const args = arguments; clearTimeout(timeout); timeout = setTimeout(function() { fn.apply(ctx, args); }, wait); } } 数组扁平化，实现一个flatten函数const flatten = arr => ( [].concat(...arr.map(item => Array.isArray(item) ? flatten(item) : item)) ); const arr = [1, [2], [[3], 4], 5]; console.log(flatten(arr)); // [1,2,3,4,5] 待续","tags":[]},{"title":"go-practice-follow-offical-tour","date":"2018-06-15T09:37:50.000Z","path":"article/2018-06-15-go-practice-follow-offical-tour.html","text":"最近在学习go相关的东西，以下为Go官方指南中的练习记录 循环与函数实现一个平方根函数：用牛顿法实现平方根函数 package main import ( \"fmt\" ) func Sqrt(x float64) float64 { z := x / 2 cnt := 10 for cnt > 0 { z -= (z * z - x) / (2 * z) cnt = cnt - 1 } return z } func main() { fmt.Println(Sqrt(3)) // 1.7320508075688772 } 切片实现 Pic。它应当返回一个长度为 dy 的切片，其中每个元素是一个长度为 dx，元素类型为 uint8 的切片。当你运行此程序时，它会将每个整数解释为灰度值（好吧，其实是蓝度值）并显示它所对应的图像 package main import \"golang.org/x/tour/pic\" func Pic(dx, dy int) [][]uint8 { pic := make([][]uint8, dy*dx) for i := 0; i &lt; dy; i++ { in := make([]uint8, dx) for j := 0; j &lt; dx; j++ { in[j] = uint8(1 &lt;&lt; uint8(j%8)) } pic[i] = in } return pic } func main() { pic.Show(Pic) } 映射实现 WordCount。它应当返回一个映射，其中包含字符串 s 中每个“单词”的个数。函数 wc.Test 会对此函数执行一系列测试用例，并输出成功还是失败 package main import ( \"strings\" \"golang.org/x/tour/wc\" ) func WordCount(s string) map[string]int { m := make(map[string]int) field := strings.Fields(s) for i := 0; i &lt; len(field); i++ { if m[field[i]] > 0 { m[field[i]] = m[field[i]] + 1 } else { m[field[i]] = 1 } } return m } /* output func main() { wc.Test(WordCount) } PASS f(\"I am learning Go!\") = map[string]int{\"I\":1, \"am\":1, \"learning\":1, \"Go!\":1} PASS f(\"The quick brown fox jumped over the lazy dog.\") = map[string]int{\"dog.\":1, \"The\":1, \"fox\":1, \"over\":1, \"the\":1, \"quick\":1, \"brown\":1, \"jumped\":1, \"lazy\":1} PASS f(\"I ate a donut. Then I ate another donut.\") = map[string]int{\"another\":1, \"I\":2, \"ate\":2, \"a\":1, \"donut.\":2, \"Then\":1} PASS f(\"A man a plan a canal panama.\") = map[string]int{\"plan\":1, \"canal\":1, \"panama.\":1, \"A\":1, \"man\":1, \"a\":2} */ 斐波纳契闭包实现一个 fibonacci 函数，它返回一个函数（闭包），该闭包返回一个斐波纳契数列 (0, 1, 1, 2, 3, 5, ...)。 package main import \"fmt\" func fibonacci() func() int { a, b, c := -1, 0, 0 return func() int { if a == -1 { a = 0 return a } else if a == 0 { a = 1 return a } else { c = a + b b = a a = c return c } } } func main() { f := fibonacci() for i := 0; i &lt; 10; i++ { fmt.Println(f()) } } // 0, 1, 1, 2, 3, 5, 8, 13, 21, 34 Stringer通过让 IPAddr 类型实现 fmt.Stringer 来打印点号分隔的地址。例如，IPAddr{1, 2, 3, 4} 应当打印为 “1.2.3.4”。 package main import \"fmt\" type IPAddr [4]byte func (ip IPAddr) String() string { var result string for i, v := range ip { result += fmt.Sprintf(\"%v\", v) if i &lt; len(ip) - 1 { result += \".\" } } return result } func main() { hosts := map[string]IPAddr{ \"loopback\": {127, 0, 0, 1}, \"googleDNS\": {8, 8, 8, 8}, } for name, ip := range hosts { fmt.Printf(\"%v: %v\\n\", name, ip) } } // loopback: 127.0.0.1 // googleDNS: 8.8.8.8 note(方法与指针) 带指针参数的函数必须接受一个指针,而以指针为接收者的方法被调用时，接收者既能为值又能为指针。 由于指针参数的函数方法有一个指针接收者，为方便起见，Go 会将语句 v.Scale(5) 解释为 (&amp;v).Scale(5)； 接受一个值作为参数的函数必须接受一个指定类型的值，而以值为接收者的方法被调用时，接收者既能为值又能为指针，方法调用 p.Abs() 会被解释为 (*p).Abs() 使用指针接收者的原因有二： 首先，方法能够修改其接收者指向的值。 其次，这样可以避免在每次调用方法时复制该值。若值的类型为大型结构体时，这样做会更加高效。","tags":[]},{"title":"使用JavaScript处理点九图","date":"2018-01-09T09:56:03.000Z","path":"article/2018-01-09-use-javascript-to-handle-9-patch.html","text":"前言在前端开发中，常会将图片作为某个元素的背景图，但是背景图的大小和比例和元素有偏差，所以一般要使元素有全背景的话，只能将图片拉伸。这里不考虑background-repeat。最好的办法还是将图片修改为比例和元素相同以等比缩放。使用微信或者QQ的人应该会发现聊天气泡，气泡会随着内容多少的改变而去适应它，但是并没有使气泡图片有拉伸的效果，这里就用到了点九图 点九图关于点九图这里不做过多介绍，简单来说，它是andriod平台的应用软件开发里的一种特殊的图片形式，扩展名为.9.png。它有两个重要的特点是：四周必须要有四条一像素纯黑的线或点；左上两条线控制拉伸区，右下两条线控制内容区。这里我们需要将上传的点九图片拉伸成指定的或者自适应的比例，在没有接触点九图之前根本没有任何想法，于是上github上找到一个在web端处理点九图的库，将代码拉取到本地即可看到demo。 分析阅读源码发现主要使用border-image和用canvas绘制两种方式实现。首先先取出点九图左边和上边1px，这里以水平方向为例： let tempCtx, tempCanvas; tempCanvas = document.createElement('canvas'); tempCtx = tempCanvas.getContext('2d'); tempCtx.drawImage(this.bgImage, 0, 0); let data = tempCtx.getImageData(0, 0, this.bgImage.width, 1).data; 上面的data存放的为只读的ImageData.data属性，返回Uint8ClampedArray,描述一个一维数组，包含以 RGBA 顺序的数据，数据使用 0 至 255（包含）的整数表示。然后遍历这个一维数组，每4位一个step，找到可拉伸的区间数量和区域。 NinePatch.prototype.getPieces = function(data, staticColor, repeatColor) { var tempDS, tempPosition, tempWidth, tempColor, tempType; var tempArray = new Array(); tempColor = data[4] + ',' + data[5] + ',' + data[6] + ',' + data[7]; tempDS = (tempColor == staticColor ? 's' : (tempColor == repeatColor ? 'r' : 'd')); tempPosition = 1; for (var i = 4, n = data.length - 4; i &lt; n; i += 4) { tempColor = data[i] + ',' + data[i + 1] + ',' + data[i + 2] + ',' + data[i + 3]; tempType = (tempColor == staticColor ? 's' : (tempColor == repeatColor ? 'r' : 'd')); if (tempDS != tempType) { // box changed colors tempWidth = (i / 4) - tempPosition; tempArray.push(new Array(tempDS, tempPosition, tempWidth)); tempDS = tempType; tempPosition = i / 4; tempWidth = 1 } } // push end tempWidth = (i / 4) - tempPosition; tempArray.push(new Array(tempDS, tempPosition, tempWidth)); return tempArray; } 上面的getPieces方法存放了可用于判断拉伸区间数量和可拉伸范围的数组。在将其传入绘制函数中。 for (var i = 0, n = this.horizontalPieces.length; i &lt; n; i++) { if (this.horizontalPieces[i][0] == 's') { tempStaticWidth += this.horizontalPieces[i][2]; } else { tempDynamicCount++; // 拉伸区间数量 } } fillWidth = (dWidth - tempStaticWidth) / tempDynamicCount; // 可拉伸区间 再将取得的水平和垂直的1px获取到的数组进行嵌套循环，去填充拉伸图片，这里就不贴代码了，可以查阅源码理解。 新问题找到的这种方式只能将图片进行放大，如果点九图比需要预览的图大，那就不适用了，还有个新问题是，点九图的宽或高跟预览图相比，有个的值大，有一个的值小，如：W点九 &gt; W预览，H点九 &lt; H预览。这种情景也不适用，所以考虑处理点九图。这里只说最终的解决办法，当点九图的宽或高其中一个大于预览图的对应值时，将对应边缩小到预览图的值，再将另一边等比缩小，产生新的点九图片，这样新的点九图肯定比预览图小，可以正常拉伸了。 if (this.div.offsetWidth &lt; this.bgImage.width &amp;&amp; this.div.offsetHeight > this.bgImage.height) { tmpCanvas.width = this.div.offsetWidth; tmpCanvas.height = Math.floor(this.bgImage.height * this.div.offsetWidth / this.bgImage.width); tmpCtx.drawImage(this.bgImage, 0, 0, this.div.offsetWidth, Math.floor(this.bgImage.height * this.div.offsetWidth / this.bgImage.width)); let tmpImage = new Image(); tmpImage.src = tmpCanvas.toDataURL(\"image/png\"); this.bakImage = this.bgImage; this.bgImage = tmpImage; } 遗留的问题按照上面的缩放方式，不论是宽还是高缩小，都会影响原点九图左边或者上面的1px的边界，导致在 getPieces方法中误取可拉伸区间值，这种情况一般发生在边界线离点九图非透明色边界距离较近时发生，暂时没有想到解决方案。想到其实这也是种模拟实现的方式，在实际的产品中不可能多用。不过这个过程收获也是挺大。有好的解决方案欢迎轻敲~~","tags":[{"name":"javascript","slug":"javascript","permalink":"http://dearxiaojie.top/tag/javascript/"},{"name":"canvas","slug":"canvas","permalink":"http://dearxiaojie.top/tag/canvas/"},{"name":"9-patch","slug":"9-patch","permalink":"http://dearxiaojie.top/tag/9-patch/"}]},{"title":"记一次多图上传+本地预览中遇到的问题","date":"2017-11-30T06:54:54.000Z","path":"article/2017-11-30-mutiple-image-upload.html","text":"在web开发中常会遇到图片预览的场景，比如在图片上传的情况下，一个办法是将图片上传到服务器之后，服务端将存储的URL返回来，然后异步通过URL加载刚上传的图片，达到图片的预览。但是在这个过程中会有两次web请求，一次是发送文件，一次是下载文件。我们可以在图片上传前就进行图片的预览，这样可以避免不必要的网络请求和等待。 图片添加&lt;input type=\"file\" id=\"uploadcontainer\" name=\"images\" multiple=\"multiple\" accept=\"image/*\"> 如上，input将type设置为file即可以上传文件，accept可以设置接收文件类型，这里是上传图片，所以设置成了image/*, multiple 属性可以支持多文件上传。 图片预览 以下代码默认加载了jquery // 监听图片添加 $('#uploadcontainer').on('change', function() { let files = $(this).prop('files'); that.preview(files); }); preview: function(files) { let that = this; // 遍历预览 $.each(files, function(index, item) { let fileReader = new FileReader(); let tpl = new Template($('#tpl').html()); fileReader.readAsDataURL(item); fileReader.onload = function(e) { that.FILES.push(item); // *** 图片onload过程中将图片存在一个全局的数组中,因为在预览过程中还会有分类等处理，会在真正上传的时候添加更多参数 html = tpl.render({ cover_url: e.currentTarget.result, title: item.name.split('.')[0], }); // ... 将html放到页面 }; }); } 图片上传 假定我们的接口只支持每次只能上传一张图片 upload: function(f, cb) { // 递归 (function uploads() { let file = f.shift(); if (file) { // 避免重名导致上传混乱，每次都重新创建新的对象 let formData = new FormData(); formData.append('image', file.image); formData.append('title', file.title); formData.append('category', file.category); $.ajax({ type: 'POST', url: '****', data: formData, contentType: false,// * cache: false, processData: false // * }).always(function(rst) { if (rst.ret == 1) { console.log(file.title + ' 上传中...') } else { console.log(ret.msg || file.title + ' 上传失败...') } uploads(); }); } else { console.log('上传完成...'); cb(); } })(); }, 后记 使用FormData对象，设置contentType为false, processData为false fileReader.onload的时候缓存图片，不然不能对应图片及增加的参数，导致图片和参数对应混乱 递归上传，每次创建FormData对象，避免重复上传和重名混乱","tags":[{"name":"js","slug":"js","permalink":"http://dearxiaojie.top/tag/js/"}]},{"title":"highcharts线型图表处理","date":"2017-08-29T07:05:40.000Z","path":"article/2017-08-29-diy-highcharts.html","text":"问题分析某次需求中，需要使用highcharts展示数据以对比。可是这批数据量级相差较大，如果在同一张图表中展示，会导致线条相隔很远或者没有波动幅度；还需要在点击某根线条的时候改变图表Y轴为当前线条数量级的，并处理他们的样式以区分。 那么，第一个问题，要在同一张表中展示不同量级的数据，且相互具有参考性，有个办法就是将数据统一处理成一个维度的，如数据归一化，将数据映射到0~1之间的小数，那不同量级的数据之间就有一定的参考性了。第二个问题的话本来想过改源码，但是感觉意义不大，使用场景不多，就找highcharts的api文档，各种拼接。差不多实现了需求. 数据归一化采用min-max标准化，也叫离差标准化，对原始数据的线性变化，结果落到[0, 1]之间。将需要处理的数据组，即series数据先处理，找到每组的最大最小，并计算. function normalizing(arr) { var data = []; for (var i = 0, len = arr.length; i &lt; len; i++) { var cur = arr[i].data; arr[i].visible = false; var name = arr[i].name; arr[i].showInLegend = false; var max = Math.max.apply(null, cur); var min = Math.min.apply(null, cur); var news = cur.map(function (x) { return (x - min) / max; }); var item = { name: name, data: news }; arr.push(item) } return arr; }; 上面代码中，将原数据的每个线条设置为不显示，再将归一化后的数据push到数组后面。即最终图表上显示的是处理后的数据绘制的线条，这样的操作会引发后面的问题，接下来会提到。 展示真实数据在上面一步中，将所有数据都处理成了[0, 1]之间的数据，那鼠标hover上去显示的就是计算后的数据。这显然不是我们想要的，所以才没有去除原来的数据。查看highcharts的api，发现可以改变hover显示的格式，那我只需要找到计算后与之相对应的原数据就能正确显示了。现在hover能够正确显示数据了，图表里的线条也有了一定的对比性，但是Y轴坐标依然是按照归一化后数据量级来的。在考虑到需要在点击线条的时候显示成其原数据量级的Y轴，所以采用以下办法。取出选中线条数据中的最大最小，按照归一化算法逆回去，那么其实现在图表中的线条已经不是[0, 1]之间的数据了，而是分别乘上点击线条最大值，并加上最小值后的数据。那么，Y轴的自然就变成了当前的数据量级。 function adjustSeries(activeName) { var data = chart.series; var max, min; for (var i = 0, len = 6; i &lt; len; i++) { var curName = data[i + 6].name var current = data[i]; if (curName === activeName) { max = Math.max.apply(null, current.yData); min = Math.min.apply(null, current.yData); } } for (var i = 6, len = originData.length; i &lt; len; i++) { var cur = originData[i].data || []; var newc = cur.map(function (item, index) { var cnt = Math.round(item * max) + min; return cnt; }); var upObj = { data: newc, lineWidth: 1, dashStyle: 'Dash', dataLabels: { enabled: false }, className: 'half-opacity' }; if (originData[i].name === activeName) { upObj = { data: newc, lineWidth: 4, dashStyle: 'Solid', dataLabels: { enabled: true }, className: 'no-opacity' } } chart.series[i].update(upObj); } }; 上面代码中的originData其实就是归一化后存起来的一个副本，因为后面每次点击都会使用这个数据，所以在存数据的时候一定要保证originData不变，存放的是真实数据，而不是数据引用，javascript基础知识，不清楚的可查看javascript中的深拷贝和浅拷贝。 使用到的API plotOptions.series.event.click 点击线条的时候处理相关逻辑 tooltip.formatter 更改鼠标hover的时候显示的数据和样式 chart.series[i].update 动态更新图表数据，定制线条样式 其他… reference Highcharts API 成品链接","tags":[{"name":"js","slug":"js","permalink":"http://dearxiaojie.top/tag/js/"}]},{"title":"在浏览器中懒加载ES2015模块","date":"2017-06-05T11:51:28.000Z","path":"article/2017-06-05-lazy-loading-es2015-modules-in-the-browser.html","text":"ES2015模块在浏览器懒加载 在过去的几年里，开发者们已经无情的将服务端网站移动到了客户端，前提是那样能使页面的性能得到提高。 然而，这可能是不够的。你是否考虑过你的网站也许加载更多于它实际用到的东西？遇到懒加载，一个延迟初始化（加载/分配）某个资源(代码/数据/静态资源)直到它需要的时候再加载。 与此同时，ES2015已经能在生产环境中使用了，通过一些transpilers如Babel。现在你不用参与到使用AMD还是CommonJS的战争中，参照这篇文章的描述（The mind-boggling universe of JavaScript Module strategies）,因为你可以写ES2015模块和让他们transpiled并交付给浏览器同时支持现有CommonJS或AMD模块。 在这篇文章中，我将讨论如何使用System.js同步(在页面加载的时候)和异步(懒加载)加载ES2015模块。 页面加载 vs 懒加载在浏览器上开发JavaScript代码执行时,你必须决定什么时候你让它执行。有一些代码必须在页面加载的同时就执行，比如SPA应用使用了一些框架如Angular，Ember，Backbone，或者React，这些代码可能通过一个或多个&lt;script&gt;标签，必须在一个页面请求返回到浏览器后被引用到HTML文档的主体结构中。 在另一方面，你可能有更多的代码块在一些特定的触发条件发生的时候在执行。经典的例子如： 内容折叠。比如一个评论面板，在用户滚动到页底的时候才显示 事件触发内容显示。比如一个放大的覆盖层，在用户点击图片的时候在显示 少数内容。比如一个‘免运费’的控件，只只用于一些小的页面上 有时间间隔的内容显示。比如一个客服聊天框 这样的话，对于给出一个类似上面的功能，如果他的触发条件未发生，他的代码块就永远不会被执行。因此，那个代码块在页面加载的时候明显是不需要的，是可以延迟加载的。 为了延迟加载，你只需要将在页面加载期间执行的代码从代码块中提取出来。这样在他的触发条件第一次发生的时候就被执行。 这种异步加载引用代码的方式，或者叫懒加载，在提升页面性能上扮演了一个重要的角色，从减少页面首屏时间和速度指数上来看的话。 为了学习更多关于对比页面加载和懒加载对页面性和速度指数的影响的知识，可以阅读这篇文章 Leveling up: Simple steps to optimize the Critical Rendering Path AMD陷阱AMD标准是为在浏览器上异步加载加载创造的，是第一个作为全局JavaScript文件散落在页面的成功替代品。根据Require.js文档: The AMD format comes from wanting a module format that was better than today’s “write a bunch of script tags with implicit dependencies that you have to manually order” and something that was easy to use directly in the browser. 它是基于模块设计模式Module Design Pattern的授权，有一个模块加载器，依赖注入和异步能力。它的一个主要的作用就是执行模块的懒加载。 尽管是一个可怕的想法，它带来了一些固有的复杂性：也就是说，之前理解运行时模块的timelines是不那么重要的。这就意味着开发者们需要知道每个异步模块是什么时候做它预期的工作的。 如果不明白这点，开发者们发现这样的情况：它有时候能正常工作，有时候不能。由于竞态，调试是非常困难的。因为这样的事情，AMD失去了大量的势头和牵引。 学习更多关于AMD的陷阱，查看Moving Past RequireJS ES2015模块101在继续下去之前，我们回顾一下ES2015模块。如果你已经非常熟悉了，那这是一个快速的复习。在ES2015中，模块已经成为官方JavaScript语言的一部分，它们非常强大而且很容易去掌握，站在CommonJS模块这个巨人的肩膀上的话。 作用域通常，一个ES2015模块所有的全局变量仅作用于自己这个文件，模块可以导出数据，也可以导入其他的模块。 导出和导入在一个你想导出的项目(如一个变量，函数、类)的前面加上一个关键词export就可以导出，在下面这个例子中，我们导出Dog和Wolf: // zoo.js var getBarkStyle = function(isHowler) { return isHowler? 'woooooow!': 'woof, woof!'; }; export class Dog { constructor(name, breed) { this.name = name; this.breed = breed; } bark() { return `${this.name}: ${getBarkStyle(this.breed === 'husky')}`; }; } export class Wolf { constructor(name) { this.name = name; } bark() { return `${this.name}: ${getBarkStyle(true)}`; }; } 让我们想想如果在一个单元测试（如Mocha/Chai）用引入这个模块。使用语法import &lt;object&gt; from &lt;path&gt;，至于&lt;object&gt;我们可以选择我们想导入的元素–命名导入（named imports）。接下来我们可以从chai中导入expect，同样，从Zoo中导入Dog和Wolf。这种命名导入的语法很像ES2015的另一个方便的特性–解构赋值 // zoo_spec.js import { expect } from 'chai'; import { Dog, Wolf } from '../src/zoo'; describe('the zoo module', () => { it('should instantiate a regular dog', () => { var dog = new Dog('Sherlock', 'beagle'); expect(dog.bark()).to.equal('Sherlock: woof, woof!'); }); it('should instantiate a husky dog', () => { var dog = new Dog('Whisky', 'husky'); expect(dog.bark()).to.equal('Whisky: woooooow!'); }); it('should instantiate a wolf', () => { var wolf = new Wolf('Direwolf'); expect(wolf.bark()).to.equal('Direwolf: woooooow!'); }); }); 默认如果你只有一个项目要导出，你可以使用export default来将你需要导出的项目作为一个对象 // cat.js export default class Cat { constructor(name) { this.name = name; } meow() { return `${this.name}: You gotta be kidding that I'll obey you, right?`; } } 导入默认的模块更简单，至于结构赋值就不再用到了，你可以直接从模块中导入 // cat_spec.js import { expect } from 'chai'; import Cat from '../src/cat'; describe('the cat module', () => { it('should instantiate a cat', () => { var cat = new Cat('Bugsy'); expect(cat.meow()).to.equal('Bugsy: You gotta be kidding that I\\'ll obey you, right?'); }); }); 学习更多关于ES2015模块的知识，查看文章Exploring ES6 — Modules. ES2015模块加载器和System.js惊奇的发现，ES2015实际上没有一个模块加载规范。这儿是一个非常受欢迎的对动态模块加载的提议–es6-module-loader–受System.js的启发。这个提议已经被撤回了，但是有个WhatWG在讨论阶段的新的加载规范和Domenic Denicola提出的动态导入规范。 然而，System.js目前是最常使用的支持ES2015的模块加载器实现之一，它支持ES2015，AMD，CommonJS和浏览器中的全局脚本，还有NodeJS。它提供了一个异步模块加载器（对比Require.js）和ES2015转换，通过Babel,Traceur或者Typescript。 System.js使用Promises-based API实现了异步模块加载。自从promises可以被链式调用和组合，这是非常长强大和方便的方法。举个例子，如果你想平行的加载多个模块，你可以使用Promises.all，当所有promises都被解决后，listener就可以被解除了。 最后，动态导入规范正在得到更多的牵引，而且已经被编入webpack 2。你可以看看它在webpack2指南上是如何工作的Code splitting with ES2015，这也是受system.js的启发，所以过度起来也很简单。 同步和异步导入模块为了以同步和异步两种方式说明模块的加载，这里有一个简单的项目，将会在页面加载的时候同步加载我们的Cat模块，在用户点击按钮的时候懒加载Zoo模块。代码的github地址lazy-load-es2015-systemjs。 让我们看一看主要的代码块中在页面加载时加载的代码，我们的main.js。 首先，注意通过import同步加载Cat时的表现，然后，创建了一个Cat的实例，调用它的方法meow()，然后添加结果到DOM中： // main.js // Importing Cat module synchronously import Cat from 'cat'; // DOM content node let contentNode = document.getElementById('content'); // Rendering cat let myCat = new Cat('Bugsy'); contentNode.innerHTML += myCat.meow(); 最后，注意通过System.import(&#39;zoo&#39;)异步导入Zoo，最后，Dog和Wolf分别调用他们的方法back()，再次将结果添加到DOM中： // Button to lazy load Zoo contentNode.innerHTML += `&lt;p>&lt;button id='loadZoo'>Lazy load &lt;b>Zoo&lt;/b>&lt;/button>&lt;/p>`; // Listener to lazy load Zoo document.getElementById('loadZoo').addEventListener('click', e => { // Importing Zoo module asynchronously System.import('zoo').then(Zoo => { // Rendering dog let myDog = new Zoo.Dog('Sherlock', 'beagle'); contentNode.innerHTML += `${myDog.bark()}`; // Rendering wolf let myWolf = new Zoo.Wolf('Direwolf'); contentNode.innerHTML += `&lt;br/>${myWolf.bark()}`; }); }); 结论掌握遵守页面加载最少必须加载和懒加载可延迟加载的模块可以明显的提升你的页面性能，AMD和CommonJS为ES2015模块铺路。你可以开始使用System.js加载ES2015模块，或者通过webpack 2使用动态导入规范。但是官方的解决方案至今还未发布。 referencelazy-loading-es2015-modules-in-the-browser","tags":[{"name":"ES2015","slug":"ES2015","permalink":"http://dearxiaojie.top/tag/ES2015/"}]},{"title":"8个npm常用技巧和简写","date":"2017-06-03T09:17:15.000Z","path":"article/2017-06-03-several-npm-shorthand-or-trick.html","text":"在篇文章里,将介绍一些非常有用的npm技巧。在这有许多我们不能完全覆盖,所以主要介绍和我们开发工作最相关和最有用的技巧。 最基本的一些简写为了大家在同一起跑线，特别是针对于我们的新手，下面先快速的复习一些基本的简写来保证没人忘记任何简单的东西。 安装package常规：npm install pkg 简写：npm i pkg 全局安装常规： npm install --global pkg 简写：npm i -g pkg 作为项目依赖常规：npm install --save pkg 简写： npm i -S pkg 作为开发依赖常规： npm install --save-dev pkg 简写： npm i -D pkg 更多的简写请查看npm的简写表接下来开始有趣的东西。 初始化一个package我们都知道使用npm init，这是我们创建一个package需要做的第一步。但是，在默认情况下，我们会不停的敲enter键，所以我们怎么避免呢。npm init -y 或 npm init -f就可以一次搞定。 测试命令另一个我们都会的命令是npm test，基本上每天都会使用很多次。倘若我告诉你减少约40%的字符后可以做同样的事呢？非常幸运，这里有个命令npm t，确实能够做到。 列举可用的脚本我们得到了一个新项目,不知道如何开始。通常想知道：如何运行它?哪些脚本可用?有一种方式是打开package.json文件，查看scripts部分。但是我们可以做的更好，所以我们可以简单的运行npm run，之后就可以获得可用脚本的列表。另一个方式是安装ntl(npm i -g ntl)，然后在项目根目录运行ntl，就会列举出可用脚本，并可以直接选择运行，非常方便。 列举已安装的packages类似于可用的脚本,有时候我们需要知道在我们的项目的依赖关系。再次的，我们可以打开package.json文件查看。但是我们已经知道我们可以做的更好，那就是npm ls --depth 0如果需要列出全局安装的packages，我们运行同样的命令加上-g标志。npm ls -g --depth 0 运行安装的可执行文件我们安装了一个包在我们的项目中,它带有一个可执行的文件,但只有通过npm脚本运行它。你想知道为什么,或者如何克服它吗?首先，我们理解为什么–当我们在我们终端执行命令的时候，其根本其实是在我们PATH环境变量中列举的路径中寻找同名的可执行文件。这就是他们可从任何地方访问的神奇之处。本地安装包在本地注册他们的可执行文件,所以他们没有列在我们的PATH中，也就不会被发现。当我们通过一个npm脚本运行可执行文件，它是如何工作的？好问题！因为这种方式运行时,是npm的一个小技巧,增加了一个额外的文件夹路径&lt;project-directory&gt;/node_modules/.bin到PATH，npm添加了一些更有趣的东西，你可以通过运行npm run env | grep &quot;$PATH&quot;看见它。你也可以只是运行npm run env来查看所有可用的环境变量。如果你想知道，node_modules/.bin巧好是本地安装包存放他们可执行文件的地方。例如，如果在你的项目中安装了mocha，直接在项目中运行./node_modules/.bin/mocha看有什么动作so easy,对吧？无论何时你想运行一个本地安装包的可执行文件，只需要运行./node_modules/.bin/&lt;command&gt; 在网上找你的package在package.json文件中，你可能会看到repository的入口(‘entry’)，想知道它有什么好处呢？要回答这个问题，只需要运行npm repo就可以在你的浏览器中看到。顺便说一下,npm home命令和npm homepage同样适用,如果你想在npmjs打开你的package，这里也有个不错的简写npm docs 在其他脚本前后运行脚本也许你熟悉某些脚本例如pretest,这个允许你定义在test脚本运行前运行的代码。你可能会惊讶地发现,你可以为每一个脚本增加预先和滞后执行的脚本,包括您自己的自定义脚本!对于使用npm作为构建工具和有很多脚本需要编排的项目来说，是非常有用的。 更换package的版本你有一个package，也许使用semver做版本控制，在一个新版本发布前需要更换版本。一种方式是打开package.json文件手动的改变版本，但在这里我们不这样。一个简单的方式是运行npm version加上major、minor或者patch。That’s all 最后另外值得一提的是一些组合命令，如npm it将会运行安装和测试命令，等同于npm install &amp;&amp; npm test,非常方便。如果你知道更多的有用的技巧,请在评论中分享一下吧! reference8-npm-tricks-you-can-use-to-impress-your-colleaguesshorthands-and-other-cli-niceties","tags":[{"name":"npm","slug":"npm","permalink":"http://dearxiaojie.top/tag/npm/"}]},{"title":"使用Python发送HTML邮件","date":"2017-05-25T16:13:29.000Z","path":"article/2017-05-26-use-python-smtp-to-send-mail.html","text":"这段时间在慢慢学习Python，正巧有个与Python相关的活，借此机会好练练手 为什么要学习Python呢，作为一个前端，为什么不学习nodejs，而选择学习Python，对呀，其实我也这么问自己，但是，有什么影响嘛，爱学啥学啥，我不觉得啥该学不该学。学了如果不用，也慢慢会忘。扯远了，其实我是比较喜欢Python的语法和它的严格缩进，学了一段时间后，发现还是有和es6/es7相似的方法。 SMTPSMTP是发送邮件的协议，Python内置对SMTP的支持，可以发送纯文本、HTML邮件。其中有两个用到的模块，email负责邮件构造，smtplib发送邮件。 '''using python send gmail''' # !/usr/bin/env python3 # -*- coding: utf-8 -*- import smtplib from email.header import Header from email.mime.text import MIMEText from email.mime.multipart import MIMEMultipart from email.utils import parseaddr, formataddr class SendGmail(object): '''send mail via gmail''' def __init__(self): self._from_addr = input('From:') self._password = input('Password:') self._to_addr = input('To:') self._smtp_server = smtplib.SMTP('smtp.gmail.com', 587) self._msg = MIMEMultipart('alternative') self._msg['From'] = self._format_addrs('&lt;%s>' % self._from_addr) # 发件人 self._msg['To'] = self._format_addrs('&lt;%s>' % self._to_addr) # 收件人 subject = 'hello python' self._msg['Subject'] = Header(subject, 'utf-8').encode() # 主题 def get_content(self, mail_tmp_path='mail.html'): '''get mail content''' page = mail_tmp_path file = open(page, 'r', encoding='utf8') content = file.read() content = content.replace('&lt;#send_name#>', self._from_addr) content = content.replace('&lt;#name#>', self._to_addr) self._msg.attach(MIMEText(content, 'html', 'utf-8')) def send_mail(self): '''send mail''' server = self._smtp_server server.ehlo() server.starttls() server.login(self._from_addr, self._password) server.sendmail(self._from_addr, [self._to_addr], self._msg.as_string()) print('success send to %s!' % self._to_addr) server.quit() @classmethod def _replace_tmp(cls, string): pass @classmethod def _format_addrs(cls, string): '''format addr''' name, addr = parseaddr(string) return formataddr((Header(name, 'utf-8').encode(), addr)) if __name__ == '__main__': MESSAGE = SendGmail() MESSAGE.get_content() MESSAGE.send_mail()","tags":[{"name":"Python","slug":"Python","permalink":"http://dearxiaojie.top/tag/Python/"},{"name":"SMTP","slug":"SMTP","permalink":"http://dearxiaojie.top/tag/SMTP/"},{"name":"mail","slug":"mail","permalink":"http://dearxiaojie.top/tag/mail/"}]},{"title":"使用Travis CI自动部署Hexo博客到Github上","date":"2017-05-04T15:27:53.000Z","path":"article/2017-05-04-use-travisci-build-your-hexo-site.html","text":"写在前面自从在github page上搭建博客以来，都是使用的hexo，每次都是通过hexo命令build生成静态文件，再push到github上，后来找到一个deploy插件，只需要填写好github的repos地址就好。但是源码的保存是个问题，更换电脑想要写博客很不方便，甚至蠢到将源码保存到u盘里面，这样每次提交后又要备份一次，很容易忘记。说到这里那为什么不将源码保存到github上呢。 其实也是因为懒，给博客换了几次主题后，使得博客源码很乱，甚至自己也忘了改了主题的哪些代码，加上主题也是个repos，直接提交博客源码是提不上的，涉及到子模块问题，麻烦。想到自己还喜欢改动别人的主题，索性将主题文件夹.git文件删掉，让他成为一个普通的文件夹，这样就能提交到github了。废话不多说，估计是很久没写博客了，没有重点，下面简单说说使用Travis CI自动部署Hexo博客到github上。 什么是Travis CI？ Travis CI 是目前新兴的开源持续集成构建项目，它与jenkins，GO的很明显的特别在于采用yaml格式，简洁清新独树一帜。目前大多数的github项目都已经移入到Travis CI的构建队列中，据说Travis CI每天运行超过4000次完整构建。 构建首先进入Travis CI官网，使用github账号登录，如下图登录成功后进入如下界面，以为我再此之前已经构建过，所以会用红色框内的内容，如果没有使用过是没有的。然后点击My Repositories右边的+，添加需要自动构建的repos，进入如下页面。可以看到这个界面会显示当前github账号的所以项目，如果没有显示，点击右上角的Sync account按钮，就可以同步过来了，点击需要构建的repos前面的按钮为ON，再点击其后的原形设置图标，进入如下界面如图中设置，将Build only if .travis.yml is present及另外两个设置为ON，功能如字面意思不多说。到目前为止，已经将需要构建的repos开启，那么，我们如何在将源码提交到github的时候，它就自动构建并将build后的静态文件push到我的静态文件branch或者repos呢（我是将build后的静态文件放到一个单独的repos了，也可以放在源码repos的另一个branch，例如起名叫hexo），接下来说如何让Travis CI访问github. Access Token我们需要在Travis上配置Access Token，就可以在构建完毕后自动push到github上保存静态文件的repos了。 生成Access Token登录github，进入个人主页，点击setting，进入界面后找到下图所指位置。点击Personal access tokens，进入页面后，在点击右上角Generate new token,会再次让输入github密码，然后在Token description下起一个名字，再勾选一些权限，我是全给勾选上了，在点击下面Generate token这里就不多截图了。复制生成的token码。 配置Travis CI回到Travis的setting页面，如上面图，在Environment Variables这一栏，点击Add，起一个名字到Name，将复制的token码粘贴到Value框中，到这步为止，已经完成了Travis的设置。到博客源码根目录，创建一个.travis.yml的配置文件，内容如下，附注释，注意缩进 language: node_js #设置语言 node_js: stable #设置相应的版本 install: - npm install #安装hexo及插件 script: - hexo clean #清除 - hexo g #生成 after_script: - cd ./public - git init - git config user.name \"swust-xiaoj\" #修改name - git config user.email \"swustxiaojie@163.com\" #修改email - git add . - git commit -m \"update site\" - git push --force \"https://${travis}@${GH_REF}\" master:master #travis是在Travis中配置token的名称 branches: only: - master #只监测master，可根据自己情况设置，若是存放同一个仓库，这儿可以选择存放源码的branch，如hexo env: global: - GH_REF: github.com/swust-xiaoj/tb.git #设置GH_REF，注意更改yourname 因为我是新起了一个repos来存放静态文件了，所以上面的GH_REF是对应那个repos地址，若是放同一个repos中，那这儿一般都是yourname.github.io那个仓库。到此，配置已经完成了。 创建文章我们可以创建一篇文章hexo new post use-travis-build-your-hexo-site，添加内容后，并push到github，正常情况下，进入Travis网站就可以看到已经在构建了，如图完成后，访问链接就可以看到这篇文章了。 写在后面很久没有花时间写点东西了，不管有没有价值，总是一种对知识的积累和总结，输出也意味着输入，所以以后还是将学到的东西和积累总结下，自己可以将知识梳理的同时能帮助到别人是更好的了。 更新master commit 树被清空仔细查看上面的配置文件，我们发现每次都是将 public 目录下的文件重新生成了一个git项目，然后强制覆盖提交到了 master 分支下，这就是问题的所在。为了解决这个问题，我将配置文件改为了如下的内容： after_script: - git clone https://${GH_REF} .deploy_git - cd .deploy_git - git checkout master - cd ../ - mv .deploy_git/.git/ ./public/ - cd ./public - git config user.name \"swust-xiaoj\" #修改name - git config user.email \"swustxiaojie@163.com\" #修改email - git add . - git commit -m \"Travis CI Auto Builder\" - git push --force --quiet \"https://${travis}@${GH_REF}\" master:master #travis是在Travis中配置token的名称 在 after_script 部分，我先将博客项目 clone 到本地的 .deploy_git 目录下（目录名可自定义）,然后切换到 master 分支，将 master 分支下的 .git 目录拷贝到了 public 目录下，接着继续后面的 commit 操作。 添加 commit 时间戳按照前面的方法配置 travis.yml 的内容，在 master 分支下的提交记录是这样的： Travis CI Auto Builder Travis CI Auto Builder Travis CI Auto Builder ... 看到每次的提交记录中没有提交的时间戳，所以考虑着要把 commit 的时间戳给加上。script 命令下是可以执行 shell 命令的，所以对 travis.yml 文件进行了修改。在 shell 中获取当前的时间戳，可以这样: #/bin/bash > date +\"%Y-%m-%d %H:%M\" 2018-05-05 12:13 Travis CI 中使用的linux系统在编译生成时使用的是UTC时间，这样我们在github中的提交列表中看到的提交时间就会晚8小时。我们需要在执行时将时区改为东八区。 before_install: - export TZ='Asia/Shanghai' 然后将after_script中的命令移到单独的shell文件中。最终的两个文件内容如下 > build.sh #!/bin/bash set -ev git clone https://${GH_REF} .deploy_git cd .deploy_git git checkout master cd ../ mv .deploy_git/.git/ ./public/ cd ./public git config user.name \"swust-xiaoj\" #修改name git config user.email \"swustxiaojie@163.com\" #修改email git add . git commit -m \"Travis CI Auto Builder at `date +\"%Y-%m-%d %H:%M\"`\" git push --force --quiet \"https://${travis}@${GH_REF}\" master:master #travis是在Travis中配置token的名称 > .travis.yml language: node_js node_js: stable cache: apt: true directories: - node_modules before_install: - export TZ='Asia/Shanghai' # 更改时区 - npm install hexo-cli -g - chmod +x ./build.sh # 为shell文件添加可执行权限 install: - npm install script: - hexo clean - hexo g after_script: - ./build.sh branches: only: - master env: global: - GH_REF: github.com/swust-xiaoj/swust-xiaoj.github.io.git 参考 Customizing the Build IT 范儿 | 使用Travis CI自动部署Hexo博客","tags":[{"name":"hexo","slug":"hexo","permalink":"http://dearxiaojie.top/tag/hexo/"}]},{"title":"Show 'Search' button in iPhone/iPad Safari keyboard","date":"2016-10-23T09:36:09.000Z","path":"article/2016-10-23-search-btn.html","text":"问题描述点击搜索框的时候，需要将软键盘的return go 前往 按键文案变成 搜索或 search，并且点击的时候发起搜索。实现方式是将input框type 设置成 search，并在外层套一个form，在一般浏览器如QQ浏览器，uc浏览器等上能将软键盘显示成搜索,但是在safari浏览器上并不能正常将软键盘文案改变。 解决办法在form上设置action,并将其值设置成.,但是需要控制在搜索的时候应将表单默认行为拦截，form上添加return false即可。 源代码&lt;!-- 搜索框 --> &lt;form class=\"search-top\" action=\".\"> &lt;div class=\"search-wrap\"> &lt;input type=\"search\" name='key' id='search-input' placeholder=\"keyword...\" autocapitalize=\"off\" autocomplete=\"off\" autocorrect=\"off\" > &lt;span class=\"search\">&lt;i class=\"icon-search\">&lt;/i>&lt;/span> &lt;i class=\"icon-reset reset\">&lt;/i> &lt;/div> &lt;div class=\"cancel-btn\">取消&lt;/div> &lt;/form> $('.search-top').on('submit', function (e) { var text = $('#search-input').val().trim(); text &amp;&amp; that.emit.emit('search', text); return false; }); reference Show ‘Search’ button in iPhone/iPad Safari keyboard","tags":[{"name":"CSS","slug":"CSS","permalink":"http://dearxiaojie.top/tag/CSS/"}]},{"title":"Gulp Connect发送post请求返回405","date":"2016-04-10T13:29:57.000Z","path":"article/2016-04-10-Gulp Connect发送post请求返回405.html","text":"问题在使用gulp过程中，遇到了在使用gulp-connect启动服务的时候，发送ajax请求不能发送post，返回错误: 405 Method Not Allowed 解决通过自定义一个中间件来完成POST、PUT、DELETE 请求。首先，引入fs、path和connect var fs = require('fs'), path = require('path'), connect = require('gulp-connect'); 接着，在配置中增加自己的中间件。 gulp.task('server',function(){ connect.server({ middleware: function(connect, options) { return [ function(req, res, next) { var filepath = path.join(options.root, req.url); if ('POSTPUTDELETE'.indexOf(req.method.toUpperCase()) > -1 &amp;&amp; fs.existsSync(filepath) &amp;&amp; fs.statSync(filepath).isFile()) { return res.end(fs.readFileSync(filepath)); } return next(); } ]; }, hostname: '127.0.0.1', port: 8090, livereload: true }); }); References让 Gulp Connect 支持 POST、PUT、DELETE 请求","tags":[{"name":"gulp","slug":"gulp","permalink":"http://dearxiaojie.top/tag/gulp/"}]},{"title":"删除node_modules不成功","date":"2015-11-23T11:11:31.000Z","path":"article/2015-11-23-删除node-modules不成功.html","text":"Question Windows做Node.js开发的你或许碰到过无法删除node_modules文件夹的情况,如下图： Reasonwindows 在文件目录的长度有限制，因为node packages 有众多dependencies，每一个dependency又有其他的dependency，这些dependency或许还有其他的dependency，所以导致node_modules有超级复杂的文件目录。比如： D:\\codetest\\node_modules\\edpx-mobile\\node_modules\\edp-webserver\\node_modules\\babel\\node_modules\\chokidar\\node_modules\\anymatch\\node_modules Solutioninstallnpm install -g rimraf deleterimraf node_modules 亲测有效","tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://dearxiaojie.top/tag/nodejs/"}]},{"title":"remove white space below image","date":"2015-10-20T10:23:18.000Z","path":"article/2015-10-20-remove-white-space-below-image.html","text":"最近遇到过关于&lt;img&gt;标签显示一张图片在一个&lt;div&gt;里面，&lt;div&gt;的宽高由image撑起。可是在图片的底部和&lt;div&gt;底部之间，多出神秘的2~3px的空白。如下图：我知道&lt;img&gt;是个特殊的元素，为什么会出现这种现象？ Reason&lt;img&gt; 元素在默认情况下是inline元素，inline元素默认和父级元素的baseline对齐的，而baseline又和父级底边有一定距离，注意下面两段文字。 Look at this line of text. Notice there are no letters that breach the baseline 另一段： By just crossing the bridge he probably got away. 注意比较上面两段文字中字母y,j,p,g,下图更形象的显示因为浏览器提供空间低于inline元素来适应字体。这就是上面出现的白边。这不是CSS的padding或margin,所以开发中不容易发现。 Solution 给&lt;img&gt;元素设置display:block 给&lt;img&gt;元素设置vertical-align:bottom或者vertical-align:top 给&lt;img&gt;元素设置font-size:0; vertical-align:middle; 给&lt;div&gt;元素设置line-height:0 给&lt;div&gt;元素设置font-size:0 给&lt;img&gt;元素设置vertical-align:text-bottom 以上最后一条效果并不好，设置后仍有1px的白边，如下图：而正常处理后是没有白边的，如下图： Code source源码与在线演示 References Mystery white space underneath image tag How to Remove the Space Below Images and Other Inline-Block Elements Remove white space below image 欢迎补充","tags":[{"name":"CSS","slug":"CSS","permalink":"http://dearxiaojie.top/tag/CSS/"}]},{"title":"CSS伪元素::after提示用法","date":"2015-09-05T11:40:37.000Z","path":"article/2015-09-05-CSS伪元素-after.html","text":"概述CSS伪元素::after用来匹配已选中元素的一个虚拟的最后子元素，通常会配合content属性来为该元素添加装饰内容.这个虚拟元素默认是行内元素 语法 element:after { style properties } / CSS2 语法 /element::after { style properties } / CSS3 语法 / ::after表示法是在CSS 3中引入的,::符号是用来区分伪类和伪元素的.支持CSS3的浏览器同时也都支持CSS2中引入的表示法:after. ##例子 用::after伪元素，attr()CSS表达式和一个自定义数据属性 data-descr 创建一个纯CSS, 词汇表提示工具 &lt;body> &lt;p>这是一段并没有什么用的 &lt;span data-descr='collection of words and punctuation'>文字&lt;/span> ，完全是为了凑数才出现的文字，实现一个 &lt;span data-descr='small popups which also hide again'>提示&lt;/span> 功能，可以吧鼠标放上去 &lt;span data-descr='not to be taken literrlly'>看看&lt;/span> &lt;/p> &lt;/body> span[data-descr] { position: relative; text-decoration: underline; color: #00F; cursor: help; } span[data-descr]:hover::after { content: attr(data-descr); position: absolute; left: 0; top: 24px; min-width: 200px; border: 1px #aaaaaa solid; border-radius: 10px; background-color: #ffffcc; padding: 12px; color: #000000; font-size: 14px; z-index: 1; } 在线演示 效果图 浏览器兼容性 References ::after (:after)","tags":[{"name":"CSS","slug":"CSS","permalink":"http://dearxiaojie.top/tag/CSS/"}]},{"title":"图解Javascript上下文与作用域","date":"2015-08-04T06:54:54.000Z","path":"article/2015-08-04-图解Javascript上下文与作用域.html","text":"本文尝试阐述Javascript中的上下文与作用域背后的机制，主要涉及到执行上下文（execution context）、作用域链（scope chain）、闭包（closure）、this等概念。 Execution context执行上下文（简称上下文）决定了Js执行过程中可以获取哪些变量、函数、数据，一段程序可能被分割成许多不同的上下文，每一个上下文都会绑定一个变量对象（variable object），它就像一个容器，用来存储当前上下文中所有已定义或可获取的变量、函数等。位于最顶端或最外层的上下文称为全局上下文（global context），全局上下文取决于执行环境，如Node中的global和Browser中的window：需要注意的是，上下文与作用域（scope）是不同的概念。Js本身是单线程的，每当有function被执行时，就会产生一个新的上下文，这一上下文会被压入Js的上下文堆栈（context stack）中，function执行结束后则被弹出，因此Js解释器总是在栈顶上下文中执行。在生成新的上下文时，首先会绑定该上下文的变量对象，其中包括arguments和该函数中定义的变量；之后会创建属于该上下文的作用域链（scope chain），最后将this赋予这一function所属的Object，这一过程可以通过下图表示： this上文提到this被赋予function所属的Object，具体来说，当function是定义在global对中时，this指向global；当function作为Object的方法时，this指向该Object： var x = 1; var f = function(){ console.log(this.x); } f(); // -> 1 var ff = function(){ this.x = 2; console.log(this.x); } ff(); // -> 2 x // -> 2 var o = {x: \"o's x\", f: f}; o.f(); // \"o's x\" Scope chain上文提到，在function被执行时生成新的上下文时会先绑定当前上下文的变量对象，再创建作用域链。我们知道function的定义是可以嵌套在其他function所创建的上下文中，也可以并列地定义在同一个上下文中（如global）。作用域链实际上就是自下而上地将所有嵌套定义的上下文所绑定的变量对象串接到一起，使嵌套的function可以“继承”上层上下文的变量，而并列的function之间互不干扰： var x = 'global'; function a(){ var x = \"a's x\"; function b(){ var y = \"b's y\"; console.log(x); }; b(); } function c(){ var x = \"c's x\"; function d(){ console.log(y); }; d(); } a(); // -> \"a's x\" c(); // -> ReferenceError: y is not defined x // -> \"global\" y // -> ReferenceError: y is not defined Closure如果理解了上文中提到的上下文与作用域链的机制，再来看闭包的概念就很清楚了。每个function在调用时会创建新的上下文及作用域链，而作用域链就是将外层（上层）上下文所绑定的变量对象逐一串连起来，使当前function可以获取外层上下文的变量、数据等。如果我们在function中定义新的function，同时将内层function作为值返回，那么内层function所包含的作用域链将会一起返回，即使内层function在其他上下文中执行，其内部的作用域链仍然保持着原有的数据，而当前的上下文可能无法获取原先外层function中的数据，使得function内部的作用域链被保护起来，从而形成“闭包”。看下面的例子： var x = 100; var inc = function(){ var x = 0; return function(){ console.log(x++); }; }; var inc1 = inc(); var inc2 = inc(); inc1(); // -> 0 inc1(); // -> 1 inc2(); // -> 0 inc1(); // -> 2 inc2(); // -> 1 x; // -> 100 执行过程如下图所示，inc内部返回的匿名function在创建时生成的作用域链包括了inc中的x，即使后来赋值给inc1和inc2之后，直接在global context下调用，它们的作用域链仍然是由定义中所处的上下文环境决定，而且由于x是在function inc中定义的，无法被外层的global context所改变，从而实现了闭包的效果： this in closure我们已经反复提到执行上下文和作用域实际上是通过function创建、分割的，而function中的this与作用域链不同，它是由执行该function时当前所处的Object环境所决定的，这也是this最容易被混淆用错的一点。一般情况下的例子如下： var name = \"global\"; var o = { name: \"o\", getName: function(){ return this.name } }; o.getName(); // -> \"o\" 由于执行o.getName()时getName所绑定的this是调用它的o，所以此时this == o；更容易搞混的是在closure条件下： var name = \"global\"; var oo = { name: \"oo\", getNameFunc: function(){ return function(){ return this.name; }; } } oo.getNameFunc()(); // -> \"global\" 此时闭包函数被return后调用相当于： getName = oo.getNameFunc(); getName(); // -> \"global\" 换一个更明显的例子： var ooo = { name: \"ooo\", getName: oo.getNameFunc() // 此时闭包函数的this被绑定到新的Object }; ooo.getName(); // -> \"ooo\" 当然，有时候为了避免闭包中的this在执行时被替换，可以采取下面的方法： var name = \"global\"; var oooo = { name: \"ox4\", getNameFunc: function(){ var self = this; return function(){ return self.name; }; } }; oooo.getNameFunc()(); // -> \"ox4\" 或者是在调用时强行定义执行的Object： var name = \"global\"; var oo = { name: \"oo\", getNameFunc: function(){ return function(){ return this.name; }; } } oo.getNameFunc()(); // -> \"global\" oo.getNameFunc().bind(oo)(); // -> \"oo\" 总结Js是一门很有趣的语言，由于它的很多特性是针对HTML中DOM的操作，因而显得随意而略失严谨，但随着前端的不断繁荣发展和Node的兴起，Js已经不再是”toy language”或是jQuery时代的”CSS扩展”，本文提到的这些概念无论是对新手还是从传统Web开发中过度过来的Js开发人员来说，都很容易被混淆或误解，希望本文可以有所帮助。 写这篇总结的原因是我在Github上分享的Learn javascript in one picture，刚开始有人质疑这只能算是一张语法表（syntax cheat sheet），根本不会涉及更深层的闭包、作用域等内容，但是出乎意料的是这个项目竟然获得3000多个star，所以不能虎头蛇尾，以上。 References Understanding Scope and Context in JavaScript this - JavaScript | MDN 闭包 - JavaScript | MDN 原文猛戳","tags":[{"name":"javascript","slug":"javascript","permalink":"http://dearxiaojie.top/tag/javascript/"},{"name":"概念理解","slug":"概念理解","permalink":"http://dearxiaojie.top/tag/概念理解/"}]},{"title":"javascript性能优化小知识","date":"2015-07-27T02:22:26.000Z","path":"article/2015-07-27-javascript性能优化小知识.html","text":"前面有一篇也是关于javascript性能方面的文章，是看了《高性能javascript》后的笔记，这是一篇自己在项目和学习过程中的积累，部分参考了一些学习博客。对面试和代码的编写都有帮助。 避免全局查找在一个函数中会用到全局对象存储为局部变量来减少全局查找，因为访问局部变量的速度要比访问全局变量的速度更快些。 字符串的连接如果要连接多个字符串，应该少使用+=，如 s+=a; s+=b; s+=c; 应该写成s+=a + b + c；而如果是收集字符串，比如多次对同一个字符串进行+=操作的话，最好使用一个缓存，使用JavaScript数组来收集，最后使用join方法连接起来。 数字转换成字符串(&quot;&quot; +) &gt; String() &gt; .toString() &gt; new String()字符串如’1322’转换成数字的时候可以在前面加’+’,如var str = &#39;123&#39;;var num = +str,那么typeof num为number 浮点数转换成整型很多人喜欢使用parseInt()，其实parseInt()是用于将字符串转换成数字，而不是浮点数和整型之间的转换，我们应该使用Math.floor()或者Math.round()。 使用DocumentFragment优化多次append一旦需要更新DOM,请考虑使用文档碎片来构建DOM结构，然后再将其添加到现存的文档中。 for (var i = 0; i &lt; 1000; i++) { var el = document.createElement('p'); el.innerHTML = i; document.body.appendChild(el); } //可以替换为： var frag = document.createDocumentFragment(); for (var i = 0; i &lt; 1000; i++) { var el = document.createElement('p'); el.innerHTML = i; frag.appendChild(el); } document.body.appendChild(frag); 使用一次innerHTML赋值代替构建dom元素对于大的DOM更改，使用innerHTML要比使用标准的DOM方法创建同样的DOM结构快得多。 var frag = document.createDocumentFragment(); for (var i = 0; i &lt; 1000; i++) { var el = document.createElement('p'); el.innerHTML = i; frag.appendChild(el); } document.body.appendChild(frag); //可以替换为： var html = []; for (var i = 0; i &lt; 1000; i++) { html.push('&lt;p>' + i + '&lt;/p>'); } document.body.innerHTML = html.join(''); 使用事件代理任何可以冒泡的事件都不仅仅可以在事件目标上进行处理，目标的任何祖先节点上也能处理，使用这个知识就可以将事件处理程序附加到更高的地方负责多个目标的事件处理，同样，对于内容动态增加并且子节点都需要相同的事件处理函数的情况，可以把事件注册提到父节点上，这样就不需要为每个子节点注册事件监听了。另外，现有的js库都采用observe方式来创建事件监听,其实现上隔离了DOM对象和事件处理函数之间的循环引用,所以应该尽量采用这种方式来创建事件监听 缩短否定检测if (oTest != '#ff0000') { //do something } if (oTest != null) { //do something } if (oTest != false) { //do something } //虽然这些都正确，但用逻辑非操作符来操作也有同样的效果： if (!oTest) { //do something } 条件分支将条件分支，按可能性顺序从高到低排列：可以减少解释器对条件的探测次数在同一条件子的多（&gt;2）条件分支时，使用switch优于if：switch分支选择的效率高于if，在IE下尤为明显。4分支的测试，IE下switch的执行时间约为if的一半。使用三目运算符替代条件分支 if (a > b) { num = a; } else { num = b; } //可以替换为： num = a > b ? a : b; 续。。。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://dearxiaojie.top/tag/javascript/"},{"name":"性能优化","slug":"性能优化","permalink":"http://dearxiaojie.top/tag/性能优化/"}]},{"title":"高性能JavaScript","date":"2015-05-24T11:12:54.000Z","path":"article/2015-05-24-高性能JavaScript.html","text":"javascript加载和运行脚本位置尽管浏览器已经允许并行下载javascript文件，但是javascript下载过程仍然会阻塞其他资源的下载，如图片。页面仍然需要等待所有javascript代码下载并执行完成才能继续所以优化javascript的首要原则：将脚本放在底部（&lt;/body&gt;之前) 组织脚本每个&lt;script&gt;标签初始下载都会阻塞页面渲染，所以减少页面包含的&lt;script&gt;标签数量有助于改善这一情况。考虑到到HTTP请求会额外带来性能的开销。下载单个100B的文件比下载4个25B的文件更快。所以，减少页面中外链脚本文件的数量会改善性能。 无阻塞的脚本 延迟的脚本：带有defer属性的&lt;script&gt;标签，需要浏览器支持 动态脚本元素:在跨浏览器兼容性和易用的优势，是最通用的无阻塞加载解决方案 XMLHttpRequest注入：先创建一个XHR对象，然后用她下载javascript文件，最后通过创建动态&lt;script&gt;元素将代码注入页面中 var xhr = new XMLHttpRequest(); xhr.open(\"get\",\"file.js\",true); xhr.onreadystatechange = funtion(){ if(xhr.readyState == 4){ if(xhr.status>=200&amp;&amp;xhr.status&lt;300||xhr.status==304){ var script = document.creatElement(\"script\"); script.type=\"text/javascript\"; script.text=xhr.responseText; document.body.appendChild(script); } } }; xhr.send(null); //由于代码是在&lt;script>标签之前返回的，因此它下载后不会自动执行。 //同样的代码在所有主流浏览器中无一例外都能正常工作 //局限性在于：javascript文件必须与请求的页面处于相同的域，即javascript不能从CDN下载 无阻塞脚本加载工具lazyLoad类库、LABjs等等 ##管理作用域 作用域链和标识符解析在函数执行的过程中，没遇到一个变量，都会经历一次标识符解析过程以决定从哪里获取或存储数据。该过程搜索运行期上下文的作用域链，查找同名的标识符。搜索过程从作用域链头部开始也就是当前运行函数的活动对象，如果找到了，就使用这个标示符对应的变量；如果没有找到，继续搜索作用域链中的下一个对象，直到标识符被找到，或者没有可用于搜索的对象为止，这种情况下标识符被认为是未定义的。正是这个搜索过程影响了性能。 标识符解析的性能一个标识符所在的位置越深，他的读写速度就越慢，因此读写局部变量总是最快的，而读写全局变量通常是最慢的。全局变量总是存在于运行期上下文作用域链的最末端，因此是最远的。在没有优化javascript引擎的浏览器中，尽量使用局部变量，如果某个跨作用域的值在函数中被引用了多次，就把他存储到局部变量里。 function initUI() { var doc = document, bd = doc.body, links = doc.getElementByTagName('a'); var i = 0, len = links.length; while (i &lt; len) { update(links[i++]); } doc.getElementById('btn').onclick = function() { start(); }; bd.className = 'active' } //首先将document对象引用存储到局部变量doc中，全局变量的访问减少，当有很多全局变量 //被反复访问时，这种方法对性能的改善是很明显的。 闭包，作用域和内存将常用的跨作用域变量存储在局部变量中，然后访问局部变量嵌套的对象成员会明显影响性能，尽量少用通常来说，把常用的对象成员、数组元素、跨域变量保存在局部变量中来改善javascript性能，因为局部变量访问速度更快。 DOM function initHtml1(){ for(var i = 0;i&lt;15000;i++){ document.getElementById('here').innerHTML+='a'; } } function initHtml2(){ var html = \"\"; for(var i=0;i&lt;15000;i++){ html+='a'; } document.getElementById('here').innerHTML = html; } initHtml1()比initHtml2()速度慢很多，initHtml2()使用局部变量存储更新后的内容，减少了DOM访问，因此，减少DOM访问次数，讲运算尽量留在ECMAScript这端处理。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://dearxiaojie.top/tag/javascript/"},{"name":"性能优化","slug":"性能优化","permalink":"http://dearxiaojie.top/tag/性能优化/"}]}]